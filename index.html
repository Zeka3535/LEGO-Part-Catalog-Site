<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Каталог деталей и наборов LEGO</title>

  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="manifest" href="site.webmanifest">
  <link rel="shortcut icon" href="favicon.ico">
  <meta name="msapplication-TileColor" content="#1a202c">
  <meta name="theme-color" content="#1a202c">

  <meta property="og:title" content="Каталог деталей и наборов LEGO">
  <meta property="og:description" content="Современное веб-приложение для каталогизации вашей личной коллекции LEGO. Включает детали, наборы и минифигурки в едином удобном интерфейсе.">
  <meta property="og:image" content="ogimage.png">
  <meta property="og:type" content="website">

  <script src="https://cdn.tailwindcss.com"></script>

      <style>
    body{font-family:sans-serif}.no-scrollbar::-webkit-scrollbar{display:none}.no-scrollbar{-ms-overflow-style:none;scrollbar-width:none}#search-input::-webkit-search-cancel-button{-webkit-appearance:none;appearance:none;display:none}.checkerboard{background-image:linear-gradient(45deg,#374151 25%,transparent 25%),linear-gradient(-45deg,#374151 25%,transparent 25%),linear-gradient(45deg,transparent 75%,#374151 75%),linear-gradient(-45deg,transparent 75%,#374151 75%);background-size:8px 8px;background-position:0 0,0 4px,4px -4px,-4px 0}.modal-hidden{display:none!important}.viewer-hidden{display:none!important}.loader{border:4px solid #4a5568;border-top:4px solid #4299e1;border-radius:50%;width:48px;height:48px;animation:spin 1s linear infinite}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes fadeIn{from{opacity:0}to{opacity:1}}@keyframes fadeOut{from{opacity:1}to{opacity:0}}@keyframes scaleIn{from{opacity:0;transform:scale(.95)}to{opacity:1;transform:scale(1)}}@keyframes scaleOut{from{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.95)}}@keyframes fadeInUp{from{opacity:0;transform:translateY(1rem)}to{opacity:1;transform:translateY(0)}}#modal-container,#filter-modal-container,#set-modal-container,#settings-modal-container,#minifig-modal-container,#image-viewer-container{opacity:0;transition:opacity .2s ease-out}#modal-container.visible,#filter-modal-container.visible,#set-modal-container.visible,#settings-modal-container.visible,#minifig-modal-container.visible,#image-viewer-container.visible{opacity:1}.modal-content-enter{animation:scaleIn .2s ease-out forwards}.modal-content-leave{animation:scaleOut .2s ease-out forwards}.part-card.animate-in,.set-card.animate-in,.minifig-card.animate-in{opacity:0;animation:fadeInUp .4s ease-out forwards}#color-selector-wrapper{transition:max-height .35s ease-in-out;overflow:hidden}#image-viewer-container img{transform:scale(.95);opacity:0;transition:transform .2s ease-out,opacity .2s ease-out}#image-viewer-container.visible img{transform:scale(1);opacity:1}
    
    /* Стили для кастомного выпадающего списка вариаций */
    #variation-select-button {
        max-width: 100% !important;
        width: 100% !important;
        box-sizing: border-box;
        text-overflow: ellipsis;
        white-space: nowrap;
        background-color: #374151 !important;
        border: 1px solid #4B5563 !important;
        border-radius: 6px !important;
        color: white !important;
        font-size: 14px !important;
        line-height: 1.5 !important;
        transition: all 0.2s ease !important;
        min-width: 0 !important;
        flex-shrink: 1 !important;
        cursor: pointer !important;
        user-select: none !important;
    }
    
    #variation-select-button:hover {
        border-color: #6B7280 !important;
        background-color: #4B5563 !important;
    }
    
    #variation-select-button:focus {
        outline: none !important;
        border-color: #3B82F6 !important;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5) !important;
    }
    
    #variation-select-button.open {
        border-color: #3B82F6 !important;
        background-color: #4B5563 !important;
    }
    
    #variation-select-button.open svg {
        transform: rotate(180deg) !important;
    }
    
    #variation-dropdown {
        position: absolute !important;
        z-index: 99999 !important;
        background-color: #374151 !important;
        border: 1px solid #4B5563 !important;
        border-radius: 6px !important;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05) !important;
        max-height: 240px !important;
        overflow-y: auto !important;
        transition: all 0.2s ease !important;
        box-sizing: border-box !important;
        min-width: 100% !important;
        max-width: 100% !important;
        top: 100% !important;
        left: 0 !important;
        right: 0 !important;
        margin-top: 4px !important;
    }
    
    .variation-option {
        max-width: 100% !important;
        width: 100% !important;
        overflow: hidden !important;
        text-overflow: ellipsis !important;
        white-space: nowrap !important;
        box-sizing: border-box;
        padding: 8px 12px !important;
        background-color: #374151 !important;
        color: white !important;
        cursor: pointer !important;
        transition: background-color 0.15s ease !important;
        border-bottom: 1px solid #4B5563 !important;
    }
    
    .variation-option:last-child {
        border-bottom: none !important;
    }
    
    .variation-option:hover {
        background-color: #4B5563 !important;
    }
    
    .variation-option.selected {
        background-color: #3B82F6 !important;
    }
    
    .variation-option.selected:hover {
        background-color: #2563EB !important;
    }
    
    /* Стили для контейнера */
    .variation-select-container {
        position: relative !important;
        width: 100% !important;
        max-width: 100% !important;
        overflow: visible !important;
    }
    
    /* Стили для неактивных кнопок */
    button[disabled] {
        opacity: 0.5 !important;
        cursor: not-allowed !important;
        pointer-events: none !important;
    }
    
    button[disabled]:hover {
        background-color: inherit !important;
        transform: none !important;
    }
    
    /* Убираем стандартную стрелку браузера */
    .variation-select-container::after {
        display: none !important;
    }
    
    /* Для мобильных устройств */
    @media (max-width: 768px) {
        #variation-select-button {
            font-size: 16px; /* Предотвращает зум на iOS */
        }
    }
  </style>
</head>
<body class="bg-gray-900 text-gray-200">
  <aside id="sidebar-container" class="w-80 bg-gray-800 p-4 flex flex-col h-full border-r border-gray-700 fixed inset-y-0 left-0 z-40 transition-transform duration-300 ease-in-out lg:translate-x-0 -translate-x-full"></aside>
  <div id="sidebar-backdrop" class="fixed inset-0 bg-black bg-opacity-60 z-30 hidden lg:hidden"></div>
  <div class="lg:ml-80 flex flex-col h-screen">
    <header id="header-container" class="bg-gray-800/50 backdrop-blur-sm sticky top-0 z-20 p-4 border-b border-gray-700"></header>
    <main id="main-content" class="flex-1 overflow-y-auto no-scrollbar"></main>
  </div>
  <div id="modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 backdrop-blur-sm modal-hidden"></div>
  <div id="set-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 backdrop-blur-sm modal-hidden"></div>
  <div id="minifig-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 backdrop-blur-sm modal-hidden"></div>
  <div id="filter-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 backdrop-blur-sm modal-hidden"></div>
  <div id="settings-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 backdrop-blur-sm modal-hidden"></div>
  <input type="file" id="import-csv-input" class="hidden" accept=".csv">
  <div id="image-viewer-container" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-[100] backdrop-blur-sm viewer-hidden">
    <img id="fullscreen-image" src="" alt="Полноэкранный просмотр" class="max-w-[90vw] max-h-[90vh] object-contain shadow-2xl rounded-lg">
    <button id="image-viewer-close" class="absolute top-4 right-4 text-white text-opacity-80 hover:text-opacity-100 p-2 rounded-full transition-opacity bg-black/30 hover:bg-black/50"></button>
  </div>
  <button id="scroll-to-top-btn" class="fixed bottom-6 right-6 bg-blue-600 text-white p-3 rounded-full shadow-lg hover:bg-blue-700 transition-all duration-300 opacity-0 pointer-events-none z-40 transform translate-y-4" aria-label="Вернуться наверх">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7"></path></svg>
  </button>
  <script type="module">

const REBRICKABLE_API_URL = 'https://rebrickable.com/api/v3/lego';
const REBRICKABLE_API_KEYS = ['20c78cc607d6059c8d2a61338d851590', '04a7405ad41f1dd484a562f6e0c57312', 'd93f5c0989f63afa9b1c29ef8ad66002', 'b4179c1b8bd3c022ec9fc0e713e96b77', 'd32527bc33b575b8825a0ba04ba4add5'];
let currentApiKeyIndex = 0;

function getApiKey() {
    const key = REBRICKABLE_API_KEYS[currentApiKeyIndex];
    currentApiKeyIndex = (currentApiKeyIndex + 1) % REBRICKABLE_API_KEYS.length;
    return key;
}
const CACHE_NAME = 'lego-catalog-cache-v4';
const COLOR_COLLAPSE_THRESHOLD = 18;
let COLOR_MAP = {},
    PART_MAP = {},
    SET_MAP = {},
    MINIFIG_MAP = {},
    THEME_MAP = {},
    flatCategories = [];

// Cache for color image URLs to avoid repeated API calls
const COLOR_IMAGE_CACHE = new Map();
const API_REQUEST_DELAY = 200; // 200ms delay between API requests
let lastApiRequestTime = 0;
const I_Cat = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>`;
const I_Coll = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polygon points="2 17 12 22 22 17"></polygon><polygon points="2 12 12 17 22 12"></polygon></svg>`;
const I_Set = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>`;
const I_Plus = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>`;
const I_Minus = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>`;
const I_X = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
const I_Menu = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>`;
const I_Up = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>`;
const I_Down = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>`;
const I_Img = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>`;
const I_Trash = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`;
const I_Search = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>`;
const I_Chev = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>`;
const I_Dice = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><path d="M16 8h.01"></path><path d="M12 12h.01"></path><path d="M8 16h.01"></path><path d="M8 8h.01"></path><path d="M16 16h.01"></path></svg>`;
const I_Brick = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="10" rx="2" ry="2"></rect><path d="M7 11V7a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v4"></path><path d="M12 11V7"></path></svg>`;
const I_Plate = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="15" width="18" height="6" rx="1"></rect><circle cx="8" cy="18" r="1"></circle><circle cx="16" cy="18" r="1"></circle></svg>`;
const I_Tech = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20.94c1.5 0 2.85-.93 3.53-2.28a3.99 3.99 0 0 0-7.06 0c.68 1.35 2.03 2.28 3.53 2.28z"></path><path d="M12 3.06c-1.5 0-2.85.93-3.53 2.28a3.99 3.99 0 0 0 7.06 0C14.85 3.99 13.5 3.06 12 3.06z"></path><path d="M3.06 12c0-1.5.93-2.85 2.28-3.53a3.99 3.99 0 0 0 0 7.06C3.99 14.85 3.06 13.5 3.06 12z"></path><path d="M20.94 12c0 1.5-.93 2.85-2.28 3.53a3.99 3.99 0 0 0 0-7.06c1.35.68 2.28 2.03 2.28 3.53z"></path><circle cx="12" cy="12" r="1"></circle></svg>`;
const I_Slope = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 20h18L3 4v16z"></path></svg>`;
const I_Tile = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>`;
const I_Win = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"></rect><path d="M3 12h18"></path><path d="M12 3v18"></path></svg>`;
const I_Wheel = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle></svg>`;
const I_Minifig = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="8" r="3"></circle><path d="M12 11v5"></path><path d="M9 22v-5h6v5"></path><path d="M9 11H5a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h4"></path><path d="M15 11h4a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-4"></path></svg>`;
const I_Bar = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12h16"></path><path d="M4 12a2 2 0 1 0-4 0 2 2 0 0 0 4 0z"></path><path d="M20 12a2 2 0 1 0 4 0 2 2 0 0 0-4 0z"></path></svg>`;
const I_Arch = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 21V11c0-3.87 3.13-7 7-7s7 3.13 7 7v10"></path><path d="M5 21h14"></path></svg>`;
const I_Other = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>`;
const I_Filter = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>`;
const I_Theme = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"></path></svg>`;
const I_Settings = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>`;
const I_Heart = (c, f = !1) => f ? `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>` : `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>`;
const I_Refresh = (c) => `<svg xmlns="http://www.w3.org/2000/svg" class="${c}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path></svg>`;

let S = {
    view: 'catalog',
    subView: 'parts',
    catTree: [],
    expCats: new Set,
    selCatId: null,
    selCollCatId: null,
    catGroups: null,
    favCatIds: new Set,
    themeTree: [],
    expThemes: new Set,
    selThemeId: null,
    selCollThemeId: null,
    setRes: null,
    favThemeIds: new Set,
    minifigRes: null,
    q: '',
    searchGroups: null,
    searchSetRes: null,
    searchMinifigRes: null,
    loading: !1,
    sidebarLoading: !1,
    err: null,
    selPartId: null,
    selSetNum: null,
    selFigNum: null,
    sidebarOpen: window.innerWidth >= 1024,
    gridStale: !0,
    hasMoreItems: false,
    partModal: {
        groupId: null,
        variants: [],
        selColorId: null,
        qty: 1,
        loadingColors: !1,
        loadingImg: !1,
        imgUrl: null
    },
    setModal: {
        loading: !1,
        inv: [],
        invPage: 1,
        hasNextInv: !1,
        qty: 1,
        bulkUpdate: !1,
        status: '',
        statusType: '',
        view: 'details',
        minifigs: [],
        loadingMinifigs: !1
    },
    minifigModal: {
        loading: !1,
        qty: 1,
        view: 'details',
        inv: null,
        loadingInv: !1,
        invError: !1,
        bulkUpdate: !1,
        status: '',
        statusType: ''
    },
    filterOpen: !1,
    settingsOpen: !1,
    settingsModal: {
        delConfirm: null,
        status: '',
        statusType: 'info'
    },
    toDisplay: 48,
    increment: 48,
    coll: {},
    setColl: {},
    minifigColl: {},
    filters: {
        colorIds: [],
        inCollectionOnly: !1
    },
    setFilters: {
        minYear: '',
        maxYear: '',
        minParts: '',
        maxParts: ''
    },
    sortBy: 'popularity'
};
let tempFilters = {
    filters: { colorIds: [], inCollectionOnly: false },
    setFilters: { minYear: "", maxYear: "", minParts: "", maxParts: "" },
    sortBy: 'popularity'
};

function loadState() {
    
    const e = localStorage.getItem('legoCollection');
    if (e) try {
        const t = JSON.parse(e);
        "object" == typeof t && null !== t && (S.coll = t)
    } catch (t) {
        console.error("Failed to parse lego collection from localStorage", t), S.coll = {}
    }
    const t = localStorage.getItem('legoSetCollection');
    if (t) try {
        const e = JSON.parse(t);
        "object" == typeof e && null !== e && (S.setColl = e)
    } catch (e) {
        console.error("Failed to parse lego set collection from localStorage", e), S.setColl = {}
    }
    
    // Note: We don't restore cached details from localStorage anymore
    // All data will be loaded fresh from CSV files
    console.log('User collections and favorites loaded from localStorage');
    
    const o = localStorage.getItem('legoMinifigCollection');
    if (o) try {
        const e = JSON.parse(o);
        "object" == typeof e && null !== e && (S.minifigColl = e)
    } catch (e) {
        console.error("Failed to parse lego minifig collection from localStorage", e), S.minifigColl = {}
    }
    const l = localStorage.getItem('favoriteCategoryIds');
    if (l) try {
        S.favCatIds = new Set(JSON.parse(l))
    } catch (e) {
        console.error("Failed to parse favorite categories from localStorage", e), S.favCatIds = new Set
    }
    const a = localStorage.getItem('favoriteThemeIds');
    if (a) try {
        S.favThemeIds = new Set(JSON.parse(a))
    } catch (e) {
        console.error("Failed to parse favorite themes from localStorage", e), S.favThemeIds = new Set
    }
}

function saveState() {
    localStorage.setItem('legoCollection', JSON.stringify(S.coll));
    localStorage.setItem('legoSetCollection', JSON.stringify(S.setColl));
    localStorage.setItem('legoMinifigCollection', JSON.stringify(S.minifigColl));
    localStorage.setItem('favoriteCategoryIds', JSON.stringify(Array.from(S.favCatIds)));
    localStorage.setItem('favoriteThemeIds', JSON.stringify(Array.from(S.favThemeIds)));
    
    // Note: We no longer save cached details to localStorage
    // All data will be loaded fresh from CSV files on each startup
    console.log('User collections and favorites saved to localStorage');
}
const sidebarEl = document.getElementById('sidebar-container'),
    backdropEl = document.getElementById('sidebar-backdrop'),
    headerEl = document.getElementById('header-container'),
    mainEl = document.getElementById('main-content'),
    partModalEl = document.getElementById('modal-container'),
    setModalEl = document.getElementById('set-modal-container'),
    minifigModalEl = document.getElementById('minifig-modal-container'),
    filterModalEl = document.getElementById('filter-modal-container'),
    settingsModalEl = document.getElementById('settings-modal-container'),
    toTopBtn = document.getElementById('scroll-to-top-btn'),
    viewerEl = document.getElementById('image-viewer-container'),
    viewerImg = document.getElementById('fullscreen-image'),
    viewerCloseBtn = document.getElementById('image-viewer-close');

async function apiFetchPaginated(e) {
    let t = [];
    let o = 1;
    for (;;) {
        const l = e.includes("?") ? "&" : "?",
            a = `${REBRICKABLE_API_URL}${e}${l}page=${o}&page_size=800`;
        
        console.log(`API call: ${a}`);
        
        const i = await fetch(a, {
            headers: {
                Authorization: `key ${getApiKey()}`
            }
        });
        if (!i.ok) {
            const e = await i.json().catch(() => ({
                detail: "Не удалось получить детали ошибки."
            }));
            throw new Error(`Ошибка API Rebrickable: ${i.status} - ${e.detail}`)
        }
        const n = await i.json();
        console.log(`API response page ${o}:`, {
            status: i.status,
            hasResults: !!n.results,
            resultsCount: n.results?.length || 0,
            hasNext: !!n.next,
            sampleResult: n.results?.[0] ? {
                part_num: n.results[0].part_num,
                name: n.results[0].name,
                has_part_img_url: !!n.results[0].part_img_url,
                part_img_url: n.results[0].part_img_url
            } : null
        });
        
        if (n.results?.length > 0) {
            t = t.concat(n.results)
        }
        if (!n.next) break;
        o++
    }
    return t
}

function procPart(e) {
    if (!e || !e.part_num) return console.warn("Пропуск некорректных данных о детали из API:", e), null;
    

    
    const t = {
        id: e.part_num,
        name: e.name,
        rebrickable_img_url: e.part_img_url,
        categoryId: e.part_cat_id,
        num_sets: e.num_sets,
        part_num: e.part_num,
        part_cat_id: e.part_cat_id,
        part_img_url: e.part_img_url
    };
    PART_MAP[t.id] = { ...PART_MAP[t.id],
        ...t
    };
            // Force save state after part is processed to persist part data immediately
        saveState();
    return t
}

function getGroupId(e) {
    if (!e || "string" != typeof e) return e || "unknown_group";
    const t = e.match(/^([0-9]+)/);
    return t ? t[1] : e.split("p")[0]
}

function groupParts(e) {
    const t = {};
    return (e || []).forEach(e => {
        if (!e || (!e.part_num && !e.id)) return void console.warn("Пропуск детали без номера:", e);
        const partNum = e.part_num || e.id;
        const o = getGroupId(partNum);
        t[o] || (t[o] = []), t[o].push(e)
    }), Object.keys(t).forEach(e => {
        t[e].sort(partCmp)
    }), t
}

function buildCategoryTree(e) {
    const t = {
            'Bricks': ["brick"],
            'Plates': ["plate"],
            'Technic': ["technic"],
            'Slopes & Wedges': ["slope", "wedge"],
            'Tiles': ["tile"],
            'Panels, Doors & Windows': ["panel", "door", "window"],
            'Wheels & Tyres': ["wheel", "tyre"],
            'Minifig': ["minifig", "minidoll", "headwear"],
            'Bars, Hinges & Connectors': ["bar", "hinge", "connector", "link", "axle", "pin"],
            'Arches & Curves': ["arch", "curved", "round", "cone", "cylinder"]
        },
        o = {},
        l = [];
    (e || []).forEach(e => {
        const a = e.name.toLowerCase();
        let i = !1;
        for (const n in t)
            if (t[n].some(e => a.includes(e))) {
                o[n] || (o[n] = {
                    name: n,
                    children: []
                }), o[n].children.push(e), i = !0;
                break
            }
        i || l.push(e)
    });
    const a = Object.values(o).sort((e, t) => e.name.localeCompare(t.name, 'en'));
    return l.length > 0 && a.push({
        name: "Other",
        children: l.sort((e, t) => e.name.localeCompare(t.name, 'en'))
    }), a
}
async function fetchCategories() {
    try {
        const e = await apiFetchPaginated("/part_categories/");
        flatCategories = e.sort((e, t) => e.name.localeCompare(t.name, 'en')), S.catTree = buildCategoryTree(flatCategories)
        // Force save state after categories are fetched to persist all category data
        forceSaveState();
    } catch (e) {
        console.error("Ошибка загрузки категорий:", e), S.err = `Не удалось загрузить категории: ${e.message}`, S.catTree = []
    }
}
async function fetchThemes() {
    try {
        const e = await apiFetchPaginated("/themes/"),
            t = [],
            o = {};
        (e || []).forEach(e => {
            if (e && e.id) {
                o[e.id] = { ...e,
                    children: []
                };
                THEME_MAP[e.id] = o[e.id]
            }
        });
        (e || []).forEach(e => {
            if (e && e.id && o[e.id]) {
                if (e.parent_id && o[e.parent_id]) {
                    (Array.isArray(o[e.parent_id].children) || (o[e.parent_id].children = []));
                    o[e.parent_id].children.push(o[e.id]);
                } else {
                    t.push(o[e.id]);
                }
            }
        });
        const l = (e) => {
            if (Array.isArray(e.children) && e.children.length > 0) {
                e.children.sort((e, t) => e.name.localeCompare(t.name, 'en'));
                e.children.forEach(l);
            }
        };
        t.sort((e, t) => e.name.localeCompare(t.name, 'en')), t.forEach(l), S.themeTree = t
        // Force save state after themes are fetched to persist all theme data
        forceSaveState();
    } catch (e) {
        console.error("Ошибка загрузки тем:", e), S.err = (S.err ? S.err + "\n" : "") + `Не удалось загрузить темы: ${e.message}`, S.themeTree = []
    }
}
async function fetchAllColors() {
    try {
        const e = await apiFetchPaginated("/colors/");
        const colorsCount = (e || []).length;
        (e || []).forEach(e => {
            const t = String(e.id);
            COLOR_MAP[t] = {
                id: t,
                name: e.name,
                hex: `#${e.rgb}`,
                isTransparent: e.is_trans,
                rgb: e.rgb,
                is_trans: e.is_trans
            }
        })
        
        // Update API loading statistics
        if (colorsCount > 0) {
            updateApiLoadingStats('colors', colorsCount);
        }
        
        // Force save state after colors are fetched to persist all color data
        forceSaveState();
    } catch (e) {
        console.error("Ошибка загрузки цветов:", e), S.err = (S.err ? S.err + "\n" : "") + "Не удалось загрузить палитру цветов."
    }
}
async function loadPartsForCategory(e) {
    if (S.selCatId = e, S.loading = !0, S.err = null, S.searchGroups = null, S.q = '', S.catGroups = null, S.toDisplay = S.increment, S.gridStale = !0, updateUI(), S.filters.colorIds?.length > 1) return S.catGroups = {}, S.loading = !1, void updateUI();
    try {
        let t = `/parts/?part_cat_id=${e}`;
        S.filters.colorIds?.length === 1 && (t += `&color_id=${S.filters.colorIds[0]}`);
        const o = (await apiFetchPaginated(t)).map(procPart).filter(Boolean);
        let l = o;
        S.filters.inCollectionOnly && (l = o.filter(e => S.coll[e.id] && Object.keys(S.coll[e.id]).length > 0)), S.catGroups = groupParts(l)
    } catch (t) {
        console.error("Rebrickable parts fetch failed:", t), S.err = t.message
    } finally {
        S.loading = !1, updateUI()
    }
}

function getRelevanceScore(e, t) {
    const o = t.toLowerCase(),
        l = e.name ? e.name.toLowerCase() : '',
        a = e.part_num ? e.part_num.toLowerCase() : e.id ? e.id.toLowerCase() : '';
    return a === o ? 100 : l === o ? 90 : a.startsWith(o) ? 80 : l.startsWith(o) ? 70 : a.includes(o) ? 60 : l.includes(o) ? 50 : 0
}

function partCmp(e, t) {
    if (!t || (!t.part_num && !t.id) || !t.name) return -1;
    if (!e || (!e.part_num && !e.id) || !e.name) return 1;
    const o = e.name.toLowerCase().includes("print") || e.name.toLowerCase().includes("sticker") || e.name.toLowerCase().includes("pattern"),
        l = t.name.toLowerCase().includes("print") || t.name.toLowerCase().includes("sticker") || t.name.toLowerCase().includes("pattern");
    if (o && !l) return 1;
    if (!o && l) return -1;
    const a = (e.part_num || e.id).match(/[a-zA-Z]/),
        i = (t.part_num || t.id).match(/[a-zA-Z]/);
    if (a && !i) return 1;
    if (!a && i) return -1;
    const n = (t.num_sets || 0) - (e.num_sets || 0);
    if (0 !== n) return n;
    const r = e.name.length - t.name.length;
    return 0 !== r ? r : (e.part_num || e.id).localeCompare(t.part_num || t.id, 'en')
}
async function searchRebrickableParts(e) {
    if (!e || e.trim().length === 0) return S.searchGroups = null, S.loading = !1, S.selCatId = null, S.gridStale = !0, void updateUI();
    if (S.loading = !0, S.err = null, S.selCatId = null, S.catGroups = null, S.toDisplay = S.increment, S.gridStale = !0, updateUI(), S.filters.colorIds?.length > 1) return S.searchGroups = {}, S.loading = !1, void updateUI();
    try {


        
        // Search in CSV data instead of API
        let o = searchInCSVData(e, 'parts');
        
        // Apply color filter if specified
        if (S.filters.colorIds?.length === 1) {
            o = o.filter(part => {
                // Check if part has this color in inventory data
                if (window.INVENTORY_DATA && window.INVENTORY_DATA.parts) {
                    return Object.values(window.INVENTORY_DATA.parts).some(inventory => 
                        inventory.some(item => item.part_num === part.id && item.color_id === S.filters.colorIds[0])
                    );
                }
                return true; // If no inventory data, show all parts
            });
        }
        
        // Apply collection filter if specified
        S.filters.inCollectionOnly && (o = o.filter(e => S.coll[e.id] && Object.keys(S.coll[e.id]).length > 0));
        
        const l = groupParts(o);
        console.log('Grouped parts:', Object.keys(l).length, 'groups');
        
        const a = Object.entries(l).map(([t, o]) => ({
            groupId: t,
            partList: o,
            bestScore: Math.max(...o.map(t => getRelevanceScore(t, e)))
        }));
        a.sort((e, t) => {
            if (t.bestScore !== e.bestScore) return t.bestScore - e.bestScore;
            return partCmp(e.partList[0], t.partList[0])
        });
        const i = {};
        a.forEach(e => {
            e.bestScore > 0 && (i[e.groupId] = e.partList)
        }), S.searchGroups = i;
        
        console.log('Final search groups:', Object.keys(i).length, 'groups');

    } catch (t) {
        console.error("CSV search failed:", t), S.err = t.message, S.searchGroups = {}
    } finally {
        S.loading = !1, updateUI()
    }
}
async function fetchSets() {
    S.loading = !0, S.err = null, S.setRes = null, S.searchSetRes = null, S.toDisplay = S.increment, S.gridStale = !0, updateUI();
    try {
        let results = [];
        
        if (S.q) {
            // Search in CSV data
            results = searchInCSVData(S.q, 'sets');
        } else if (S.selThemeId) {
            // Filter by theme from CSV data
            results = Object.values(SET_MAP).filter(set => 
                set.theme_id === S.selThemeId
            );
        } else {
            // Get all sets from CSV
            results = Object.values(SET_MAP);
        }
        
        // Apply filters
        if (S.setFilters.minYear) {
            results = results.filter(set => set.year && set.year >= parseInt(S.setFilters.minYear));
        }
        if (S.setFilters.maxYear) {
            results = results.filter(set => set.year && set.year <= parseInt(S.setFilters.maxYear));
        }
        if (S.setFilters.minParts) {
            results = results.filter(set => set.num_parts && set.num_parts >= parseInt(S.setFilters.minParts));
        }
        if (S.setFilters.maxParts) {
            results = results.filter(set => set.num_parts && set.num_parts <= parseInt(S.setFilters.maxParts));
        }
        
        // Apply sorting
        if (S.sortBy === "alpha_asc") {
            results.sort((a, b) => (a.name || '').localeCompare(b.name || '', 'en'));
        } else if (S.sortBy === "alpha_desc") {
            results.sort((a, b) => (b.name || '').localeCompare(a.name || '', 'en'));
        } else if (S.sortBy === "year_asc") {
            results.sort((a, b) => (a.year || 0) - (b.year || 0));
        } else if (S.sortBy === "year_desc") {
            results.sort((a, b) => (b.year || 0) - (a.year || 0));
        } else if (S.sortBy === "parts_asc") {
            results.sort((a, b) => (a.num_parts || 0) - (b.num_parts || 0));
        } else if (S.sortBy === "parts_desc") {
            results.sort((a, b) => (b.num_parts || 0) - (a.num_parts || 0));
        }
        
        if (S.q) {
            S.searchSetRes = results;
        } else {
            S.setRes = results;
        }
        

    } catch (e) {
        console.error("Ошибка загрузки наборов из CSV:", e), S.err = e.message
    } finally {
        S.loading = !1, updateUI()
    }
}
async function fetchMinifigs() {
    S.loading = !0, S.err = null, S.toDisplay = S.increment, S.gridStale = !0, updateUI();
    try {
        let results = [];
        
        if (S.q) {
            // Search in CSV data
            results = searchInCSVData(S.q, 'minifigs');
            S.searchMinifigRes = results;
            S.minifigRes = null;
        } else {
            // Get all minifigs from CSV
            results = Object.values(MINIFIG_MAP);
            S.minifigRes = results;
            S.searchMinifigRes = null;
        }
        
        // Apply sorting
        if (S.sortBy === "name_asc") {
            results.sort((a, b) => (a.name || '').localeCompare(b.name || '', 'en'));
        } else if (S.sortBy === "name_desc") {
            results.sort((a, b) => (b.name || '').localeCompare(a.name || '', 'en'));
        } else if (S.sortBy === "num_parts_desc") {
            results.sort((a, b) => (b.num_parts || 0) - (a.num_parts || 0));
        } else if (S.sortBy === "num_parts_asc") {
            results.sort((a, b) => (a.num_parts || 0) - (a.num_parts || 0));
        }
        

    } catch (e) {
        console.error("Ошибка загрузки минифигурок из CSV:", e), S.err = e.message
    } finally {
        S.loading = !1, updateUI()
    }
}
async function fetchPartColors(e) {
    S.partModal.loadingColors = !0, updateModalPartially({
        colors: !0
    });
    try {
        const t = (await apiFetchPaginated(`/parts/${e}/colors/`)).map(e => String(e.color_id));
        if (PART_MAP[e]) {
            PART_MAP[e].availableColorIds = t;
            if (t.length > 0 && (!S.partModal.selColorId || !t.includes(S.partModal.selColorId))) {
                S.partModal.selColorId = sortColorIds(t, e)[0];
            }
        }
    } catch (t) {
        console.error(`Failed to fetch colors for ${e}:`, t), PART_MAP[e] || (PART_MAP[e] = {}), PART_MAP[e].availableColorIds = PART_MAP[e].availableColorIds || []
    } finally {
        S.partModal.loadingColors = !1, updateModalPartially({
            colors: !0,
            controls: !0
        }), S.partModal.selColorId && fetchPartColorSpecifics(e, S.partModal.selColorId)
    }
}
async function fetchPartColorSpecifics(e, t) {
    S.partModal.loadingImg = !0, updateModalPartially({
        image: !0
    });
    
    // Check cache first
    const cacheKey = `${e}-${t}`;
    if (COLOR_IMAGE_CACHE.has(cacheKey)) {
        S.partModal.imgUrl = COLOR_IMAGE_CACHE.get(cacheKey);
        S.partModal.loadingImg = !1;
        updateModalPartially({ image: !0 });
        return;
    }
    
    try {
        // Rate limiting
        const now = Date.now();
        const timeSinceLastRequest = now - lastApiRequestTime;
        if (timeSinceLastRequest < API_REQUEST_DELAY) {
            await new Promise(resolve => setTimeout(resolve, API_REQUEST_DELAY - timeSinceLastRequest));
        }
        
        lastApiRequestTime = Date.now();
        const o = `${REBRICKABLE_API_URL}/parts/${e}/colors/${t}/`,
            l = await fetch(o, {
                headers: {
                    Authorization: `key ${getApiKey()}`
                }
            });
            
        if (l.status === 429) {
            // Rate limited - wait and show fallback
            console.warn('Rate limited by API, using fallback image');
            S.partModal.imgUrl = PART_MAP[e]?.rebrickable_img_url || null;
            return;
        }
        
        if (!l.ok) throw new Error("Image not found for this color.");
        const a = await l.json();
        
        if (a.part_img_url) {
            // Cache the result
            COLOR_IMAGE_CACHE.set(cacheKey, a.part_img_url);
            S.partModal.imgUrl = a.part_img_url;
        } else {
            S.partModal.imgUrl = PART_MAP[e]?.rebrickable_img_url || null;
        }
    } catch (o) {
        console.warn("Could not fetch color-specific image:", o);
        S.partModal.imgUrl = PART_MAP[e]?.rebrickable_img_url || null;
    } finally {
        S.partModal.loadingImg = !1, updateModalPartially({
            image: !0
        })
    }
}
async function fetchColorDetailsForPart(e) {
    if (PART_MAP[e]?.colorImages) return;
    
    // Rate limiting
    const now = Date.now();
    const timeSinceLastRequest = now - lastApiRequestTime;
    if (timeSinceLastRequest < API_REQUEST_DELAY) {
        await new Promise(resolve => setTimeout(resolve, API_REQUEST_DELAY - timeSinceLastRequest));
    }
    
    try {
        lastApiRequestTime = Date.now();
        const t = await apiFetchPaginated(`/parts/${e}/colors/`);
        if (!PART_MAP[e]) {
            PART_MAP[e] = {
                id: e
            };
        }
        const o = {};
        if (Array.isArray(t)) {
            t.forEach(colorData => {
                if (colorData && colorData.part_img_url && colorData.color_id) {
                    o[String(colorData.color_id)] = colorData.part_img_url;
                    // Cache individual color image URLs
                    const cacheKey = `${e}-${colorData.color_id}`;
                    COLOR_IMAGE_CACHE.set(cacheKey, colorData.part_img_url);
                }
            });
        }
        PART_MAP[e].colorImages = o;
        
        // Update API loading statistics for images
        const imageCount = Object.keys(o).length;
        if (imageCount > 0) {
            updateApiLoadingStats('images', imageCount);
        }
        
        // Force save state after color details are fetched to persist color data immediately
        forceSaveState();
    } catch (t) {
        console.warn(`Could not fetch color details for part ${e}:`, t);
        // Mark this part as failed to avoid repeated attempts
        if (!PART_MAP[e]) {
            PART_MAP[e] = { id: e };
        }
        PART_MAP[e].colorImages = {}; // Empty object to prevent retry
    }
}

// Function to ensure basic part images are loaded for collection items
async function ensureBasicPartImagesForCollection() {
    const partsNeedingImages = Object.keys(S.coll).filter(partId => {
        const part = PART_MAP[partId];
        // Only process parts that have NO image URL at all
        // This should be very rare since inventory_parts.csv should provide images
        return part && !part.part_img_url;
    });
    
    if (partsNeedingImages.length === 0) {
        return;
    }
    
    // Process all parts immediately without API calls
    partsNeedingImages.forEach(partId => {
        const part = PART_MAP[partId];
        if (part && !part.part_img_url) {
            // Generate fallback image URL only if no image exists
            part.part_img_url = `https://cdn.rebrickable.com/media/parts/${partId}.jpg`;
            part.rebrickable_img_url = part.part_img_url;

        }
    });
    
    // Save state to persist the image URLs
    saveState();
}

// Simplified function to fetch color-specific images
async function fetchColorDetailsForCollectionParts() {
    // Skip this function if user prefers faster loading over color-specific images
    if (localStorage.getItem('disableColorSpecificImages') === 'true') {
        return;
    }
    
    const partsNeedingColorImages = Object.keys(S.coll).filter(partId => {
        const part = PART_MAP[partId];
        return part && !part.colorImages && part.part_img_url && part.part_img_url.startsWith('http');
    });
    
    if (partsNeedingColorImages.length === 0) return;
    

    
    // Process all parts in small batches to avoid rate limiting
    for (let i = 0; i < partsNeedingColorImages.length; i += 3) {
        const batch = partsNeedingColorImages.slice(i, i + 3);
        await Promise.all(batch.map(partId => fetchColorDetailsForPart(partId)));
        
        // Add delay between batches to avoid rate limiting
        if (i + 3 < partsNeedingColorImages.length) {
            await new Promise(resolve => setTimeout(resolve, 2000));
        }
    }
    
    // Force save state after all color details are fetched
    forceSaveState();
}

// Helper function to get currently visible part IDs
function getCurrentlyVisiblePartIds() {
    const visiblePartCards = document.querySelectorAll('.part-card[data-part-id]');
    return Array.from(visiblePartCards).map(card => card.dataset.partId);
}

// Function to load images for currently visible parts (simplified)
async function loadImagesForVisibleParts() {
    // This function is now simplified to avoid constant UI updates
    // It will be called only when explicitly needed
    return;
}



// Function to force refresh part images in collection view
async function forceRefreshPartImages() {
    if (S.view !== 'collection' || S.subView !== 'parts') return;
    
    const refreshButton = document.getElementById('refresh-images-button');
    const refreshIcon = document.getElementById('refresh-images-icon');
    
    if (!refreshButton || !refreshIcon) return;
    
    // Disable button and show loading state
    refreshButton.disabled = true;
    refreshIcon.innerHTML = '<div class="loader !w-5 !h-5 !border-2"></div>';
    
    try {
        // First ensure all parts have basic images
        await ensureBasicPartImagesForCollection();
        
        // Then fetch color-specific images for all parts
        await fetchColorDetailsForCollectionParts();
        
        // Update UI once at the end
        S.gridStale = true;
        updateUI();
    } catch (error) {
        console.error('Error refreshing part images:', error);
    } finally {
        // Re-enable button and restore icon
        refreshButton.disabled = false;
        refreshIcon.innerHTML = I_Refresh("w-5 h-5");
    }
}

async function fetchMissingCollectionPartDetails() {
    const e = Object.keys(S.coll).filter(e => !PART_MAP[e] || !PART_MAP[e].name);
    if (e.length === 0) return;
    
    for (let t = 0; t < e.length; t += 100) {
        const o = e.slice(t, t + 100);
        try {
            const parts = await apiFetchPaginated(`/parts/?part_nums=${o.join(",")}`);
            
            if (parts && Array.isArray(parts)) {
                const processedParts = parts.map(procPart).filter(Boolean);
                // Update API loading statistics
                if (processedParts.length > 0) {
                    updateApiLoadingStats('parts', processedParts.length);
                }
            }
        } catch (l) {
            console.error(`Could not fetch details for batch starting with part ${o[0]}:`, l);
            S.err = (S.err ? S.err + "\n" : "") + "Не удалось загрузить данные для некоторых деталей коллекции.";
        }
    }
    // Force save state after parts are fetched to persist all part data
    forceSaveState();
}
async function fetchMissingCollectionSetDetails() {
    const e = Object.keys(S.setColl).filter(e => !SET_MAP[e] || !SET_MAP[e].name);
    if (e.length === 0) return;
    for (let t = 0; t < e.length; t += 50) {
        const o = e.slice(t, t + 50);
        try {
            const sets = await apiFetchPaginated(`/sets/?set_nums=${o.join(",")}`);
            if (sets && Array.isArray(sets)) {
                const validSets = sets.filter(set => set && set.set_num);
                validSets.forEach(set => {
                    if (set && set.set_num) {
                        SET_MAP[set.set_num] = { ...SET_MAP[set.set_num], ...set };
                    }
                });
                
                // Update API loading statistics
                if (validSets.length > 0) {
                    updateApiLoadingStats('sets', validSets.length);
                }
            }
            // Persist updated set details cache for offline render
            saveState();
        } catch (l) {
            console.error(`Could not fetch details for batch of sets starting with ${o[0]}:`, l);
            S.err = (S.err ? S.err + "\n" : "") + "Не удалось загрузить данные для некоторых наборов коллекции.";
        }
    }
}
async function fetchMinifigDetails(e) {
    if (MINIFIG_MAP[e]?.name) return;
    try {
        const t = await fetch(`${REBRICKABLE_API_URL}/minifigs/${e}/`, {
            headers: {
                Authorization: `key ${getApiKey()}`
            }
        });
        if (!t.ok) throw new Error(`Minifig ${e} not found.`);
        const o = await t.json();
        MINIFIG_MAP[e] = o
        
        // Update API loading statistics
        updateApiLoadingStats('minifigs', 1);
        
        // Force save state after minifig details are fetched to persist minifig data immediately
        saveState();
        
        // Update UI if this minifig is currently being displayed
        if (S.gridStale) {
            updateUI();
        }
        
        // Also update UI if we're currently viewing minifigs
        if (S.subView === 'minifigs') {
            S.gridStale = true;
            updateUI();
        }
    } catch (t) {
        console.error(`Could not fetch details for minifig ${e}:`, t)
        // Set a placeholder name to avoid #undefined
        if (!MINIFIG_MAP[e]) {
            MINIFIG_MAP[e] = { set_num: e, name: 'Неизвестная минифигурка' };
        }
    }
}

async function fetchSetInventory(e, t = 1) {
    if (S.setModal.loading = !0, t === 1 && (S.setModal.inv = []), updateSetModalView(), !S.selSetNum) return;
    try {
        const o = `/sets/${e}/parts/?page=${t}&page_size=50`,
            l = await fetch(`${REBRICKABLE_API_URL}${o}`, {
                headers: {
                    Authorization: `key ${getApiKey()}`
                }
            });
        if (!l.ok) throw new Error("Could not fetch set inventory");
        const a = await l.json();
        const i = (a.results || []).map((e) => {
                procPart(e.part);
                const t = String(e.color.id);
                COLOR_MAP[t] || (COLOR_MAP[t] = {
                    id: t,
                    name: e.color.name,
                    hex: `#${e.color.rgb}`,
                    isTransparent: e.color.is_trans,
                    rgb: e.color.rgb,
                    is_trans: e.color.is_trans
                });
                return {
                    part: e.part,
                    color: COLOR_MAP[t],
                    quantity: e.quantity,
                    is_spare: e.is_spare,
                    element_id: e.element_id
                }
            }).filter((e) => !e.is_spare);
        S.setModal.inv = [...S.setModal.inv, ...i], S.setModal.invPage = t, S.setModal.hasNextInv = !!a.next
        // Force save state after set inventory is fetched to persist inventory data immediately
        forceSaveState();
    } catch (o) {
        console.error(`Failed to fetch inventory for ${e}:`, o)
    } finally {
        S.setModal.loading = !1, S.selSetNum && updateSetModalView()
    }
}
async function fetchAllSetInventory(e) {
    let t = [];
    let o = 1;
    for (;;) {
        const l = `/sets/${e}/parts/?page=${o}&page_size=500`,
            a = await fetch(`${REBRICKABLE_API_URL}${l}`, {
                headers: {
                    Authorization: `key ${getApiKey()}`
                }
            });
        if (!a.ok) {
            const e = await a.json().catch(() => ({
                detail: "Не удалось получить детали ошибки."
            }));
            throw new Error(`Ошибка API Rebrickable: ${a.status} - ${e.detail}`)
        }
        const i = await a.json();
        const n = (i.results || []).map((e) => {
                procPart(e.part);
                const t = String(e.color.id);
                return COLOR_MAP[t] || (COLOR_MAP[t] = {
                    id: t,
                    name: e.color.name,
                    hex: `#${e.color.rgb}`,
                    isTransparent: e.color.is_trans,
                    rgb: e.color.rgb,
                    is_trans: e.color.is_trans
                }), {
                    part: e.part,
                    color: COLOR_MAP[t],
                    quantity: e.quantity,
                    is_spare: e.is_spare,
                    element_id: e.element_id,
                }
            }).filter((e) => !e.is_spare);
        if (n.length > 0) {
            t = t.concat(n);
        }
        if (!i.next) break;
        o++, await new Promise(e => setTimeout(e, 1e3))
    }
    // Force save state after all set inventory is fetched to persist inventory data immediately
    forceSaveState();
    return t
}
async function fetchSetMinifigs(e) {
    S.setModal.loadingMinifigs = !0, updateSetModalView();
    try {
        const t = await apiFetchPaginated(`/sets/${e}/minifigs/`);
        for (let e = 0; e < t.length; e += 5) {
            const o = t.slice(e, e + 5),
                l = o.map(e => fetchMinifigDetails(e.set_num));
            await Promise.all(l), e + 5 < t.length && await new Promise(e => setTimeout(e, 1e3))
        }
        S.setModal.minifigs = (t || []).map(e => ({ ...MINIFIG_MAP[e.set_num],
            quantity: e.quantity,
            isExpanded: !1,
            isLoadingParts: !1,
            parts: null,
            loadingError: !1
        }))
        // Force save state after set minifigs are fetched to persist minifig data immediately
        forceSaveState();
    } catch (t) {
        console.error(`Failed to fetch minifigs for set ${e}:`, t), S.setModal.minifigs = []
    } finally {
        S.setModal.loadingMinifigs = !1, S.selSetNum && updateSetModalView()
    }
}
async function fetchMinifigParts(e) {
    try {
        const t = await apiFetchPaginated(`/minifigs/${e}/parts/`);
        const result = (t || []).map(e => {
            procPart(e.part);
            const t = String(e.color.id);
            return COLOR_MAP[t] || (COLOR_MAP[t] = {
                id: t,
                name: e.color.name,
                hex: `#${e.color.rgb}`,
                isTransparent: e.color.is_trans,
                rgb: e.color.rgb,
                is_trans: e.color.is_trans
            }), { ...e,
                color: COLOR_MAP[t]
            }
        });
        
        // Force save state after minifig parts are fetched to persist parts data immediately
        forceSaveState();
        
        // Fetch missing part images for minifig parts
        await fetchMissingMinifigPartImages(result);
        
        return result;
    } catch (t) {
        throw console.error(`Failed to fetch parts for minifig ${e}:`, t), t
    }
}

// Function to fetch missing part images for minifig parts
async function fetchMissingMinifigPartImages(minifigParts) {
    const partsWithoutImages = minifigParts.filter(p => !p.part.part_img_url);
    
    if (partsWithoutImages.length === 0) {
        return;
    }
    

    
    for (const partInfo of partsWithoutImages.slice(0, 5)) { // Limit to 5 to avoid rate limiting
        if (!partInfo || !partInfo.part || !partInfo.part.part_num) {
            console.warn('Invalid part info, skipping...');
            continue;
        }
        
        try {
            // Rate limiting
            const now = Date.now();
            const timeSinceLastRequest = now - lastApiRequestTime;
            if (timeSinceLastRequest < API_REQUEST_DELAY) {
                await new Promise(resolve => setTimeout(resolve, API_REQUEST_DELAY - timeSinceLastRequest));
            }
            
            lastApiRequestTime = Date.now();
            const response = await fetch(`${REBRICKABLE_API_URL}/parts/${partInfo.part.part_num}/?key=${getApiKey()}`);
            
            if (response.status === 429) {
                console.warn('Rate limited by API, stopping part image fetching');
                break;
            }
            
            if (response.ok) {
                const data = await response.json();
                if (data.results && data.results[0] && data.results[0].part_img_url) {
                    partInfo.part.part_img_url = data.results[0].part_img_url;

                }
            }
            
            // Add delay to avoid rate limiting
            await new Promise(resolve => setTimeout(resolve, 100));
        } catch (error) {
            console.warn(`Failed to fetch image URL for part ${partInfo.part.part_num}:`, error);
        }
    }
}
async function handleFeelingLucky() {
    S.loading = !0, S.err = null, S.gridStale = !0, updateUI();
    try {
        let e;
        if ("parts" === S.subView) {
            if (flatCategories.length === 0) throw new Error("Категории еще не загружены.");
            const t = flatCategories[Math.floor(Math.random() * flatCategories.length)],
                o = await apiFetchPaginated(`/parts/?part_cat_id=${t.id}&page_size=100`);
            if (o.length === 0) return handleFeelingLucky();
            e = o[Math.floor(Math.random() * o.length)];
            const l = procPart(e);
            if (!l) throw new Error("Не удалось выбрать случайную деталь.");
            const a = getGroupId(l.part_num);
            openModalForPart(l.id, a, [l])
        } else if ("sets" === S.subView) {
            const t = Object.keys(THEME_MAP);
            if (t.length === 0) throw new Error("Темы еще не загружены.");
            let o = 0;
            for (; o < 10;) {
                const l = t[Math.floor(Math.random() * t.length)],
                    a = await apiFetchPaginated(`/sets/?theme_id=${l}&page_size=100`);
                if (a.length > 0) {
                    e = a[Math.floor(Math.random() * a.length)];
                    SET_MAP[e.set_num] = e;
                    openModalForSet(e.set_num);
                    S.loading = !1;
                    return void updateUI();
                }
                o++
            }
            throw new Error("Не удалось найти случайный набор.")
        } else {
            const t = await apiFetchPaginated("/minifigs/?page_size=200");
            if (t.length === 0) throw new Error("Не удалось загрузить минифигурки.");
            e = t[Math.floor(Math.random() * t.length)];
            MINIFIG_MAP[e.set_num] = e;
            openModalForMinifig(e.set_num)
        }
    } catch (e) {
        console.error("Feeling lucky failed:", e), S.err = `Не удалось совершить чудо: ${e.message}`
    } finally {
        S.loading = !1, updateUI()
    }
}

function getPartImageUrl(e) {
    const t = `data:image/svg+xml,${encodeURIComponent(I_Img("w-full h-full text-gray-500"))}`;
    if (!e || typeof e !== 'string' || e.trim() === '') return `src="${t}"`;
    
    // Accept various types of image URLs
    const trimmedUrl = e.trim();
    
    // Accept HTTP URLs, data URLs, and relative paths
    if (trimmedUrl.startsWith('http') || trimmedUrl.startsWith('data:') || trimmedUrl.startsWith('./') || trimmedUrl.startsWith('/')) {
        return `src="${trimmedUrl}" onerror="this.onerror=null; this.src='${t}';"`
    }
    
    // For other cases, try to use the URL as is, but log a warning
    console.warn('Potentially invalid image URL detected:', trimmedUrl);
    return `src="${trimmedUrl}" onerror="this.onerror=null; this.src='${t}';"`
}

// Simple function to handle image load errors (no API calls)
function handleImageLoadError(imgElement, originalUrl) {
    console.warn(`Image failed to load: ${originalUrl}`);
    // Just log the error, don't try to fetch from API
    // This prevents infinite loops and API overloading
}
        

        


function sortColorIds(e, t) {
    const o = ["0", "15", "4", "1", "14", "2", "71", "72", "88", "19", "5", "34"],
        l = Object.keys(S.coll[t] || {});
    return [...e].sort((e, t) => {
        const a = o.includes(e),
            i = o.includes(t);
        if (a && !i) return -1;
        if (!a && i) return 1;
        const n = l.includes(e),
            r = l.includes(t);
        if (n && !r) return -1;
        if (!n && r) return 1;
        const s = COLOR_MAP[e],
            c = COLOR_MAP[t];
        return s && c ? s.name.localeCompare(c.name, 'en') : 0
    })
}

function getPluralizedColorString(e) {
    const t = Math.abs(e),
        o = t % 10,
        l = t % 100;
    return l >= 11 && l <= 19 ? "цветов" : 1 === o ? "цвет" : [2, 3, 4].includes(o) ? "цвета" : "цветов"
}

function parseCsvLine(e) {
    const t = [];
    let o = "",
        l = !1;
    const a = '"';
    for (let i = 0; i < e.length; i++) {
        const n = e[i];
        n === a ? l && e[i + 1] === a ? (o += a, i++) : l = !l : "," === n && !l ? (t.push(o), o = "") : o += n
    }
    return t.push(o), t.map(e => e.trim())
}
const CATEGORY_ICONS = {
    'Bricks': I_Brick,
    'Plates': I_Plate,
    'Technic': I_Tech,
    'Slopes & Wedges': I_Slope,
    'Tiles': I_Tile,
    'Panels, Doors & Windows': I_Win,
    'Wheels & Tyres': I_Wheel,
    'Minifig': I_Minifig,
    'Bars, Hinges & Connectors': I_Bar,
    'Arches & Curves': I_Arch,
    'Other': I_Other
};

function filterThemeTreeForCollection(e, t) {
    return Array.isArray(e) ? e.map(e => {
        if (!e || !e.id) return null;
        const o = Array.isArray(e.children) && e.children.length > 0 ? filterThemeTreeForCollection(e.children, t) : [];
        return t.has(e.id) || o.length > 0 ? { ...e,
            children: o
        } : null
    }).filter(Boolean) : []
}

function renderSidebar() {
    const e = Object.values(S.coll).reduce((e, t) => e + Object.values(t).reduce((e, t) => e + t, 0), 0);
    const t = Object.keys(S.coll).reduce((e, t) => e + Object.keys(S.coll[t]).length, 0);
    const o = Object.values(S.setColl).reduce((e, t) => e + t.qty, 0);
    const l = Object.keys(S.setColl).length;
    const a = Object.values(S.minifigColl).reduce((e, t) => e + t.qty, 0);
    const i = Object.keys(S.minifigColl).length;
    const n = (e) => `flex items-center w-full p-3 text-base font-semibold rounded-lg transition-colors duration-150 ${S.view===e?"bg-blue-600 text-white":"text-gray-400 hover:bg-gray-700 hover:text-white"}`;
    const r = (e) => `relative flex-1 py-2 px-1 rounded-lg text-sm font-semibold transition-colors duration-200 flex flex-col items-center justify-center gap-1 ${S.subView===e?"bg-blue-600 text-white":"text-gray-300 hover:bg-gray-700 hover:text-white"}`;
    const s = (e, t, o) => {
        if (o === 0 || "collection" !== S.view) return "";
        const l = t;
        const i = l >= 1e3 ? "text-[10px] px-1" : "text-xs px-1.5";
        const a = `absolute top-1 right-1 ${i} py-0.5 rounded-full font-bold ${S.subView===e?"bg-blue-200 text-blue-800":"bg-gray-600 text-gray-200"}`;
        return `<span class="${a}">${l.toLocaleString("ru-RU")}</span>`
    };
    let c = "",
        d = "";
    if ("sets" === S.subView) {
        d = "Темы";
        let e = S.themeTree;
        let t = "";
        if ("collection" === S.view) {
            const o = null === S.selCollThemeId,
                l = o ? "bg-blue-600 text-white" : "text-gray-300 hover:bg-gray-700 hover:text-white";
            t = `
              <li>
                <button data-action="show-all-collection-items" class="w-full text-left flex items-center p-2 rounded-md transition-colors duration-150 ${l}">
                  <span class="truncate">Все наборы</span>
                </button>
              </li>
            `;
            const a = new Set();
            Object.keys(S.setColl).forEach(e => {
                const t = SET_MAP[e];
                if (t && t.theme_id) {
                    let e = t.theme_id;
                    for (; e;) {
                        a.add(e);
                        e = THEME_MAP[e]?.parent_id
                    }
                }
            });
            e = filterThemeTreeForCollection(S.themeTree, a)
        }
        const o = (e) => {
            if (!Array.isArray(e)) return [];
            e.forEach(e => {
                e && Array.isArray(e.children) && o(e.children)
            });
            return e.sort((e, t) => {
                const o = S.favThemeIds.has(e.id),
                    l = S.favThemeIds.has(t.id);
                return o && !l ? -1 : !o && l ? 1 : e.name.localeCompare(t.name, 'en')
            }), e
        };
        o(e);
        const l = (e, t = 0) => {
            if (!Array.isArray(e)) return "";
            return e.map(e => {
                if (!e) return "";
                const o = S.expThemes.has(e.id),
                    a = ("catalog" === S.view && S.selThemeId === e.id || "collection" === S.view && S.selCollThemeId === e.id) ? "bg-blue-600/80 text-white" : "text-gray-400 hover:bg-gray-700/50 hover:text-gray-200",
                    i = Array.isArray(e.children) && e.children.length > 0 ? `<ul class="space-y-1 ${o?"":"hidden"}">${l(e.children,t+1)}</ul>` : "",
                    n = S.favThemeIds.has(e.id),
                    r = n ? "text-red-400 opacity-100" : "text-gray-500 lg:opacity-0 lg:group-hover:opacity-100";
                return `
                    <li class="space-y-1">
                        <button data-theme-id="${e.id}" class="w-full text-left flex items-center justify-between p-2 rounded-md transition-colors duration-150 ${a} group" style="padding-left: ${.5+1.5*t}rem;">
                            <div class="flex items-center truncate flex-grow">
                                <span data-action="toggle-favorite-theme" data-theme-id="${e.id}" class="p-1 rounded-full hover:bg-gray-600 hover:text-red-400 transition-opacity z-10 mr-2 ${r}" aria-label="Добавить в избранное">
                                    ${I_Heart("w-4 h-4",n)}
                                </span>
                                <span class="truncate">${e.name}</span>
                            </div>
                            ${Array.isArray(e.children)&&e.children.length>0?I_Chev(`w-5 h-5 text-gray-400 transform transition-transform duration-200 flex-shrink-0 ${o?"rotate-180":""}`):""}
                        </button>
                        ${i}
                    </li>
                `
            }).join("")
        };
        S.sidebarLoading ? c = '<div class="flex items-center justify-center p-4"><div class="loader !w-6 !h-6"></div></div>' : c = t + l(e)
    } else if ("minifigs" === S.subView) d = "Минифигурки", c = '<li class="text-gray-400 text-sm p-2">Используйте поиск или просмотрите каталог.</li>';
    else {
        d = "Категории";
        let e = S.catTree;
        let t = "";
        if ("collection" === S.view) {
            const o = null === S.selCollCatId,
                l = o ? "bg-blue-600 text-white" : "text-gray-300 hover:bg-gray-700 hover:text-white";
            t = `
              <li>
                <button data-action="show-all-collection-items" class="w-full text-left flex items-center p-2 rounded-md transition-colors duration-150 ${l}">
                  <span class="truncate">Все детали</span>
                </button>
              </li>
            `;
            const a = new Set(Object.keys(S.coll).map(e => PART_MAP[e]?.categoryId).filter(e => void 0 !== e && null !== e));
            e = JSON.parse(JSON.stringify(S.catTree));
            e = e.map(e => (Array.isArray(e.children) && (e.children = e.children.filter(e => a.has(e.id))), e)).filter(e => Array.isArray(e.children) && e.children.length > 0)
        }
        S.sidebarLoading ? c = '<div class="flex items-center justify-center p-4"><div class="loader !w-6 !h-6"></div></div>' : "collection" === S.view && Object.keys(S.coll).length > 0 && 0 === e.length ? c = '<li class="text-gray-400 text-sm p-2">Нет деталей в категориях.</li>' : (e.forEach(e => {
            Array.isArray(e.children) && e.children.sort((e, t) => {
                const o = S.favCatIds.has(e.id),
                    l = S.favCatIds.has(t.id);
                return o && !l ? -1 : !o && l ? 1 : e.name.localeCompare(t.name, 'en')
            })
        }), c = t + e.map(e => {
            const t = S.expCats.has(e.name),
                o = e.children.map(e => {
                    const t = ("catalog" === S.view && S.selCatId === e.id || "collection" === S.view && S.selCollCatId === e.id) ? "bg-blue-600/80 text-white" : "text-gray-400 hover:bg-gray-700/50 hover:text-gray-200",
                        o = S.favCatIds.has(e.id),
                        l = o ? "text-red-400 opacity-100" : "text-gray-500 lg:opacity-0 lg:group-hover:opacity-100";
                    return `
                      <li>
                          <button data-category-id="${e.id}" class="w-full text-left flex items-center p-2 pl-11 rounded-md transition-colors duration-150 ${t} group">
                            <span data-action="toggle-favorite-category" data-category-id="${e.id}" class="p-1 rounded-full hover:bg-gray-600 hover:text-red-400 transition-opacity z-10 mr-2 -ml-2 ${l}" aria-label="Добавить в избранное">
                                ${I_Heart("w-4 h-4",o)}
                            </span>
                            <span class="truncate flex-grow">${e.name}</span>
                          </button>
                      </li>
                   `
                }).join("");
            const l = (CATEGORY_ICONS[e.name] || I_Other)("w-5 h-5 mr-3 text-gray-400 flex-shrink-0");
            return `
                  <li class="space-y-1">
                      <button data-parent-category="${e.name}" class="w-full text-left flex items-center justify-between p-2 rounded-md hover:bg-gray-700 transition-colors duration-150">
                          <div class="flex items-center truncate">
                            ${l}
                            <span class="font-semibold text-gray-200 truncate">${e.name}</span>
                          </div>
                          ${I_Chev(`w-5 h-5 text-gray-400 transform transition-transform duration-200 ${t?"rotate-180":""}`)}
                      </button>
                      <ul class="space-y-1 ${t?"":"hidden"}">
                          ${o}
                      </ul>
                  </li>
              `
        }).join(""))
    }
    sidebarEl.innerHTML = `
        <div class="flex items-center justify-between mb-4 flex-shrink-0">
          <h1 class="text-xl font-bold text-white">Меню</h1>
          <button id="sidebar-close" class="lg:hidden text-gray-300 hover:text-white p-1">
            ${I_X("w-6 h-6")}
          </button>
        </div>

        <div class="space-y-2 mb-4 flex-shrink-0">
            <button data-view="catalog" class="${n("catalog")}">${I_Cat("w-5 h-5 mr-3")}<span>Каталог</span></button>
            <button data-view="collection" class="${n("collection")}">${I_Coll("w-5 h-5 mr-3")}<span>Коллекция</span></button>
        </div>

        <div class="mb-4 p-1 bg-gray-900/50 rounded-xl grid grid-cols-3 gap-1">
            <button data-sub-view="parts" class="${r("parts")}">
                ${I_Brick("w-5 h-5")}
                <span class="mt-1">Детали</span>
                ${s("parts",e,t)}
            </button>
            <button data-sub-view="sets" class="${r("sets")}">
                ${I_Set("w-5 h-5")}
                <span class="mt-1">Наборы</span>
                ${s("sets",o,l)}
            </button>
            <button data-sub-view="minifigs" class="${r("minifigs")}">
                ${I_Minifig("w-5 h-5")}
                <span class="mt-1">Фигурки</span>
                ${s("minifigs",a,i)}
            </button>
        </div>
        
        <div id="sidebar-scroll-container" class="flex-grow overflow-y-auto no-scrollbar">
          <h2 class="text-lg font-semibold text-white mb-3">${d}</h2>
          <nav>
            <ul id="category-list" class="space-y-1">${c}</ul>
          </nav>
        </div>
        
        <div class="flex-shrink-0 mt-4 border-t border-gray-700 pt-4 space-y-4">
            ${"collection"===S.view?`
            <div>
                <h2 class="text-lg font-semibold text-white mb-3">Сводка коллекции</h2>
                ${0===e&&0===l&&0===i?'<p class="text-gray-400 text-sm">Ваша коллекция пуста.</p>':`
                  <div class="space-y-1">
                      <div class="flex justify-between items-center text-sm text-gray-400">
                          <span>${I_Brick("inline-block w-4 h-4 mr-1")} Детали</span>
                          <span class="font-semibold text-white">${t.toLocaleString("ru-RU")} уник. / ${e.toLocaleString("ru-RU")} всего</span>
                      </div>
                      <div class="flex justify-between items-center text-sm text-gray-400">
                          <span>${I_Set("inline-block w-4 h-4 mr-1")} Наборы</span>
                          <span class="font-semibold text-white">${l.toLocaleString("ru-RU")} уник. / ${o.toLocaleString("ru-RU")} всего</span>
                      </div>
                       <div class="flex justify-between items-center text-sm text-gray-400">
                          <span>${I_Minifig("inline-block w-4 h-4 mr-1")} Минифигурки</span>
                          <span class="font-semibold text-white">${i.toLocaleString("ru-RU")} уник. / ${a.toLocaleString("ru-RU")} всего</span>
                      </div>
                  </div>
                `}
            </div>
            `:""}
            <button id="settings-button" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-600 hover:bg-gray-500 text-white">
                ${I_Settings("w-5 h-5 mr-2")} Настройки
            </button>
        </div>
      `
}

function renderHeader() {
    const {
        subView: e
    } = S;
    let t = "Поиск по ID или названию...";
    "sets" === e && (t = "Поиск по наборам..."), "minifigs" === e && (t = "Поиск по минифигуркам...");
    
    headerEl.innerHTML = `
            <div class="flex justify-between items-center gap-4">
                <div class="flex items-center">
                    <button id="sidebar-toggle" class="lg:hidden text-gray-300 hover:text-white mr-4 -ml-1 p-1">
                        ${I_Menu("w-6 h-6")}
                    </button>
                    <h1 class="text-xl font-bold text-white hidden sm:block">LEGO® Catalog</h1>
                </div>
                <div class="flex items-center space-x-2 w-full max-w-sm">
                    <div class="relative flex-grow">
                        <input id="search-input" type="search" placeholder="${t}" value="${S.q}" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 pl-4 pr-10 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"/>
                        <button id="clear-search" class="absolute inset-y-0 right-0 flex items-center pr-3 text-gray-400 hover:text-white ${S.q?"":"hidden"}">${I_X("w-5 h-5")}</button>
                    </div>
                     <button id="search-button" class="p-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors flex-shrink-0" aria-label="Поиск">
                        ${I_Search("w-5 h-5")}
                    </button>
                    <button id="filter-button" class="p-2 bg-gray-600 text-white rounded-md hover:bg-gray-500 transition-colors flex-shrink-0" aria-label="Фильтры">
                        ${I_Filter("w-5 h-5")}
                    </button>

                </div>
            </div>
        `
}

function renderSetCard(e, t, o = 0) {
    if (!e) return "";
    const l = t ? "animate-in" : "",
        a = t ? `animation-delay: ${Math.min(40*o,1500)}ms;` : "",
        i = S.setColl[e.set_num] ? S.setColl[e.set_num].qty : 0;
    return `
            <div data-set-num="${e.set_num}" style="${a}" class="set-card ${l} relative bg-gray-800 rounded-lg overflow-hidden group transform transition-all duration-300 hover:bg-gray-700 cursor-pointer hover:scale-105">
                ${i>0?`<div class="absolute top-3 right-3 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md">${i}</div>`:""}
                <div class="w-full h-40 bg-gray-700 flex items-center justify-center p-2 rounded-t-lg">
                    <div class="w-full h-full bg-white rounded-md flex items-center justify-center overflow-hidden shadow-inner">
                        <img ${getPartImageUrl(e.set_img_url && e.set_img_url.startsWith('http') ? e.set_img_url : null)} alt="${e.name}" class="w-full h-full object-contain pointer-events-none" loading="lazy" />
                    </div>
                </div>
                <div class="p-4 space-y-1">
                    <h3 class="text-sm font-semibold text-white truncate pointer-events-none">${e.name}</h3>
                    <p class="text-xs text-gray-400 pointer-events-none">#${e.set_num} • ${e.year}</p>
                </div>
            </div>
        `
}

function renderMinifigCard(e, t, o = 0) {
    if (!e) return `
        <div class="minifig-card relative bg-gray-800 rounded-lg overflow-hidden group p-4 flex flex-col items-center justify-center animate-pulse" style="min-height: 180px;">
            <div class="w-16 h-16 bg-gray-700 rounded-full mb-4"></div>
            <div class="h-4 bg-gray-700 rounded w-24 mb-2"></div>
            <div class="h-3 bg-gray-700 rounded w-16 mb-1"></div>
            <div class="h-3 bg-gray-700 rounded w-12"></div>
            <span class="text-gray-400 text-xs mt-4">Загрузка...</span>
        </div>
    `;
    
    // Auto-fetch minifig details if name is missing
    if (!e.name && e.set_num) {
        fetchMinifigDetails(e.set_num).catch(console.error);
    }
    const l = t ? "animate-in" : "",
        a = t ? `animation-delay: ${Math.min(40*o,1500)}ms;` : "",
        i = S.minifigColl[e.set_num] ? S.minifigColl[e.set_num].qty : 0;
    return `
            <div data-fig-num="${e.set_num}" style="${a}" class="minifig-card ${l} relative bg-gray-800 rounded-lg overflow-hidden group transform transition-all duration-300 hover:bg-gray-700 cursor-pointer hover:scale-105">
                ${i>0?`<div class="absolute top-3 right-3 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md">${i}</div>`:""}
                <div class="w-full h-40 bg-gray-700 flex items-center justify-center p-2 rounded-t-lg">
                    <div class="w-full h-full bg-white rounded-md flex items-center justify-center overflow-hidden shadow-inner">
                        <img ${getPartImageUrl((e.minifig_img_url && e.minifig_img_url.startsWith('http')) || (e.set_img_url && e.set_img_url.startsWith('http')) ? (e.minifig_img_url || e.set_img_url) : null)} alt="${e.name}" class="w-full h-full object-contain pointer-events-none" loading="lazy" />
                    </div>
                </div>
                <div class="p-4 space-y-1">
                    <h3 class="text-sm font-semibold text-white truncate pointer-events-none">${e.name || 'Загрузка...'}</h3>
                    <p class="text-xs text-gray-400 pointer-events-none">#${e.set_num}</p>
                    ${!e.name ? '<p class="text-xs text-blue-400">Загружаем детали...</p>' : ''}
                </div>
            </div>
        `
}

function renderPartCard(e, t, o, l, a = 0) {
    if (!e) return "";
    const i = "collection" === S.view,
        n = getGroupId(e.id),
        r = l ? "animate-in" : "",
        s = l ? `animation-delay: ${Math.min(40*a,1500)}ms;` : "";
    let c = "";
    o > 0 && (c = `<div class="absolute top-3 ${i?"left-3":"right-3"} bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md">${o}</div>`);
            // FIXED: Now properly uses part_img_url from inventory_parts.csv as primary image source
    let d = e.part_img_url || e.rebrickable_img_url;
    
    // Only try to get color-specific images if the feature is enabled and available
    if (i && t && localStorage.getItem('disableColorSpecificImages') !== 'true') {
        const colorImage = PART_MAP[e.id]?.colorImages?.[t.id];
        if (colorImage && colorImage.startsWith('http')) {
            d = colorImage;
        }
    }
    
    // Ensure we have a valid image URL - but don't overwrite existing ones
    if (!d || typeof d !== 'string' || !d.startsWith('http')) {
        // Only use fallback if no image exists at all
        if (!e.part_img_url && !e.rebrickable_img_url) {
            d = `https://cdn.rebrickable.com/media/parts/${e.id}.jpg`;
        } else {
            // Use existing image even if it's not HTTP (could be data: URL or relative path)
            d = e.part_img_url || e.rebrickable_img_url;
        }
    }
    

    const tHtml = t ? `
        <div class="flex items-center pt-1 pointer-events-none">
            <span class="w-4 h-4 rounded-full border border-gray-500 ${t.isTransparent?"checkerboard":""}" style="background-color: ${t.hex};"></span>
            <span class="ml-2 text-xs text-gray-300 truncate">${t.name}</span>
        </div>
    ` : "";
    return `
            <div data-group-id="${n}" data-part-id="${e.id}" ${i && t ?`data-color-id="${t.id}"`:""} style="${s}" class="part-card ${r} relative bg-gray-800 rounded-lg overflow-hidden group transform transition-all duration-300 hover:bg-gray-700 cursor-pointer hover:scale-105">
                ${i && t ?`
                    <button aria-label="Удалить ${e.name} (${t.name})" data-action="delete-from-collection" data-part-id="${e.id}" data-color-id="${t.id}" class="absolute top-3 right-3 bg-red-600 text-white p-1.5 rounded-full z-10 shadow-md transition-colors hover:bg-red-700 opacity-100 focus:opacity-100 md:opacity-0 md:group-hover:opacity-100">
                        ${I_Trash("w-4 h-4")}
                    </button>
                `:""}
                ${c}
                <div class="w-full h-40 bg-gray-700 flex items-center justify-center p-2 rounded-t-lg">
                    <div class="w-full h-full bg-white rounded-md flex items-center justify-center overflow-hidden shadow-inner">
                        <img ${getPartImageUrl(d)} alt="${e.name}" class="w-full h-full object-contain pointer-events-none" loading="lazy" />
                    </div>
                </div>
                <div class="p-4 space-y-1">
                    <h3 class="text-sm font-semibold text-white truncate pointer-events-none">${e.name}</h3>
                    <p class="text-xs text-gray-400 pointer-events-none">ID: ${e.id}</p>
                    ${i? tHtml :""}
                </div>
            </div>
        `
}

function renderAppliedFilters() {
    let e = "",
        t = !1,
        o = !1;
    if ("sets" === S.subView) {
        const {
            minYear: l,
            maxYear: a,
            minParts: i,
            maxParts: n
        } = S.setFilters, r = [l && `Мин. год: ${l}`, a && `Макс. год: ${a}`, i && `Мин. деталей: ${i}`, n && `Макс. деталей: ${n}`].filter(Boolean).map(e => `
                <div class="flex items-center bg-green-900/50 text-green-200 rounded-full pl-3 pr-2 py-1 text-sm">
                    <span class="mr-2">${e}</span>
                </div>`).join(""), s = {
            year_desc: "Год (новые)",
            year_asc: "Год (старые)",
            parts_desc: "Детали (убыв.)",
            parts_asc: "Детали (возр.)",
            alpha_asc: "Алфавит (А-Я)",
            alpha_desc: "Алфавит (Я-А)"
        },
        c = {
            [Symbol.iterator]: function*() {
                yield* Object.entries(this).map(([k, v]) => [k, v])
            }
        };
        Object.assign(c, s);
        t = S.q ? "relevance" === S.sortBy : "year_desc" === S.sortBy;
        const d = t || !s[S.sortBy] ? "" : `
                <div class="flex items-center bg-gray-600 text-gray-200 rounded-full pl-3 pr-2 py-1 text-sm">
                    <span class="mr-2">Сортировка: ${s[S.sortBy]}</span>
                </div>
            `;
        e = [d, r].filter(Boolean).join(""), o = !t || !!(l || a || i || n)
    } else if ("minifigs" === S.subView) {
        const l = {
            name_asc: "Алфавит (А-Я)",
            name_desc: "Алфавит (Я-А)",
            num_parts_desc: "Кол-во деталей (убыв.)",
            num_parts_asc: "Кол-во деталей (возр.)"
        },
        a = {
            [Symbol.iterator]: function*() {
                yield* Object.entries(this).map(([k, v]) => [k, v])
            }
        };
        Object.assign(a, l);
        t = S.q ? "relevance" === S.sortBy : "name_asc" === S.sortBy;
        const i = t || !l[S.sortBy] ? "" : `
                <div class="flex items-center bg-gray-600 text-gray-200 rounded-full pl-3 pr-2 py-1 text-sm">
                    <span class="mr-2">Сортировка: ${l[S.sortBy]}</span>
                </div>
            `;
        e = i, o = !t
    } else {
        const {
            colorIds: l,
            inCollectionOnly: a
        } = S.filters, i = l.map(e => {
            if (!COLOR_MAP[e]) return "";
            return `
                <div class="flex items-center bg-blue-900/50 text-blue-200 rounded-full pl-3 pr-2 py-1 text-sm">
                    <span class="mr-2">${COLOR_MAP[e].name}</span>
                    <button data-action="remove-filter" data-filter-type="color" data-color-id="${e}" class="text-blue-200 hover:bg-blue-500/50 rounded-full p-0.5">${I_X("w-4 h-4")}</button>
                </div>
                `
        }).join(""), n = a && "catalog" === S.view ? `
                <div class="flex items-center bg-green-900/50 text-green-200 rounded-full pl-3 pr-2 py-1 text-sm">
                    <span class="mr-2">В коллекции</span>
                    <button data-action="remove-filter" data-filter-type="inCollectionOnly" class="text-green-200 hover:bg-green-500/50 rounded-full p-0.5">${I_X("w-4 h-4")}</button>
                </div>
            ` : "", r = {
            relevance: "Релевантность",
            alpha_asc: "Алфавит (А-Я)",
            alpha_desc: "Алфавит (Я-А)",
            popularity: "Популярность",
            quantity_desc: "Кол-во в коллекции (убыв.)",
            quantity_asc: "Кол-во в коллекции (возр.)"
        },
        s = {
            [Symbol.iterator]: function*() {
                yield* Object.entries(this).map(([k, v]) => [k, v])
            }
        };
        Object.assign(s, r);
        t = S.q ? "relevance" === S.sortBy : "popularity" === S.sortBy;
        const c = t ? "" : `
                <div class="flex items-center bg-gray-600 text-gray-200 rounded-full pl-3 pr-2 py-1 text-sm">
                    <span class="mr-2">Сортировка: ${r[S.sortBy]}</span>
                    <button data-action="remove-filter" data-filter-type="sortBy" class="text-gray-200 hover:bg-gray-500/50 rounded-full p-0.5">${I_X("w-4 h-4")}</button>
                </div>
            `;
        e = [c, i, n].filter(Boolean).join(""), o = !t || l.length > 0 || (a && "catalog" === S.view)
    }
    return o ? `
            <div class="px-4 pt-2 pb-0">
                <div class="flex items-center flex-wrap gap-2">
                    ${e}
                    <button data-action="remove-all-filters" class="text-sm text-blue-400 hover:underline">Очистить все</button>
                </div>
            </div>
        ` : ""
}

function renderMainContent() {
    let e = "";
    if (S.loading) e = '<div class="flex flex-col items-center justify-center h-full p-8 text-center"><div class="loader"></div><p class="mt-4 text-gray-400">Загрузка...</p></div>';
    else if (S.err) e = `<div class="flex flex-col items-center justify-center h-full p-8 text-center text-red-400"><p class="font-semibold">Произошла ошибка</p><p class="text-sm mt-2">${S.err}</p></div>`;
    else if ("catalog" === S.view) {
        let t, o, l, a = "grid-cols-[repeat(auto-fill,minmax(150px,1fr))]";
        if ("parts" === S.subView) {
            let i = {};
            l = "Выберите категорию, чтобы увидеть детали, или воспользуйтесь поиском.", S.filters.colorIds?.length > 1 ? l = 'Фильтрация по нескольким цветам в режиме "Каталог" не поддерживается. Пожалуйста, выберите один цвет или просмотрите свою "Коллекцию".' : null !== S.searchGroups ? (i = S.searchGroups, l = "По вашему запросу ничего не найдено.") : null !== S.selCatId && (i = S.catGroups, l = "В этой категории нет деталей.");
            let n = Object.values(i).flat();
            switch (S.sortBy) {
                case "alpha_asc":
                    n.sort((e, t) => e.name.localeCompare(t.name, 'en'));
                    break;
                case "alpha_desc":
                    n.sort((e, t) => t.name.localeCompare(e.name, 'en'));
                    break;
                case "popularity":
                    n.sort((e, t) => t.num_sets - e.num_sets)
            }
            i = groupParts(n);
            const r = i ? Object.keys(i) : [];
            t = r.map(e => i[e][0]);
            o = e => {
                const t = Object.values(S.coll[e.id] || {}).reduce((e, t) => e + t, 0);
                return renderPartCard(e, null, t, S.gridStale)
            }, a = "grid-cols-[repeat(auto-fill,minmax(130px,1fr))]";
        } else "sets" === S.subView ? (t = S.q ? S.searchSetRes : S.setRes, o = e => renderSetCard(e, S.gridStale), l = S.q ? "По вашему запросу ничего не найдено." : "Выберите тему для просмотра наборов.") : (t = S.q ? S.searchMinifigRes : S.minifigRes, o = e => renderMinifigCard(e, S.gridStale), l = S.q ? "По вашему запросу ничего не найдено." : "catalog" === S.view && !S.q ? "Используйте поиск для нахождения минифигурок." : "В коллекции нет минифигурок.");
        if (!t || 0 === t.length) e = `
                    <div class="flex flex-col items-center justify-center h-full p-4 text-center">
                        ${S.sidebarLoading ? `
                            <div class="flex items-center text-blue-400 text-sm mb-6">
                                <div class="loader !w-6 !h-6 !border-2 mr-3"></div>
                                <span>Загрузка данных...</span>
                            </div>
                        ` : ''}
                        <p class="text-gray-400 max-w-sm mb-6">${l}</p>
                        <button id="feeling-lucky-button" class="flex items-center gap-3 bg-blue-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-blue-700 transition-all duration-200 transform hover:scale-105 shadow-lg">
                            ${I_Dice("w-6 h-6")} Мне повезёт!
                        </button>
                    </div>`;
        else {
            S.hasMoreItems = t.length > S.toDisplay;
            const l = t.slice(0, S.toDisplay);
            e = `<div class="grid ${a} gap-4 p-4">
                    ${l.map((e,t)=>{const l=o(e);return l.replace('class="part-card ',`style="animation-delay: ${Math.min(40*t,1500)}ms;" class="part-card `).replace('class="set-card ',`style="animation-delay: ${Math.min(40*t,1500)}ms;" class="set-card `).replace('class="minifig-card ',`style="animation-delay: ${Math.min(40*t,1500)}ms;" class="minifig-card `)}).join("")}
                </div>`
        }
    } else {
        let t, o, l = `В вашей коллекции нет ${"parts"===S.subView?"деталей":"sets"===S.subView?"наборов":"минифигурок"}`,
            i = S.q.trim().toLowerCase(),
            n = "grid-cols-[repeat(auto-fill,minmax(150px,1fr))]";
        if ("parts" === S.subView) {
            const e = [];
            for (const t in S.coll)
                for (const o in S.coll[t]) {
                    const l = PART_MAP[t],
                        a = COLOR_MAP[o],
                        i = S.coll[t][o];
                    if (l && a && i > 0) {
                        e.push({
                            part: l,
                            color: a,
                            quantity: i
                        });
                        
                        // Fetch missing part details for collection items
                        if (!l.name || !l.part_img_url) {
                            fetchMissingCollectionPartDetails().catch(console.error);
                        }
                    }
                }
            let filteredParts = e;
            S.selCollCatId && (filteredParts = e.filter(({
                part: e
            }) => PART_MAP[e.id]?.categoryId === S.selCollCatId));
            S.filters.colorIds?.length > 0 && (filteredParts = e.filter(e => S.filters.colorIds.includes(e.color.id)));
            i && (filteredParts = e.filter(({
                part: e
            }) => e.name.toLowerCase().includes(i) || e.id.toLowerCase().includes(i)));
            t = filteredParts;
            switch (S.sortBy) {
                case "alpha_asc":
                    t.sort((e, t) => e.part.name.localeCompare(t.part.name, 'en'));
                    break;
                case "alpha_desc":
                    t.sort((e, t) => t.part.name.localeCompare(e.part.name, 'en'));
                    break;
                case "quantity_desc":
                    t.sort((a, b) => b.quantity - a.quantity);
                    break;
                case "quantity_asc":
                    t.sort((a, b) => a.quantity - b.quantity);
                    break;
                case "popularity":
                    t.sort((e, t) => (PART_MAP[t.part.id]?.num_sets || 0) - (PART_MAP[e.part.id]?.num_sets || 0))
            }
            o = (e, t, o) => renderPartCard(e.part, e.color, e.quantity, t, o);
            n = "grid-cols-[repeat(auto-fill,minmax(130px,1fr))]";
        } else if ("sets" === S.subView) {
            let sets = Object.keys(S.setColl).map(e => SET_MAP[e]).filter(Boolean);
            
            // Fetch missing set details for collection items
            sets.forEach(set => {
                if (!set.name || !set.set_img_url) {
                    fetchMissingCollectionSetDetails().catch(console.error);
                }
            });
            
            if (S.selCollThemeId) {
                const getAllChildThemeIds = (themeId) => {
                    const theme = THEME_MAP[themeId];
                    if (!theme) return [];
                    let ids = [theme.id];
                    if (Array.isArray(theme.children)) {
                        theme.children.forEach(child => {
                            ids = ids.concat(getAllChildThemeIds(child.id));
                        });
                    }
                    return ids;
                };
                const allowedThemeIds = getAllChildThemeIds(S.selCollThemeId);
                sets = sets.filter(set => set && allowedThemeIds.includes(set.theme_id));
            }
            i && (sets = sets.filter(e => e.name.toLowerCase().includes(i) || e.set_num.toLowerCase().includes(i)));
            t = sets;
            switch (S.sortBy) {
                case "alpha_asc":
                    t.sort((e, t) => e.name.localeCompare(t.name, 'en'));
                    break;
                case "alpha_desc":
                    t.sort((e, t) => t.name.localeCompare(t.name, 'en'));
                    break;
                case "year_asc":
                    t.sort((e, t) => e.year - t.year);
                    break;
                case "year_desc":
                    t.sort((e, t) => t.year - e.year);
                    break;
                case "parts_asc":
                    t.sort((e, t) => e.num_parts - t.num_parts);
                    break;
                case "parts_desc":
                    t.sort((e, t) => t.num_parts - e.num_parts)
            }
            o = (e, t, o) => renderSetCard(e, t, o)
        } else {
            let minifigs = Object.keys(S.minifigColl).map(e => MINIFIG_MAP[e]).filter(Boolean);
            i && (minifigs = minifigs.filter(e => e.name.toLowerCase().includes(i) || e.set_num.toLowerCase().includes(i)));
            t = minifigs;
            
            // Fetch missing minifig details for collection items
            minifigs.forEach(minifig => {
                if (!minifig.name || !minifig.minifig_img_url) {
                    fetchMinifigDetails(minifig.set_num).catch(console.error);
                }
            });
            
            switch (S.sortBy) {
                case "name_asc":
                    t.sort((e, t) => e.name.localeCompare(t.name, 'en'));
                    break;
                case "name_desc":
                    t.sort((e, t) => t.name.localeCompare(e.name, 'en'));
                    break;
                case "num_parts_desc":
                    t.sort((e, t) => t.num_parts - e.num_parts);
                    break;
                case "num_parts_asc":
                    t.sort((e, t) => e.num_parts - t.num_parts)
            }
            o = (e, t, o) => renderMinifigCard(e, t, o);
        }
        if (t.length === 0) {
            (i || "parts" === S.subView && (S.filters.colorIds.length > 0 || S.selCollCatId) || "sets" === S.subView && S.selCollThemeId) && (l += ", соответствующих фильтрам");
            l += ".";
            e = `<div class="flex flex-col items-center justify-center h-full p-4 text-center">
                    ${S.sidebarLoading ? `
                        <div class="flex items-center text-blue-400 text-sm mb-6">
                            <div class="loader !w-6 !h-6 !border-2 mr-3"></div>
                            <span>Загрузка данных...</span>
                        </div>
                    ` : ''}
                    <p class="text-gray-400">${l}</p>
                </div>`;
        } else {
            S.hasMoreItems = t.length > S.toDisplay;
            const l = t.slice(0, S.toDisplay);
            e = `<div class="grid ${n} gap-4 p-4">
                    ${l.map((e,t)=>o(e,S.gridStale,t)).join("")}
                </div>`
        }
    }
    mainEl.innerHTML = renderAppliedFilters() + e;
    S.gridStale = !1;

    // Автоматически загружать больше контента, если нет полосы прокрутки
    requestAnimationFrame(() => {
        if (!S.loading && S.hasMoreItems && mainEl.scrollHeight <= mainEl.clientHeight) {
            S.toDisplay += S.increment;
            renderMainContent();
        }
    });
    
    // Removed automatic image loading to prevent constant UI updates
}

// Add scroll event listener for automatic image loading (simplified)
function setupScrollListener() {
    // This function is now simplified to avoid constant UI updates
    // Scroll events will not trigger automatic image loading
    return;
}

function renderSetCollectionControls() {
    if (!S.selSetNum) return "";
    const {
        qty: e
    } = S.setModal, t = S.setColl[S.selSetNum]?.qty || 0;
    return `
            <div class="bg-gray-700/50 rounded-lg p-4">
                <div class="space-y-4">
                    <div class="flex justify-between items-center">
                        <h3 class="text-white font-semibold">Коллекция наборов</h3>
                        <p class="text-sm text-gray-400 text-right">В коллекции: <span id="set-modal-in-collection-qty" class="font-bold text-white">${t}</span></p>
                    </div>
                    
                    <div class="flex justify-between items-center gap-4">
                        <div class="flex items-center gap-2">
                            <button data-action="decrease-set-qty" class="p-2 rounded-full ${e > 0 ? 'bg-gray-600 hover:bg-gray-500' : 'bg-gray-700 cursor-not-allowed'} text-white transition-colors" ${e <= 0 ? 'disabled' : ''}>${I_Minus("w-5 h-5")}</button>
                            <input id="set-modal-quantity-input" type="number" value="${e}" readonly class="w-12 text-center bg-gray-900 text-white font-bold rounded-md py-1"/>
                            <button data-action="increase-set-qty" class="p-2 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors">${I_Plus("w-5 h-5")}</button>
                        </div>
                        <button data-action="update-set-collection" class="flex-grow bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors">
                            ${t>0?"Обновить":"Добавить"}
                        </button>
                    </div>
                    ${t>0?`
                        <div>
                            <button data-action="delete-from-set-collection-modal" class="w-full mt-1 text-sm text-red-400 hover:text-red-300 hover:bg-red-900/50 rounded-md py-1.5 transition-colors">Удалить из коллекции</button>
                        </div>
                    `:"<div></div>"}
                </div>
            </div>
        `
}

function renderSetBulkPartsControls() {
    return S.selSetNum ? S.setModal.bulkUpdate ? `
                <div class="bg-gray-700/50 rounded-lg p-4 mt-4">
                     <h3 class="text-md font-semibold text-gray-300 mb-2">Коллекция деталей</h3>
                     <div class="flex items-center justify-center gap-3 text-white h-10">
                        <div class="loader !w-5 !h-5 !border-2"></div>
                        <span>Обновление...</span>
                     </div>
                </div>
            ` : `
            <div class="bg-gray-700/50 rounded-lg p-4 mt-4">
                <h3 class="text-md font-semibold text-gray-300 mb-2">Коллекция деталей</h3>
                <div class="grid grid-cols-2 gap-2">
                    <button data-action="bulk-add-parts" class="flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-green-600 hover:bg-green-700 text-white">
                        ${I_Plus("w-5 h-5 mr-2")} Добавить все
                    </button>
                    <button data-action="bulk-remove-parts" class="flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-600 hover:bg-red-700 text-white">
                        ${I_Minus("w-5 h-5 mr-2")} Удалить все
                    </button>
                </div>
            </div>
        ` : ""
}

function renderSetModalToggleButton() {
    const e = SET_MAP[S.selSetNum];
    return e ? "details" === S.setModal.view ? `<button data-action="toggle-set-modal-view" class="flex items-center gap-2 px-3 py-1.5 text-sm font-semibold rounded-md transition-colors bg-gray-600 hover:bg-gray-500 text-white">
                ${I_Brick("w-5 h-5")}
                <span>Инвентарь</span>
                <span class="text-xs bg-gray-700 text-gray-200 px-1.5 py-0.5 rounded-full">${e.num_parts}</span>
            </button>` : `<button data-action="toggle-set-modal-view" class="flex items-center gap-2 px-3 py-1.5 text-sm font-semibold rounded-md transition-colors bg-blue-600 hover:bg-blue-700 text-white">
                ${I_Cat("w-5 h-5")}
                <span>Детали набора</span>
            </button>` : ""
}

function renderSetModalDetailsView() {
    const e = SET_MAP[S.selSetNum];
    const t = THEME_MAP[e.theme_id];
    return `
        <div class="flex flex-col lg:flex-row">
            <div class="lg:w-1/2 p-4 sm:p-6 bg-gray-900/30 flex items-center justify-center flex-shrink-0 border-b lg:border-b-0 lg:border-r border-gray-700">
                 <div data-action="view-image-fullscreen" data-image-url="${e.set_img_url||""}" class="w-48 h-48 sm:w-64 sm-h-64 bg-white rounded-lg flex items-center justify-center overflow-hidden shadow-lg relative cursor-pointer group">
                    <img ${getPartImageUrl(e.set_img_url)} alt="${e.name}" class="max-w-full max-h-full object-contain">
                    <div class="absolute inset-0 bg-black/40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                        ${I_Search("w-10 h-10 text-white")}
                    </div>
                 </div>
            </div>
            
            <div class="lg:w-1/2 p-4 sm:p-6 flex flex-col">
                <div class="space-y-6">
                    <div>
                        <h3 class="text-md font-semibold text-gray-300 mb-3">Детали</h3>
                        <div class="space-y-1 text-sm text-gray-400">
                            <p><span class="font-semibold text-gray-300">Название:</span> ${e.name}</p>
                            <p>ID: ${e.set_num}</p>
                            <p>Год: ${e.year}</p>
                            <p>Кол-во деталей: ${e.num_parts}</p>
                            ${t?`<div class="flex items-center">
                                <span class="mr-1">Тема:</span>
                                <button data-action="go-to-theme" data-theme-id="${t.id}" class="text-blue-400 hover:text-blue-300 hover:underline text-left truncate">
                                    ${t.name}
                                </button>
                            </div>`:""}
                        </div>
                    </div>

                    <div id="set-modal-controls-container">
                        ${renderSetCollectionControls()}
                        ${renderSetBulkPartsControls()}
                    </div>
                    
                     ${S.setModal.status?`
                        <div class="mt-4 p-2 text-sm rounded-md ${"error"===S.setModal.statusType?"bg-red-900/50 text-red-300":"bg-green-900/50 text-green-300"}">
                            ${S.setModal.status}
                        </div>
                     `:""}
                </div>
            </div>
        </div>
        `
}

function renderSetModalInventoryView() {
    return `<div id="set-inventory-container" class="p-4 flex flex-col">
            ${renderSetInventory()}
        </div>`
}

function updateSetModalView() {
    if (!S.selSetNum) return;
    const e = document.getElementById("set-modal-view-container");
    e && ("details" === S.setModal.view ? e.innerHTML = renderSetModalDetailsView() : e.innerHTML = renderSetModalInventoryView())
}

function renderSetModal(e = !1) {
    if (!S.selSetNum) return void closeSetModal();
    const t = SET_MAP[S.selSetNum];
    if (!t) return void closeSetModal();
    const o = e ? "modal-content-enter" : "",
        l = "inventory" === S.setModal.view;
    e && (document.body.classList.add("overflow-hidden"), setModalEl.classList.remove("modal-hidden"), requestAnimationFrame(() => setModalEl.classList.add("visible"))), setModalEl.innerHTML = `
        <div id="set-modal-content" class="bg-gray-800 rounded-lg shadow-xl w-[calc(100%-2rem)] ${l?"max-w-6xl":"max-w-4xl"} flex flex-col ${l?"h-[calc(100vh-4rem)]":"max-h-[calc(100vh-2rem)]"} ${o} transition-all duration-300">
            <div class="flex-shrink-0 p-4 border-b border-gray-700 flex justify-between items-center gap-4">
                 <h2 class="text-xl lg:text-2xl font-bold text-white truncate pr-4">${t.name}</h2>
                 <div class="flex items-center gap-2 flex-shrink-0">
                    ${renderSetModalToggleButton()}
                    <button id="set-modal-close" class="text-gray-400 hover:text-white transition-colors">${I_X("w-6 h-6")}</button>
                 </div>
            </div>
            <div id="set-modal-view-container" class="flex-grow overflow-y-auto no-scrollbar" style="min-height: 0;">
            </div>
        </div>
        `, updateSetModalView()
}

function renderSetInventory() {
    const {
        inv: e,
        loading: t,
        hasNextInv: o,
        minifigs: l,
        loadingMinifigs: a
    } = S.setModal;
    let i = "";
    a ? i = '<div class="flex items-center justify-center p-4"><div class="loader !w-6 !h-6"></div></div>' : l?.length > 0 && (i = l.map(e => {
        const t = e.set_num,
            o = S.minifigColl[t]?.qty || 0,
            l = e.name || "Загрузка...";
        const n = e.isLoadingParts ? '<div class="flex items-center justify-center p-2"><div class="loader !w-5 !h-5"></div></div>' : e.loadingError ? `
                        <div class="text-center p-2">
                            <p class="text-xs text-red-400 mb-2">Не удалось загрузить детали.</p>
                            <button data-action="retry-load-minifig-parts" data-fig-num="${t}" class="text-xs px-2 py-1 rounded-md bg-blue-600 hover:bg-blue-700 text-white transition-colors">
                                Попробовать снова
                            </button>
                        </div>
                    ` : (e.parts || []).map((e) => `
                                <div class="flex items-center p-1.5 rounded-md gap-2 text-xs">
                                    <div class="w-8 h-8 bg-white rounded flex items-center justify-center flex-shrink-0">
                                        <img ${getPartImageUrl(e.part.part_img_url)} alt="${e.part.name}" class="w-full h-full object-contain p-0.5">
                                    </div>
                                    <div class="flex-grow truncate">
                                        <p class="text-gray-200 truncate">${e.part.name}</p>
                                        <p class="text-gray-400 truncate">${e.part.part_num}</p>
                                    </div>
                                    <div class="flex items-center gap-2 flex-shrink-0">
                                        <span class="w-4 h-4 rounded-full border border-gray-500 ${e.color.isTransparent?"checkerboard":""}" style="background-color: ${e.color.hex};" title="${e.color.name}"></span>
                                        <span class="text-gray-300 w-6 text-right">${e.quantity}x</span>
                                    </div>
                                </div>
                            `).join("") || (e.parts && 0 === e.parts.length ? '<p class="text-xs text-gray-400 text-center p-2">Детали не найдены.</p>' : "");
        return `
                    <div class="bg-gray-700/50 rounded-lg overflow-hidden">
                        <div class="flex items-center p-2 gap-3 text-sm">
                            <div data-action="view-image-fullscreen" data-image-url="${e.minifig_img_url||e.set_img_url||""}" class="w-12 h-12 bg-white rounded-md flex items-center justify-center flex-shrink-0 cursor-pointer group relative">
                                <img ${getPartImageUrl(e.minifig_img_url || e.set_img_url)} alt="${l}" class="w-full h-full object-contain p-1">
                                <div class="absolute inset-0 bg-black/40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                                    ${I_Search("w-5 h-5 text-white")}
                                </div>
                            </div>
                            <div class="flex-grow truncate">
                                <p class="text-white font-semibold truncate">${l}</p>
                                <p class="text-gray-400 truncate">${t}</p>
                            </div>
                            <div class="flex items-center gap-2 flex-shrink-0">
                                <span class="text-gray-300 w-8 text-right font-semibold">${e.quantity}x</span>
                                <button data-action="add-minifig-to-collection" data-fig-num="${t}" data-quantity="${e.quantity}" class="p-2 rounded-full text-white transition-colors ${o>0?"bg-green-600":"bg-blue-600 hover:bg-blue-700"}" title="${o>0?`В коллекции: ${o}`:`Добавить ${e.quantity} в коллекцию минифигурок`}">
                                    ${I_Minifig("w-5 h-5")}
                                </button>
                                <button data-action="toggle-minifig-parts" data-fig-num="${t}" class="p-2 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors" title="Показать/скрыть детали">
                                    ${I_Chev(`w-5 h-5 transform transition-transform duration-200 ${e.isExpanded?"rotate-180":""}`)}
                                </button>
                            </div>
                        </div>
                        <div id="minifig-parts-${t.replace(/[^a-zA-Z0-9]/g,"-")}" class="${e.isExpanded?"bg-gray-900/40 p-2 max-h-60 overflow-y-auto no-scrollbar":"hidden"}">
                             ${e.isExpanded?`
                                <div class="flex justify-end items-center mb-2 px-1.5">
                                    <button data-action="add-minifig-parts-to-collection" data-fig-num="${t}" class="flex items-center gap-2 text-xs px-2 py-1 rounded-md bg-blue-600 hover:bg-blue-700 text-white transition-colors disabled:opacity-50" title="Добавить все детали этой минифигурки в вашу коллекцию деталей" ${S.setModal.bulkUpdate?"disabled":""}>
                                        ${I_Plus("w-4 h-4")}
                                        <span>Добавить детали</span>
                                    </button>
                                </div>
                            `:""}
                            ${n}
                        </div>
                    </div>
                `
    }).join(""));
    const r = e.map(e => `
            <div class="flex items-center bg-gray-700/50 p-2 rounded-md gap-3 text-sm">
                <div class="w-12 h-12 bg-white rounded-md flex items-center justify-center flex-shrink-0">
                        <img ${getPartImageUrl(e.part.part_img_url)} alt="${e.part.name}" class="w-full h-full object-contain p-1">
                </div>
                <div class="flex-grow truncate">
                    <p class="text-white font-semibold truncate">${e.part.name}</p>
                    <p class="text-gray-400 truncate">${e.part.part_num}</p>
                </div>
                <div class="flex items-center gap-2 flex-shrink-0">
                    <span class="w-5 h-5 rounded-full border border-gray-500 ${e.color.isTransparent?"checkerboard":""}" style="background-color: ${e.color.hex};" title="${e.color.name}"></span>
                    <span class="text-gray-300 w-8 text-right">${e.quantity}x</span>
                </div>
            </div>
        `).join("");
    let s = "";
    return t ? s = '<div class="flex justify-center p-4 flex-shrink-0"><div class="loader !w-8 !h-8"></div></div>' : o && (s = `<div class="pt-4 text-center flex-shrink-0">
                <button data-action="load-more-inventory" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 transition-colors">
                    Загрузить ещё
                </button>
            </div>`), `
            <div class="space-y-6">
                ${i?`
                    <div>
                        <h3 class="text-lg font-semibold text-white mb-3 flex items-center gap-2">
                            ${I_Minifig("w-5 h-5")} Минифигурки
                        </h3>
                        <div class="space-y-2">${i}</div>
                    </div>`:""}
                <div>
                    <h3 class="text-lg font-semibold text-white mb-3 flex items-center gap-2">
                        ${I_Brick("w-5 h-5")} Детали
                    </h3>
                    ${e.length>0||t?`
                        <div class="space-y-2">${r}</div>
                        ${s}
                    `:'<div class="text-sm text-gray-400 p-2">Инвентарь (кроме минифигурок) не найден.</div>'}
                </div>
            </div>
        `
}

function updateSetModalControlsState() {
    if (!S.selSetNum) return;
    const e = document.getElementById("set-modal-controls-container");
    e && (e.innerHTML = renderSetCollectionControls() + renderSetBulkPartsControls())
}

function renderModal() {
    if (!S.selPartId) return void(partModalEl.classList.contains("modal-hidden") || closeModal());
    const e = PART_MAP[S.selPartId];
    if (!e) return void closeModal();
    const t = flatCategories.find(t => t.id === e.categoryId)?.name, {
        variants: o,
        imgUrl: l
    } = S.partModal;
    let a = "";
    o?.length > 1 && (a = `
                <div>
                    <label for="variation-select" class="block text-sm font-medium text-gray-400 mb-2">Вариация</label>
                    <div class="relative variation-select-container">
                        <button id="variation-select-button" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500 cursor-pointer pr-10 text-left flex justify-between items-center hover:bg-gray-600 transition-colors duration-200">
                            <span id="variation-select-text" class="truncate flex-1">${o.find(e => e.id === S.selPartId)?.name || o[0]?.name || ''}</span>
                            <svg class="w-4 h-4 text-gray-400 transition-transform duration-200 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </button>
                        <div id="variation-dropdown" class="absolute bg-gray-700 border border-gray-600 rounded-md shadow-lg z-[99999] max-h-60 overflow-y-auto" style="display: none; background-color: #374151; border: 1px solid #4B5563; border-radius: 6px; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); min-width: 200px;">
                            ${o.map(e=>`
                                <div data-value="${e.id}" class="variation-option px-3 py-2 text-white hover:bg-gray-600 cursor-pointer transition-colors duration-150 ${e.id===S.selPartId?'selected':''}">
                                    <span class="truncate block">${e.name}</span>
                                </div>
                            `).join("")}
                        </div>
                    </div>
                </div>
            `), document.body.classList.add("overflow-hidden"), partModalEl.classList.remove("modal-hidden"), requestAnimationFrame(() => {
        partModalEl.classList.add("visible")
    }), partModalEl.innerHTML = `
        <div id="modal-content" class="bg-gray-800 rounded-lg shadow-xl w-[calc(100%-2rem)] max-w-lg lg:max-w-4xl flex flex-col max-h-[calc(100vh-2rem)] modal-content-enter">
            
            <div class="flex-shrink-0 p-4 border-b border-gray-700 flex justify-between items-center">
                 <h2 class="text-xl lg:text-2xl font-bold text-white lg:truncate pr-8">${e.name}</h2>
                 <button id="modal-close" class="text-gray-400 hover:text-white transition-colors">${I_X("w-6 h-6")}</button>
            </div>
            
            <div id="modal-scroll-area" class="flex-grow flex flex-col lg:flex-row overflow-y-auto no-scrollbar">
                <div class="lg:w-1/2 p-4 sm:p-6 bg-gray-900/30 flex items-center justify-center flex-shrink-0 border-b lg:border-b-0 lg:border-r border-gray-700">
                     <div id="modal-image-container" data-action="view-image-fullscreen" data-image-url="${l||""}" class="w-48 h-48 sm:w-64 sm:h-64 bg-white rounded-lg flex items-center justify-center overflow-hidden shadow-lg relative cursor-pointer group">
                        <img ${getPartImageUrl(l)} alt="${e.name}" class="max-w-full max-h-full object-contain">
                        <div class="absolute inset-0 bg-black/40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                           ${I_Search("w-10 h-10 text-white")}
                        </div>
                     </div>
                </div>
                
                <div class="lg:w-1/2 p-4 sm:p-6 flex flex-col">
                    <div class="space-y-6">
                        <div>
                            <p class="text-sm text-gray-400">ID: ${e.id}</p>
                            ${t?`
                                <div class="text-sm text-gray-400 flex items-center mt-1">
                                    <span class="mr-1">Категория:</span>
                                    <button data-action="go-to-category" data-category-id="${e.categoryId}" class="text-blue-400 hover:text-blue-300 hover:underline text-left truncate">
                                        ${t}
                                    </button>
                                </div>
                            `:""}
                            ${a?`<div class="mt-4">${a}</div>`:""}
                        </div>
                        
                        <div>
                          <h3 class="text-md font-semibold text-gray-300 mb-3">Доступные цвета</h3>
                           <div id="color-selector-container" class="min-h-[200px]">${renderColorSelector()}</div>
                        </div>
                        
                        <div id="modal-controls-container">${renderModalControls()}</div>
                    </div>
                </div>
            </div>
        </div>
        `, updateModalPartially({
        image: !0
    });
    
    // Add event listener for custom variation selector
    const variationSelectButton = document.getElementById("variation-select-button");
    const variationDropdown = document.getElementById("variation-dropdown");
    const variationSelectText = document.getElementById("variation-select-text");
    
    if (variationSelectButton && variationDropdown) {
        console.log('Variation elements found:', {
            button: variationSelectButton,
            dropdown: variationDropdown,
            text: variationSelectText
        });
        

        
        // Toggle dropdown
        variationSelectButton.addEventListener("click", (event) => {
            event.preventDefault();
            console.log('Variation button clicked');
            const isOpen = variationDropdown.style.display !== 'none';
            console.log('Is dropdown open:', isOpen);
            
            if (!isOpen) {
                // Показываем выпадающий список
                variationDropdown.style.display = 'block';
                variationSelectButton.classList.add('open');
                
                // Позиционируем выпадающий список точно под кнопкой
                const buttonRect = variationSelectButton.getBoundingClientRect();
                const modalContainer = document.querySelector('#modal-content');
                const modalRect = modalContainer.getBoundingClientRect();
                
                // Устанавливаем позицию выпадающего списка относительно модального окна
                variationDropdown.style.position = 'absolute';
                variationDropdown.style.left = '0px';
                variationDropdown.style.top = '100%';
                variationDropdown.style.marginTop = '4px';
                variationDropdown.style.width = '100%';
                variationDropdown.style.minWidth = '100%';
                
                console.log('Dropdown positioned at:', {
                    position: 'absolute',
                    left: '0px',
                    top: '100%',
                    width: '100%',
                    buttonWidth: buttonRect.width,
                    modalWidth: modalRect.width
                });
            } else {
                variationDropdown.style.display = 'none';
                variationSelectButton.classList.remove('open');
                console.log('Dropdown closed');
            }
        });
        
        // Handle option selection
        variationDropdown.addEventListener("click", (event) => {
            const option = event.target.closest('.variation-option');
            if (option) {
                const selectedVariationId = option.dataset.value;
                const selectedVariation = S.partModal.variants?.find(v => v.id === selectedVariationId);
                
                if (selectedVariation && selectedVariation.id !== S.selPartId) {
                    // Update selected part ID to the new variation
                    S.selPartId = selectedVariationId;
                    
                    // Update button text
                    variationSelectText.textContent = selectedVariation.name;
                    
                    // Update option styling
                    variationDropdown.querySelectorAll('.variation-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    option.classList.add('selected');
                    
                    // Close dropdown
                    variationDropdown.style.display = 'none';
                    variationSelectButton.classList.remove('open');
                    
                    // Update part modal data for the new variation
                    const newPart = PART_MAP[selectedVariationId];
                    if (newPart) {
                        S.partModal.imgUrl = newPart.rebrickable_img_url || null;
                        S.partModal.selColorId = null;
                        S.partModal.qty = 0;
                        
                        // Update image
                        updateModalPartially({
                            image: true
                        });
                        
                        // Update modal title to show selected variation name
                        const modalTitle = document.querySelector('#modal-content h2');
                        if (modalTitle) {
                            modalTitle.textContent = selectedVariation.name;
                        }
                        
                        // Fetch colors for the new variation
                        if (newPart.availableColorIds && newPart.availableColorIds.length > 0) {
                            S.partModal.selColorId = sortColorIds(newPart.availableColorIds, newPart.id)[0];
                            S.partModal.qty = S.coll[selectedVariationId]?.[S.partModal.selColorId] || 0;
                            updateModalPartially({
                                colors: true,
                                controls: true
                            });
                            fetchPartColorSpecifics(newPart.id, S.partModal.selColorId);
                        } else {
                            fetchPartColors(newPart.id);
                        }
                    }
                }
            }
        });
        
        // Close dropdown when clicking outside
        document.addEventListener("click", (event) => {
            if (!variationSelectButton.contains(event.target) && !variationDropdown.contains(event.target)) {
                variationDropdown.style.display = 'none';
                variationSelectButton.classList.remove('open');
            }
        });
        
        // Close dropdown on escape key
        document.addEventListener("keydown", (event) => {
            if (event.key === "Escape") {
                variationDropdown.style.display = 'none';
                variationSelectButton.classList.remove('open');
            }
        });
        
        // Close dropdown on scroll (important for fixed positioning)
        window.addEventListener("scroll", () => {
            if (variationDropdown.style.display !== 'none') {
                variationDropdown.style.display = 'none';
                variationSelectButton.classList.remove('open');
            }
        });
        
        // Close dropdown on window resize
        window.addEventListener("resize", () => {
            if (variationDropdown.style.display !== 'none') {
                variationDropdown.style.display = 'none';
                variationSelectButton.classList.remove('open');
            }
        });
    }
}

function renderColorSelector() {
    if (!S.selPartId) return "";
    const e = PART_MAP[S.selPartId];
    if (!e) return "";
    const {
        selColorId: t,
        loadingColors: o
    } = S.partModal, l = e.availableColorIds || [];
    return o ? '<div class="flex items-center justify-center h-24"><div class="loader !w-8 !h-8"></div></div>' : 0 === l.length ? '<div class="text-center py-4">\n                        <p class="text-sm text-gray-400 mb-3">Нет информации о доступных цветах.</p>\n                        <button data-action="retry-fetch-colors" class="bg-blue-600 text-white font-bold py-1.5 px-4 rounded-lg hover:bg-blue-700 transition-colors text-sm">\n                            Попробовать снова\n                        </button>\n                    </div>' : `
            <div class="bg-gray-900/50 rounded-lg">
                <div class="relative">
                    <div class="max-h-48 overflow-y-auto no-scrollbar">
                        <div class="flex flex-wrap justify-center gap-3 p-3">
                            ${sortColorIds(l,e.id).map(e=>{const o=COLOR_MAP[e];if(!o)return"";const l=S.coll[S.selPartId]&&S.coll[S.selPartId][e]>0;return`
                <button data-color-id="${e}" title="${o.name}" class="w-8 h-8 rounded-full border-2 transition-transform duration-150 overflow-hidden flex-shrink-0 flex items-center justify-center ${o.isTransparent?"checkerboard":""} ${t===e?"border-blue-500 scale-110":"border-gray-600 hover:border-gray-400"}" style="background-color: ${o.hex};">
                    ${l?'<div class="w-2 h-2 bg-white rounded-full"></div>':""}
                </button>
            `}).join("")}
                        </div>
                    </div>
                    ${l.length>1.5*COLOR_COLLAPSE_THRESHOLD?'<div class="absolute bottom-0 left-0 right-0 h-8 bg-gradient-to-t from-gray-900/50 to-transparent pointer-events-none"></div>':""}
                </div>
            </div>
        `
}

function renderModalControls() {
    const {
        selColorId: e,
        qty: t
    } = S.partModal, o = e ? COLOR_MAP[e] : null;
    if (!o || !S.selPartId) return "";
    const l = S.coll[S.selPartId]?.[e] || 0;
    return `
            <div class="bg-gray-700/50 rounded-lg p-3">
                <div class="space-y-2">
                    <div class="flex justify-between items-center">
                        <p class="text-white font-semibold truncate" title="${o.name}">${o.name}</p>
                        <p class="text-sm text-gray-400 text-right">В коллекции: <span id="modal-in-collection-qty" class="font-bold text-white">${l}</span></p>
                    </div>
                    
                    <div class="flex justify-between items-center gap-3">
                        <div class="flex items-center gap-1.5">
                            <button data-action="decrease-qty" class="p-2 rounded-full ${t > 0 ? 'bg-gray-600 hover:bg-gray-500' : 'bg-gray-700 cursor-not-allowed'} text-white transition-colors" ${t <= 0 ? 'disabled' : ''}>${I_Minus("w-5 h-5")}</button>
                            <input id="modal-quantity-input" type="number" value="${t}" readonly class="w-12 text-center bg-gray-900 text-white font-bold rounded-md py-1"/>
                            <button data-action="increase-qty" class="p-2 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors">${I_Plus("w-5 h-5")}</button>
                        </div>
                        <button id="modal-update-collection-btn" data-action="update-collection" class="flex-grow bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors">
                            ${l>0?"Обновить":"Добавить"}
                        </button>
                    </div>
                    <div id="modal-delete-container" class="h-5 flex items-center justify-center">
                        ${l>0?`
                            <button data-action="delete-from-collection-modal" class="text-sm text-red-400 hover:text-red-300 hover:underline transition-colors">Удалить из коллекции</button>
                        `:""}
                    </div>
                </div>
            </div>
        `
}

function renderFilterModal() {
    if (!S.filterOpen) return void closeFilterModal();
    let e = "";
    if ("sets" === S.subView) {
        const t = [{
            id: "relevance",
            name: "Релевантность",
            desc: "Поиск"
        }, {
            id: "year_desc",
            name: "Год (новые)",
            desc: "По умолч."
        }, {
            id: "year_asc",
            name: "Год (старые)",
            desc: ""
        }, {
            id: "parts_desc",
            name: "Кол-во деталей (убыв.)",
            desc: ""
        }, {
            id: "parts_asc",
            name: "Кол-во деталей (возр.)",
            desc: ""
        }, {
            id: "alpha_asc",
            name: "Алфавит (А-Я)",
            desc: ""
        }, {
            id: "alpha_desc",
            name: "Алфавит (Я-А)",
            desc: ""
        }].map(e => {
            const t = tempFilters.sortBy === e.id,
                o = "relevance" === e.id && !S.q,
                l = ("relevance" === e.id && S.q || "year_desc" === e.id && !S.q ? `<span class="ml-2 text-xs bg-blue-600/50 text-blue-300 px-1.5 py-0.5 rounded-full">По умолч.</span>` : "");
            return `
                    <label class="flex items-center p-3 rounded-lg hover:bg-gray-700/50 transition-colors cursor-pointer ${o?"opacity-50 cursor-not-allowed":""}">
                        <input type="radio" name="sort" value="${e.id}" class="h-4 w-4 text-blue-600 bg-gray-700 border-gray-500 focus:ring-blue-500" ${t?"checked":""} ${o?"disabled":""} data-action="modal-set-sort">
                        <span class="ml-3 text-white">${e.name}</span>
                        ${l}
                    </label>
                `
        }).join("");
        e = `
                <div>
                    <h3 class="text-md font-semibold text-gray-300 mb-2">Сортировать по</h3>
                    <div class="bg-gray-900/50 rounded-lg space-y-1 p-2">${t}</div>
                </div>
                <div>
                    <h3 class="text-md font-semibold text-gray-300 mb-2">Фильтры</h3>
                    <div class="bg-gray-900/50 rounded-lg p-3 space-y-4">
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label for="min-year" class="block text-sm font-medium text-gray-400 mb-1">Мин. год</label>
                                <input type="number" id="min-year" value="${tempFilters.setFilters.minYear}" data-filter-key="minYear" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" data-action="modal-set-filter">
                            </div>
                             <div>
                                <label for="max-year" class="block text-sm font-medium text-gray-400 mb-1">Макс. год</label>
                                <input type="number" id="max-year" value="${tempFilters.setFilters.maxYear}" data-filter-key="maxYear" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" data-action="modal-set-filter">
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label for="min-parts" class="block text-sm font-medium text-gray-400 mb-1">Мин. деталей</label>
                                <input type="number" id="min-parts" value="${tempFilters.setFilters.minParts}" data-filter-key="minParts" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" data-action="modal-set-filter">
                            </div>
                             <div>
                                <label for="max-parts" class="block text-sm font-medium text-gray-400 mb-1">Макс. деталей</label>
                                <input type="number" id="max-parts" value="${tempFilters.setFilters.maxParts}" data-filter-key="maxParts" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                            </div>
                        </div>
                    </div>
                </div>
            `
    } else if ("minifigs" === S.subView) {
        const t = [{
            id: "relevance",
            name: "Релевантность",
            desc: "Поиск"
        }, {
            id: "name_asc",
            name: "Алфавит (А-Я)",
            desc: "По умолч."
        }, {
            id: "name_desc",
            name: "Алфавит (Я-А)",
            desc: ""
        }, {
            id: "num_parts_desc",
            name: "Кол-во деталей (убыв.)",
            desc: ""
        }, {
            id: "num_parts_asc",
            name: "Кол-во деталей (возр.)",
            desc: ""
        }].map(e => {
            const t = tempFilters.sortBy === e.id,
                o = "relevance" === e.id && !S.q,
                l = ("relevance" === e.id && S.q || "name_asc" === e.id && !S.q ? `<span class="ml-2 text-xs bg-blue-600/50 text-blue-300 px-1.5 py-0.5 rounded-full">По умолч.</span>` : "");
            return `
                    <label class="flex items-center p-3 rounded-lg hover:bg-gray-700/50 transition-colors cursor-pointer ${o?"opacity-50 cursor-not-allowed":""}">
                        <input type="radio" name="sort" value="${e.id}" class="h-4 w-4 text-blue-600 bg-gray-700 border-gray-500 focus:ring-blue-500" ${t?"checked":""} ${o?"disabled":""} data-action="modal-set-sort">
                        <span class="ml-3 text-white">${e.name}</span>
                        ${l}
                    </label>
                `
        }).join("");
        e = `
                <div>
                    <h3 class="text-md font-semibold text-gray-300 mb-2">Сортировать по</h3>
                    <div class="bg-gray-900/50 rounded-lg space-y-1 p-2">${t}</div>
                </div>
            `
    } else {
        const sortOptions = [{
            id: "relevance",
            name: "Релевантность",
            desc: "Поиск"
        }, {
            id: "popularity",
            name: "Популярность",
            desc: "Каталог"
        }, {
            id: "alpha_asc",
            name: "Алфавит (А-Я)",
            desc: ""
        }, {
            id: "alpha_desc",
            name: "Алфавит (Я-А)",
            desc: ""
        }];
        if (S.view !== "catalog") {
            sortOptions.push({
                id: "quantity_desc",
                name: "Кол-во в коллекции (убыв.)",
                desc: ""
            }, {
                id: "quantity_asc",
                name: "Кол-во в коллекции (возр.)",
                desc: ""
            });
        }
        const t = sortOptions.map(e => {
            const t = tempFilters.sortBy === e.id,
                o = "relevance" === e.id && !S.q || "popularity" === e.id && S.q,
                l = S.q && "relevance" === e.id || !S.q && "popularity" === e.id ? '<span class="ml-2 text-xs bg-blue-600/50 text-blue-300 px-1.5 py-0.5 rounded-full">По умолч.</span>' : "";
            return `
                    <label class="flex items-center p-3 rounded-lg hover:bg-gray-700/50 transition-colors cursor-pointer ${o?"opacity-50 cursor-not-allowed":""}">
                        <input type="radio" name="sort" value="${e.id}" class="h-4 w-4 text-blue-600 bg-gray-700 border-gray-500 focus:ring-blue-500" ${t?"checked":""} ${o?"disabled":""} data-action="modal-set-sort">
                        <span class="ml-3 text-white">${e.name}</span>
                        ${l}
                    </label>
                `
        }).join(""), o = "catalog" === S.view ? `
                <div>
                    <h3 class="text-md font-semibold text-gray-300 mb-2">Фильтры</h3>
                    <div class="bg-gray-900/50 rounded-lg p-2">
                        <label class="flex justify-between items-center p-2 cursor-pointer">
                            <span class="text-white">Только детали в коллекции</span>
                            <div class="relative">
                                <input type="checkbox" class="sr-only peer" ${tempFilters.filters.inCollectionOnly?"checked":""} data-action="modal-toggle-collection">
                                <div class="w-11 h-6 bg-gray-600 rounded-full peer peer-focus:ring-2 peer-focus:ring-blue-500 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                            </div>
                        </label>
                    </div>
                </div>
                            ` : "", l = Object.keys(COLOR_MAP).sort((e, t) => COLOR_MAP[e].name.localeCompare(COLOR_MAP[t].name, 'en')).map(e => {
            const t = COLOR_MAP[e],
                o = tempFilters.filters.colorIds.includes(e);
            return `<button data-action="modal-set-color" data-color-id="${e}" title="${t.name}" class="w-8 h-8 rounded-full border-2 transition-transform duration-150 overflow-hidden flex-shrink-0 ${t.isTransparent?"checkerboard":""} ${o?"border-blue-500 scale-110":"border-gray-600 hover:border-gray-400"}" style="background-color: ${t.hex};"></button>`
        }).join("");
        e = `
                <div>
                    <h3 class="text-md font-semibold text-gray-300 mb-2">Сортировать по</h3>
                    <div class="bg-gray-900/50 rounded-lg space-y-1 p-2">${t}</div>
                </div>
                ${o}
                <div>
                     <h3 class="text-md font-semibold text-gray-300 mb-2">Фильтр по цвету</h3>
                     <div class="bg-gray-900/50 rounded-lg p-3">
                        <button data-action="modal-set-color" data-color-id="null" class="w-full mb-3 py-2 text-sm rounded-md transition-colors ${0===tempFilters.filters.colorIds.length?"bg-blue-600 text-white font-semibold":"bg-gray-600 hover:bg-gray-500 text-gray-200"}">Все цвета</button>
                        <div class="relative">
                            <div class="max-h-48 overflow-y-auto no-scrollbar pr-2">
                                <div class="grid grid-cols-[repeat(auto-fill,minmax(36px,1fr))] gap-3">
                                    ${l}
                                </div>
                            </div>
                            <div class="absolute bottom-0 left-0 right-0 h-6 bg-gradient-to-t from-gray-900 to-transparent pointer-events-none"></div>
                        </div>
                     </div>
                </div>`
    }
    document.body.classList.add("overflow-hidden"), filterModalEl.classList.remove("modal-hidden"), requestAnimationFrame(() => filterModalEl.classList.add("visible")), filterModalEl.innerHTML = `
            <div id="filter-modal-content" class="bg-gray-800 rounded-lg shadow-xl w-[calc(100%-2rem)] max-w-md flex flex-col max-h-[calc(100vh-2rem)] modal-content-enter">
                <div class="flex-shrink-0 p-4 border-b border-gray-700 flex justify-between items-center">
                     <h2 class="text-xl font-bold text-white">Фильтры и сортировка</h2>
                     <button id="filter-modal-close" class="text-gray-400 hover:text-white transition-colors">${I_X("w-6 h-6")}</button>
                </div>
                <div class="flex-grow p-4 overflow-y-auto no-scrollbar space-y-6">${e}</div>
                <div class="flex-shrink-0 p-4 border-t border-gray-700 flex justify-between items-center gap-4">
                    <button data-action="modal-reset-filters" class="px-4 py-2 text-sm font-semibold rounded-md transition-colors bg-gray-600 hover:bg-gray-500 text-white">Сбросить</button>
                    <button data-action="modal-apply-filters" class="flex-grow px-4 py-2 text-sm font-semibold rounded-md transition-colors bg-blue-600 hover:bg-blue-700 text-white">Применить</button>
                </div>
            </div>
        `
}

function renderSettingsModal() {
    if (!S.settingsOpen) return void closeSettingsModal();
    document.body.classList.add("overflow-hidden"), settingsModalEl.classList.remove("modal-hidden"), requestAnimationFrame(() => settingsModalEl.classList.add("visible"));
    const {
        delConfirm: e,
        status: t,
        statusType: o
    } = S.settingsModal, l = Object.values(S.coll).reduce((e, t) => e + Object.keys(t).length, 0);
    const a = Object.keys(S.setColl).length;
    const i = Object.keys(S.minifigColl).length;
    let n = "";
    n = "parts" === e ? `
                <p class="text-yellow-300 text-sm text-center mb-2">Вы уверены? Это действие необратимо.</p>
                <div class="flex gap-2">
                    <button data-action="cancel-delete" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-600 hover:bg-gray-500 text-white">Отмена</button>
                    <button data-action="confirm-delete-parts" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-800 hover:bg-red-700 text-white">Подтвердить удаление</button>
                </div>` : "all" === e ? `
                <p class="text-yellow-300 text-sm text-center mb-2">Вы уверены? Это действие необратимо и удалит ВСЕ данные.</p>
                <div class="flex gap-2">
                    <button data-action="cancel-delete" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-600 hover:bg-gray-500 text-white">Отмена</button>
                    <button data-action="confirm-delete-all" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-800 hover:bg-red-700 text-white">Подтвердить удаление ВСЕГО</button>
                </div>` : `<button data-action="delete-all-parts" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-600 hover:bg-red-700 text-white ${0===l?"opacity-50 cursor-not-allowed":""}" ${0===l?"disabled":""}>${I_Trash("w-5 h-5 mr-2")} Удалить все детали</button>`;
    let r = "";
    r = "sets" === e ? `
                <p class="text-yellow-300 text-sm text-center mb-2">Вы уверены? Это действие необратимо.</p>
                <div class="flex gap-2">
                    <button data-action="cancel-delete" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-600 hover:bg-gray-500 text-white">Отмена</button>
                    <button data-action="confirm-delete-sets" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-800 hover:bg-red-700 text-white">Подтвердить удаление</button>
                </div>` : "all" === e ? `
                <p class="text-yellow-300 text-sm text-center mb-2">Вы уверены? Это действие необратимо и удалит ВСЕ данные.</p>
                <div class="flex gap-2">
                    <button data-action="cancel-delete" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-600 hover:bg-gray-500 text-white">Отмена</button>
                    <button data-action="confirm-delete-all" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-800 hover:bg-red-700 text-white">Подтвердить удаление ВСЕГО</button>
                </div>` : `<button data-action="delete-all-sets" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-600 hover:bg-red-700 text-white ${0===a?"opacity-50 cursor-not-allowed":""}" ${0===a?"disabled":""}>${I_Trash("w-5 h-5 mr-2")} Удалить все наборы</button>`;
    let s = "";
    s = "minifigs" === e ? `
                <p class="text-yellow-300 text-sm text-center mb-2">Вы уверены? Это действие необратимо.</p>
                <div class="flex gap-2">
                    <button data-action="cancel-delete" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-600 hover:bg-gray-500 text-white">Отмена</button>
                    <button data-action="confirm-delete-minifigs" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-800 hover:bg-red-700 text-white">Подтвердить удаление</button>
                </div>` : "all" === e ? `
                <p class="text-yellow-300 text-sm text-center mb-2">Вы уверены? Это действие необратимо и удалит ВСЕ данные.</p>
                <div class="flex gap-2">
                    <button data-action="cancel-delete" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-600 hover:bg-gray-500 text-white">Отмена</button>
                    <button data-action="confirm-delete-all" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-800 hover:bg-red-700 text-white">Подтвердить удаление ВСЕГО</button>
                </div>` : `<button data-action="delete-all-minifigs" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-600 hover:bg-red-700 text-white ${0===i?"opacity-50 cursor-not-allowed":""}" ${0===i?"disabled":""}>${I_Trash("w-5 h-5 mr-2")} Удалить все минифигурки</button>`;
    const c = "error" === o ? "bg-red-900/50 text-red-300" : "success" === o ? "bg-green-900/50 text-green-300" : "bg-blue-900/50 text-blue-300";
    settingsModalEl.innerHTML = `
             <div id="settings-modal-content" class="bg-gray-800 rounded-lg shadow-xl w-[calc(100%-2rem)] max-w-md flex flex-col max-h-[calc(100vh-2rem)] modal-content-enter">
                <div class="flex-shrink-0 p-4 border-b border-gray-700 flex justify-between items-center">
                     <h2 class="text-xl font-bold text-white">Настройки</h2>
                     <button id="settings-modal-close" class="text-gray-400 hover:text-white transition-colors">${I_X("w-6 h-6")}</button>
                </div>
                <div class="flex-grow p-4 overflow-y-auto no-scrollbar space-y-6">
                     <div>
                        <h3 class="text-md font-semibold text-gray-300 mb-2">Импорт и экспорт CSV</h3>
                         ${t?`<div id="import-export-status" class="mb-2 p-2 text-sm rounded-md ${c}">${t}</div>`:'<div id="import-export-status" class="mb-2"></div>'}
                        <div class="bg-gray-900/50 rounded-lg p-3 space-y-3">
                            <p class="text-xs text-gray-400">Импорт и экспорт вашей коллекции в формате CSV. Импорт объединит данные с вашей текущей коллекцией.</p>
                            <div class="flex gap-3">
                                <button data-action="import-csv" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-purple-600 hover:bg-purple-700 text-white">
                                    ${I_Up("w-5 h-5 mr-2")} Импорт (.csv)
                                </button>
                                <button data-action="export-csv" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-orange-600 hover:bg-orange-700 text-white">
                                    ${I_Down("w-5 h-5 mr-2")} Экспорт (.csv)
                                </button>
                            </div>
                        </div>
                    </div>
                     <div>
                        <h3 class="text-md font-semibold text-gray-300 mb-2">Опасная зона</h3>
                        <div class="bg-red-900/20 border border-red-500/30 rounded-lg p-3 space-y-3">
                           ${"all" !== e ? `<button data-action="delete-all-data" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-800 hover:bg-red-700 text-white mb-3">
                               ${I_Trash("w-5 h-5 mr-2")} Удалить всё
                           </button>` : ""}
                           ${n}
                           ${r}
                           ${s}
                        </div>
                    </div>
                    <div>
                        <h3 class="text-md font-semibold text-gray-300 mb-2">Статистика загрузки</h3>
                        <div class="bg-gray-900/50 rounded-lg p-3 space-y-2 text-sm">
                            <div class="text-green-400 text-xs mb-2">✓ Все данные загружаются из CSV файлов</div>
                            ${(() => {
                                const stats = getLoadingStats();
                                const lastUpdate = stats.lastApiUpdate ? new Date(stats.lastApiUpdate).toLocaleString('ru-RU') : 'Никогда';
                                return `
                                    <div class="grid grid-cols-2 gap-2 text-xs">
                                        <div class="text-gray-400">Цвета:</div>
                                        <div class="text-white">${stats.colors}</div>
                                        <div class="text-gray-400">Категории:</div>
                                        <div class="text-white">${stats.categories}</div>
                                        <div class="text-gray-400">Темы:</div>
                                        <div class="text-white">${stats.themes}</div>
                                        <div class="text-gray-400">Детали:</div>
                                        <div class="text-white">${stats.parts} (${stats.partsWithImages} с изображениями)</div>
                                        <div class="text-gray-400">Наборы:</div>
                                        <div class="text-white">${stats.sets} (${stats.setsWithImages} с изображениями)</div>
                                        <div class="text-gray-400">Минифигурки:</div>
                                        <div class="text-white">${stats.minifigs} (${stats.minifigsWithImages} с изображениями)</div>
                                    </div>
                                    <div class="text-yellow-400 text-xs mt-3 pt-2 border-t border-gray-700/50">
                                        <strong>Данные через API:</strong>
                                    </div>
                                    <div class="grid grid-cols-2 gap-2 text-xs text-yellow-300">
                                        <div class="text-gray-400">Цвета:</div>
                                        <div class="text-white">${stats.apiColors}</div>
                                        <div class="text-gray-400">Детали:</div>
                                        <div class="text-white">${stats.apiParts}</div>
                                        <div class="text-gray-400">Наборы:</div>
                                        <div class="text-white">${stats.apiSets}</div>
                                        <div class="text-gray-400">Минифигурки:</div>
                                        <div class="text-white">${stats.apiMinifigs}</div>
                                        <div class="text-gray-400">Изображения:</div>
                                        <div class="text-white">${stats.apiImages}</div>
                                    </div>
                                    <div class="text-blue-400 text-xs mt-2">
                                        Последнее обновление API: ${lastUpdate}
                                    </div>
                                `;
                            })()}
                        </div>
                    </div>


                    <div>
                        <h3 class="text-md font-semibold text-gray-300 mb-2">Управление кэшем</h3>
                        <div class="bg-gray-900/50 rounded-lg p-3 space-y-3">
                            <p class="text-xs text-gray-400">Управление кэшем приложения для улучшения производительности и освобождения места</p>
                            <div class="flex gap-3">
                                <button data-action="clear-app-cache" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-600 hover:bg-red-700 text-white">
                                    ${I_Trash("w-5 h-5 mr-2")} Очистить кэш
                                </button>
                                <button data-action="get-cache-info" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-blue-600 hover:bg-blue-700 text-white">
                                    ${I_Search("w-5 h-5 mr-2")} Информация
                                </button>
                            </div>
                            <div id="cache-info" class="text-xs text-gray-400 hidden"></div>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-md font-semibold text-gray-300 mb-2">О сайте</h3>
                        <div class="bg-gray-900/50 rounded-lg p-3 space-y-3 text-sm text-gray-400">
                           <p>
                               <strong>Избранное:</strong> Чтобы добавить категорию или тему в избранное для быстрого доступа, наведите на нее курсор в боковом меню и нажмите на появившееся сердечко. Избранные элементы всегда будут отображаться вверху своих списков.
                           </p>
                           <p class="pt-3 border-t border-gray-700/50">
                               Этот сайт использует <a href="https://rebrickable.com/api/" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:underline">Rebrickable API</a>, но не поддерживается и не утверждается Rebrickable.
                           </p>
                        </div>
                    </div>
                </div>
            </div>
        `
}

function updateFilterModalUI() {
    if (!S.filterOpen || !filterModalEl.innerHTML) return;
    
    // Update sort options
    filterModalEl.querySelectorAll('input[name="sort"]').forEach(e => {
        const input = e;
        input.checked = tempFilters.sortBy === input.value;
    });
    
    // Update parts filters
    if ("parts" === S.subView) {
        const e = filterModalEl.querySelector('input[data-action="modal-toggle-collection"]');
        e && (e.checked = tempFilters.filters.inCollectionOnly);
        const t = filterModalEl.querySelector('button[data-color-id="null"]');
        t && (t.className = `w-full mb-3 py-2 text-sm rounded-md transition-colors ${0===tempFilters.filters.colorIds.length?"bg-blue-600 text-white font-semibold":"bg-gray-600 hover:bg-gray-500 text-gray-200"}`);
        filterModalEl.querySelectorAll('button[data-action="modal-set-color"]').forEach(el => {
            const e = el;
            const t = e.dataset.colorId;
            if (t && "null" !== t) {
                const o = tempFilters.filters.colorIds.includes(t),
                    l = COLOR_MAP[t];
                l && (e.className = `w-8 h-8 rounded-full border-2 transition-transform duration-150 overflow-hidden flex-shrink-0 ${l.isTransparent?"checkerboard":""} ${o?"border-blue-500 scale-110":"border-gray-600 hover:border-gray-400"}`)
            }
        })
    }
    
    // Update sets filters
    if ("sets" === S.subView) {
        const minYearInput = filterModalEl.querySelector('input[id="min-year"]');
        const maxYearInput = filterModalEl.querySelector('input[id="max-year"]');
        const minPartsInput = filterModalEl.querySelector('input[id="min-parts"]');
        const maxPartsInput = filterModalEl.querySelector('input[id="max-parts"]');
        
        if (minYearInput) minYearInput.value = tempFilters.setFilters.minYear || "";
        if (maxYearInput) maxYearInput.value = tempFilters.setFilters.maxYear || "";
        if (minPartsInput) minPartsInput.value = tempFilters.setFilters.minParts || "";
        if (maxPartsInput) maxPartsInput.value = tempFilters.setFilters.maxParts || "";
    }
}

function updateModalPartially(e) {
    if (!S.selPartId) return;
    if (e.image) {
        const e = document.getElementById("modal-image-container");
        if (e) {
            const {
                imgUrl: t,
                loadingImg: o
            } = S.partModal;
            const l = PART_MAP[S.selPartId];
            e.dataset.imageUrl = t || "";
            e.innerHTML = `
                    ${o?`<div class="absolute inset-0 bg-gray-900/80 flex items-center justify-center z-10"><div class="loader !w-10 !h-10"></div></div>`:""}
                    <img ${getPartImageUrl(t)} alt="${l.name}" class="max-w-full max-h-full object-contain">
                     <div class="absolute inset-0 bg-black/40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                       ${I_Search("w-10 h-10 text-white")}
                    </div>
                `
        }
    }
    if (e.colors) {
        const e = document.getElementById("color-selector-container");
        e && (e.innerHTML = renderColorSelector())
    }
    if (e.controls) {
        const e = document.getElementById("modal-controls-container");
        e && (e.innerHTML = renderModalControls())
    }
}

function updateModalControlsState() {
    if (!S.selPartId || !S.partModal.selColorId) return;
    const e = S.coll[S.selPartId]?.[S.partModal.selColorId] || 0,
        t = document.getElementById("modal-in-collection-qty");
    t && (t.textContent = String(e));
    const o = document.getElementById("modal-update-collection-btn");
    o && (o.textContent = e > 0 ? "Обновить" : "Добавить");
    const l = document.getElementById("modal-delete-container");
    if (l) {
        const t = '<button data-action="delete-from-collection-modal" class="text-sm text-red-400 hover:text-red-300 hover:underline transition-colors">Удалить из коллекции</button>';
        e > 0 ? l.innerHTML.trim() || (l.innerHTML = t) : l.innerHTML = ""
    }
    const a = document.getElementById("modal-quantity-input");
    a && (a.value = String(S.partModal.qty))
}

function renderMinifigModal(e = !1) {
    if (!S.selFigNum) return void closeMinifigModal();
    const t = MINIFIG_MAP[S.selFigNum];
    if (!t) return void closeMinifigModal();
    const o = e ? "modal-content-enter" : "",
        l = "inventory" === S.minifigModal.view;
    e && (document.body.classList.add("overflow-hidden"), minifigModalEl.classList.remove("modal-hidden"), requestAnimationFrame(() => minifigModalEl.classList.add("visible"))), minifigModalEl.innerHTML = `
        <div id="minifig-modal-content" class="bg-gray-800 rounded-lg shadow-xl w-[calc(100%-2rem)] ${l?"max-w-2xl":"max-w-4xl"} flex flex-col ${l?"h-[calc(100vh-4rem)]":"max-h-[calc(100vh-2rem)]"} ${o} transition-all duration-300">
            <div class="flex-shrink-0 p-4 border-b border-gray-700 flex justify-between items-center gap-4">
                 <h2 class="text-xl lg:text-2xl font-bold text-white truncate pr-4">${t.name}</h2>
                 <div class="flex items-center gap-2 flex-shrink-0">
                    ${renderMinifigModalToggleButton()}
                    <button id="minifig-modal-close" class="text-gray-400 hover:text-white transition-colors">${I_X("w-6 h-6")}</button>
                 </div>
            </div>
            <div id="minifig-modal-view-container" class="flex-grow overflow-y-auto no-scrollbar" style="min-height: 0;">
            </div>
        </div>
        `, updateMinifigModalView()
}

function updateMinifigModalView() {
    if (!S.selFigNum) return;
    const e = document.getElementById("minifig-modal-view-container");
    e && ("details" === S.minifigModal.view ? e.innerHTML = renderMinifigModalDetailsView() : e.innerHTML = renderMinifigModalInventoryView())
}

function renderMinifigModalToggleButton() {
    const e = MINIFIG_MAP[S.selFigNum];
    return e ? "details" === S.minifigModal.view ? `<button data-action="toggle-minifig-modal-view" class="flex items-center gap-2 px-3 py-1.5 text-sm font-semibold rounded-md transition-colors bg-gray-600 hover:bg-gray-500 text-white">
                ${I_Brick("w-5 h-5")}
                <span>Инвентарь</span>
                <span class="text-xs bg-gray-700 text-gray-200 px-1.5 py-0.5 rounded-full">${e.num_parts}</span>
            </button>` : `<button data-action="toggle-minifig-modal-view" class="flex items-center gap-2 px-3 py-1.5 text-sm font-semibold rounded-md transition-colors bg-blue-600 hover:bg-blue-700 text-white">
                ${I_Cat("w-5 h-5")}
                <span>Детали минифигурки</span>
            </button>` : ""
}

function renderMinifigModalDetailsView() {
    if (!S.selFigNum) return "";
    const e = MINIFIG_MAP[S.selFigNum];
    const {
        qty: t
    } = S.minifigModal;
    const o = S.minifigColl[S.selFigNum]?.qty || 0;
    const l = `
        <div class="bg-gray-700/50 rounded-lg p-4">
            <div class="space-y-4">
                <div class="flex justify-between items-center">
                    <h3 class="text-white font-semibold">Коллекция минифигурок</h3>
                    <p class="text-sm text-gray-400 text-right">В коллекции: <span class="font-bold text-white">${o}</span></p>
                </div>
                
                <div class="flex justify-between items-center gap-4">
                    <div class="flex items-center gap-2">
                        <button data-action="decrease-minifig-qty" class="p-2 rounded-full ${t > 0 ? 'bg-gray-600 hover:bg-gray-500' : 'bg-gray-700 cursor-not-allowed'} text-white transition-colors" ${t <= 0 ? 'disabled' : ''}>${I_Minus("w-5 h-5")}</button>
                        <input type="number" value="${t}" readonly class="w-12 text-center bg-gray-900 text-white font-bold rounded-md py-1"/>
                        <button data-action="increase-minifig-qty" class="p-2 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors">${I_Plus("w-5 h-5")}</button>
                    </div>
                    <button data-action="update-minifig-collection" class="flex-grow bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors">
                        ${o>0?"Обновить":"Добавить"}
                    </button>
                </div>
                ${o>0?`
                    <div>
                        <button data-action="delete-from-minifig-collection-modal" class="w-full mt-1 text-sm text-red-400 hover:text-red-300 hover:bg-red-900/50 rounded-md py-1.5 transition-colors">Удалить из коллекции</button>
                    </div>
                `:"<div></div>"}
            </div>
        </div>`;
    return `
        <div class="flex flex-col lg:flex-row">
            <div class="lg:w-1/2 p-4 sm:p-6 bg-gray-900/30 flex items-center justify-center flex-shrink-0 border-b lg:border-b-0 lg:border-r border-gray-700">
                 <div data-action="view-image-fullscreen" data-image-url="${e.minifig_img_url||e.set_img_url||""}" class="w-48 h-48 sm:w-64 sm:w-64 bg-white rounded-lg flex items-center justify-center overflow-hidden shadow-lg relative cursor-pointer group">
                    <img ${getPartImageUrl(e.minifig_img_url || e.set_img_url)} alt="${e.name}" class="max-w-full max-h-full object-contain">
                     <div class="absolute inset-0 bg-black/40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                       ${I_Search("w-10 h-10 text-white")}
                    </div>
                 </div>
                 ${(!e.minifig_img_url && !e.set_img_url) ? `
                 <div class="mt-3 text-center">
                     <button data-action="refresh-minifig-image" class="text-xs px-3 py-1.5 bg-blue-600 hover:bg-blue-700 text-white rounded-md transition-colors">
                         ${I_Refresh("w-4 h-4 inline mr-1")} Обновить изображение
                     </button>
                 </div>
                 ` : ''}
            </div>
            <div class="lg:w-1/2 p-4 sm:p-6 flex flex-col">
                <div class="space-y-6">
                    <div>
                        <h3 class="text-md font-semibold text-gray-300 mb-3">Информация</h3>
                        <div class="space-y-1 text-sm text-gray-400">
                            <p><span class="font-semibold text-gray-300">Название:</span> ${e.name}</p>
                            <p>ID: ${e.set_num}</p>
                            <p>Кол-во деталей: ${e.num_parts}</p>
                        </div>
                    </div>
                    ${l}
                </div>
            </div>
        </div>`
}

function renderMinifigModalInventoryView() {
    const {
        inv: e,
        loadingInv: t,
        invError: o,
        bulkUpdate: l,
        status: a,
        statusType: i
    } = S.minifigModal;
    const n = MINIFIG_MAP[S.selFigNum];
    let r = "";
    if (t) {
        r = `<div class="flex items-center justify-center h-full p-4"><div class="loader"></div></div>`;
    } else if (o) {
        r = `<div class="text-center p-4">
                <p class="text-red-400 mb-3">Не удалось загрузить инвентарь.</p>
                <button data-action="retry-load-minifig-inv" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700">Попробовать снова</button>
            </div>`;
    } else if (e) {
        if (e.length === 0) {
            r = `<p class="text-gray-400 text-center p-4">Инвентарь для этой минифигурки не найден.</p>`;
        } else {
            const t = e.map(e => `
                <div class="flex items-center bg-gray-700/50 p-2 rounded-md gap-3 text-sm">
                    <div class="w-12 h-12 bg-white rounded-md flex items-center justify-center flex-shrink-0">
                        <img ${getPartImageUrl(e.part.part_img_url)} alt="${e.part.name}" class="w-full h-full object-contain p-1">
                    </div>
                    <div class="flex-grow truncate">
                        <p class="text-white font-semibold truncate">${e.part.name}</p>
                        <p class="text-gray-400 truncate">${e.part.part_num}</p>
                    </div>
                    <div class="flex items-center gap-2 flex-shrink-0">
                        <span class="w-5 h-5 rounded-full border border-gray-500 ${e.color.isTransparent?"checkerboard":""}" style="background-color: ${e.color.hex};" title="${e.color.name}"></span>
                        <span class="text-gray-300 w-8 text-right">${e.quantity}x</span>
                    </div>
                </div>`).join("");
            r = `<div class="space-y-2">${t}</div>`;
        }
    }
    return `
        <div class="p-4 space-y-4">
            <div class="flex justify-between items-center bg-gray-700/50 p-3 rounded-lg">
                <h3 class="text-lg font-semibold text-white">Инвентарь деталей</h3>
                ${l?`<div class="flex items-center gap-2 text-sm text-gray-300">
                        <div class="loader !w-4 !h-4 !border-2"></div>
                        <span>Добавление...</span>
                    </div>`: (e && e.length > 0) ? `
                    <button data-action="add-minifig-parts-modal" class="flex items-center gap-2 text-sm px-3 py-1.5 rounded-md bg-blue-600 hover:bg-blue-700 text-white transition-colors disabled:opacity-50" ${l?"disabled":""}>
                        ${I_Plus("w-4 h-4")}
                        <span>Добавить все детали в коллекцию</span>
                    </button>`: ""}
            </div>
            ${a?`<div class="p-2 text-sm rounded-md ${"error"===i?"bg-red-900/50 text-red-300":"bg-green-900/50 text-green-300"}">${a}</div>`:""}
            ${r}
        </div>`;
}

function updateUI() {
    renderSidebar(), renderHeader(), renderMainContent();
    
    // Setup search input event listener (only for updating S.q, not auto-search)
    const searchInput = document.getElementById('search-input');
    if (searchInput && !searchInput.hasAttribute('data-search-listener')) {
        searchInput.setAttribute('data-search-listener', 'true');
        searchInput.addEventListener('input', (e) => {
            S.q = e.target.value;
        });
    }
    
    const e = window.innerWidth < 1024;
    e ? S.sidebarOpen ? (sidebarEl.classList.remove("-translate-x-full"), backdropEl.classList.remove("hidden"), document.body.style.overflow = "hidden") : (sidebarEl.classList.add("-translate-x-full"), backdropEl.classList.add("hidden"), document.body.style.overflow = "") : (sidebarEl.classList.remove("-translate-x-full"), backdropEl.classList.add("hidden"), document.body.style.overflow = "")
    
    // Setup backdrop click handler
    if (backdropEl && !backdropEl.hasAttribute('data-backdrop-listener')) {
        backdropEl.setAttribute('data-backdrop-listener', 'true');
        backdropEl.addEventListener('click', () => {
            S.sidebarOpen = false;
            updateUI();
        });
    }
}

function generateCsvData() {
    const t = (t) => {
        if (null == t) return "";
        const o = String(t);
        return o.includes(",") || o.includes('"') || o.includes("\n") ? `"${o.replace(/"/g,'""')}"` : o
    };
    const e = [
        "type", "id", "quantity", "name",
        "part_cat_id", "part_cat_name",
        "color_id", "color_name",
        "set_theme_id", "set_theme_name", "set_year", "set_num_parts",
        "minifig_num_parts"
    ];
    let o = e.join(",") + "\n";
    for (const [partNum, colors] of Object.entries(S.coll)) {
        for (const [colorId, quantity] of Object.entries(colors)) {
            const part = PART_MAP[partNum];
            const color = COLOR_MAP[colorId];
            const category = part ? flatCategories.find(cat => cat.id === part.categoryId) : null;
            o += [
                t("part"), t(partNum), t(quantity), t(part?.name),
                t(part?.categoryId), t(category?.name),
                t(colorId), t(color?.name),
                "", "", "", "", ""
            ].join(",") + "\n";
        }
    }
    for (const [setNum, collectionInfo] of Object.entries(S.setColl)) {
        const set = SET_MAP[setNum];
        const theme = set ? THEME_MAP[set.theme_id] : null;
        o += [
            t("set"), t(setNum), t(collectionInfo.qty), t(set?.name),
            "", "", "", "",
            t(set?.theme_id), t(theme?.name), t(set?.year), t(set?.num_parts), ""
        ].join(",") + "\n";
    }
    for (const [figNum, collectionInfo] of Object.entries(S.minifigColl)) {
        const minifig = MINIFIG_MAP[figNum];
        o += [
            t("minifig"), t(figNum), t(collectionInfo.qty), t(minifig?.name),
            "", "", "", "", "", "", "", "",
            t(minifig?.num_parts)
        ].join(",") + "\n";
    }
    return o;
}


// Function to export collection to CSV
function exportCollectionToCSV() {
    try {
        updateSettingsModalStatus("Подготовка CSV файла...", "info");
        
        const csvData = generateCsvData();
        
        const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = `lego-collection-${new Date().toISOString().slice(0, 10)}.csv`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        
        updateSettingsModalStatus("Экспорт CSV успешно завершен!", "success");
    } catch (e) {
        console.error("CSV Export failed:", e);
        S.settingsModal.status = `Ошибка экспорта CSV: ${e.message}`, S.settingsModal.statusType = "error";
        renderSettingsModal();
    }
}
async function processCsvData(content) {
    const t = (e, t) => {
        updateSettingsModalStatus(e, t);
        "error" !== t && setTimeout(() => {
            if (S.settingsOpen && S.settingsModal.status === e) {
                S.settingsModal.status = "";
                const statusElement = document.getElementById('import-export-status');
                if (statusElement) {
                    statusElement.classList.add('hidden');
                }
            }
        }, 3e3)
    };
    try {
        const l = content.split(/\r?\n/).filter(e => "" !== e.trim());
        if (l.length < 2) throw new Error("CSV файл пуст или содержит только заголовки.");
        const a = parseCsvLine(l[0]).map(e => e.trim().replace(/"/g, "")),
            i = ["type", "id", "quantity"];
        if (!i.every(e => a.includes(e))) throw new Error(`Неверные заголовки в CSV. Обязательные: ${i.join(", ")}.`);
        let n = {
            parts: 0,
            sets: 0,
            minifigs: 0
        };
        for (let e = 1; e < l.length; e++) {
            const csvRow = parseCsvLine(l[e]),
                row = a.reduce((acc, header, index) => {
                    acc[header] = csvRow[index] ? csvRow[index].trim() : "";
                    return acc;
                }, {});
            const {
                type,
                id,
                quantity
            } = row, qty = parseInt(quantity, 10);
            if (!type || !id || isNaN(qty) || qty <= 0) {
                console.warn(`Пропуск некорректной строки ${e+1}:`, l[e]);
                continue
            }
            switch (type) {
                case "part":
                    {
                        const {
                            color_id,
                            name,
                            part_cat_id,
                            color_name
                        } = row;
                        if (!color_id) continue;
                        S.coll[id] || (S.coll[id] = {});
                        S.coll[id][color_id] = (S.coll[id][color_id] || 0) + qty;
                        if (name && !PART_MAP[id]) {
                            PART_MAP[id] = {
                                id: id,
                                part_num: id,
                                name: name,
                                categoryId: part_cat_id ? parseInt(part_cat_id, 10) : null
                            };
                        }
                        if (color_name && !COLOR_MAP[color_id]) {
                            COLOR_MAP[color_id] = {
                                id: color_id,
                                name: color_name
                            };
                        }
                        n.parts++;
                        break;
                    }
                case "set":
                    {
                        const {
                            name,
                            set_theme_id,
                            set_year,
                            set_num_parts
                        } = row;
                        S.setColl[id] = {
                            qty: (S.setColl[id]?.qty || 0) + qty
                        };
                        // Seed minimal details so set renders immediately; missing fields will be fetched later
                        SET_MAP[id] = {
                            ...SET_MAP[id],
                            set_num: id,
                            name: name || (SET_MAP[id]?.name || ''),
                            theme_id: set_theme_id ? parseInt(set_theme_id, 10) : (SET_MAP[id]?.theme_id ?? null),
                            year: set_year ? parseInt(set_year, 10) : (SET_MAP[id]?.year ?? null),
                            num_parts: set_num_parts ? parseInt(set_num_parts, 10) : (SET_MAP[id]?.num_parts ?? null),
                            set_img_url: SET_MAP[id]?.set_img_url || ''
                        };
                        n.sets++;
                        break;
                    }
                case "minifig":
                    {
                        const {
                            name,
                            minifig_num_parts
                        } = row;
                        S.minifigColl[id] = {
                            qty: (S.minifigColl[id]?.qty || 0) + qty
                        };
                        // Всегда создаём объект MINIFIG_MAP[id], даже если нет имени
                        if (!MINIFIG_MAP[id]) {
                            MINIFIG_MAP[id] = {
                                set_num: id,
                                name: name || "Без названия",
                                num_parts: minifig_num_parts ? parseInt(minifig_num_parts, 10) : null
                            };
                        }
                        n.minifigs++;
                        break;
                    }
            }
        }
        saveState(), t(`Импорт CSV завершен. Добавлено: ${n.parts} деталей, ${n.sets} наборов, ${n.minifigs} минифигурок.`, "success")
    } catch (e) {
        console.error("CSV Import failed:", e), t(`Ошибка импорта CSV: ${e.message}`, "error");
        throw e;
    }
}

async function handleUpdateCollection(e, t, o) {
    S.coll[e] || (S.coll[e] = {});
    o > 0 ? S.coll[e][t] = o : (delete S.coll[e][t], 0 === Object.keys(S.coll[e]).length && delete S.coll[e]), o > 0 && !PART_MAP[e]?.colorImages && await fetchColorDetailsForPart(e), saveState(), forceSaveState(), S.gridStale = !0, "collection" === S.view ? updateUI() : (renderSidebar(), mainEl.querySelector(`.part-card[data-part-id="${e}"]`)?.prepend(function() {
        const total = Object.values(S.coll[e] || {}).reduce((sum, qty) => sum + qty, 0);
        if (total > 0) {
            let el = document.createElement("div");
            el.className = "absolute top-3 right-3 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md";
            el.textContent = String(total);
            return el;
        }
        return document.createDocumentFragment();
    }()));
    
    // If part was added and has no image, fetch it automatically
    if (o > 0 && !PART_MAP[e]?.part_img_url) {
        fetchMissingImagesForCollection().catch(console.error);
    }
    
    if(S.selPartId === e) {
        updateModalControlsState();
        const button = partModalEl.querySelector(`button[data-color-id="${t}"]`);
        if (button) {
            const existingDot = button.querySelector('.w-2.h-2.bg-white.rounded-full');
            if (o > 0 && !existingDot) {
                let dot = document.createElement("div");
                dot.className = "w-2 h-2 bg-white rounded-full";
                button.appendChild(dot);
            } else if (o <= 0 && existingDot) {
                existingDot.remove();
            }
        }
    }
}

function handleUpdateSetCollection(e, t) {
    const o = (S.setColl[e]?.qty || 0) > 0;
    t > 0 ? (S.setColl[e] = {
        qty: t
        }, o || (fetchAllSetInventory(e).catch(t => console.error(`Failed to proactively fetch inventory for ${e}`, t)), fetchSetMinifigs(e).catch(t => console.error(`Failed to proactively fetch minifigs for ${e}`, t)))) : delete S.setColl[e], saveState(), forceSaveState(), S.gridStale = !0, "collection" === S.view ? updateUI() : (renderSidebar(), mainEl.querySelector(`.set-card[data-set-num="${e}"]`)?.prepend(function() {
        if (t > 0) {
            let o = document.createElement("div");
            return o.className = "absolute top-3 right-3 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md", o.textContent = String(t), o
        }
        return document.createDocumentFragment()
    }())), S.selSetNum === e && updateSetModalControlsState()
    
    // If set was added and has no image, fetch it automatically
    if (t > 0 && !SET_MAP[e]?.set_img_url) {
        fetchMissingImagesForCollection().catch(console.error);
    }
}
async function handleUpdateMinifigCollection(e, t, o = !0) {
    const l = S.minifigColl[e]?.qty || 0,
        a = t - l;
    if (0 !== a) try {
        const t = MINIFIG_MAP[e]?.parts || await fetchMinifigParts(e);
        MINIFIG_MAP[e] && !MINIFIG_MAP[e].parts && (MINIFIG_MAP[e].parts = t), (t || []).forEach(t => {
            const o = t.part.part_num,
                l = String(t.color.id),
                i = t.quantity * a;
            S.coll[o] || (S.coll[o] = {});
            const n = S.coll[o][l] || 0,
                r = n + i;
            r > 0 ? S.coll[o][l] = r : (delete S.coll[o][l], 0 === Object.keys(S.coll[o]).length && delete S.coll[o])
        })
    } catch (i) {
        console.error(`Failed to update parts for minifig ${e}:`, i)
    }
    t > 0 ? (S.minifigColl[e] = {
        qty: t
    }, o && !MINIFIG_MAP[e]?.name && await fetchMinifigDetails(e)) : delete S.minifigColl[e], saveState(), forceSaveState(), S.gridStale = !0, "collection" === S.view ? updateUI() : (renderSidebar(), mainEl.querySelector(`.minifig-card[data-fig-num="${e}"]`)?.prepend(function() {
        if (t > 0) {
            let t = document.createElement("div");
            t.className = "absolute top-3 right-3 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md", t.textContent = String(e), t
        }
        return document.createDocumentFragment();
    }()));
    S.selFigNum === e && renderMinifigModal(!1);
    if (S.selSetNum && S.setModal.minifigs.find(t => t.set_num === e)) renderSetModal(!1)
    
    // If minifig was added and has no image, fetch it automatically
    if (t > 0 && !MINIFIG_MAP[e]?.minifig_img_url) {
        fetchMissingImagesForCollection().catch(console.error);
    }
}
async function handleBulkUpdatePartsFromSet(e, t) {
    if (S.setModal.bulkUpdate) return;
    S.setModal.bulkUpdate = !0, S.setModal.status = "", S.setModal.statusType = "", updateSetModalControlsState();
    try {
        (await fetchAllSetInventory(e) || []).forEach(e => {
            const {
                part: o,
                color: l,
                quantity: a
            } = e;
            S.coll[o.part_num] || (S.coll[o.part_num] = {});
            const i = String(l.id),
                n = S.coll[o.part_num][i] || 0;
            "add" === t ? S.coll[o.part_num][i] = n + a : n - a > 0 ? (S.coll[o.part_num][i] = n - a) : (delete S.coll[o.part_num][i], 0 === Object.keys(S.coll[o.part_num]).length && delete S.coll[o.part_num])
        });
        let o = 0,
            l = 0,
            a = 0,
            i = 0;
        const n = S.setModal.minifigs || await apiFetchPaginated(`/sets/${e}/minifigs/`);
        for (let e = 0; e < n.length; e += 3) {
            const r = n.slice(e, e + 3);
            await Promise.all(r.map(async e => {
                const n = e.set_num,
                    r = e.quantity,
                    s = S.minifigColl[n]?.qty || 0;
                "add" === t ? (S.minifigColl[n] = {
                    qty: s + r
                }, o += r) : (s - r > 0 ? S.minifigColl[n] = {
                    qty: s - r
                } : delete S.minifigColl[n], a += r);
                const fig = S.setModal.minifigs.find(f => f.set_num === n);
                const c = fig?.parts || await fetchMinifigParts(n);
                if (fig) fig.parts = c;
                (c || []).forEach(e => {
                    const o = e.part.part_num,
                        a = String(e.color.id),
                        n = e.quantity * r;
                    S.coll[o] || (S.coll[o] = {});
                    const s = S.coll[o][a] || 0;
                    "add" === t ? S.coll[o][a] = s + n : s - n > 0 ? S.coll[o][a] = s - n : (delete S.coll[o][a], 0 === Object.keys(S.coll[o]).length && delete S.coll[o]), "add" === t ? l += n : i += n
                })
            })), e + 3 < n.length && await new Promise(e => setTimeout(e, 1e3))
        }
        saveState(), forceSaveState(), await Promise.all([fetchMissingCollectionPartDetails(), ensureBasicPartImagesForCollection(), fetchColorDetailsForCollectionParts(), fetchMissingCollectionMinifigDetails()]);
        let r = "";
        "add" === t ? (r = "Детали набора успешно добавлены.", o > 0 && (r += ` ${o} минифигурок и их детали (${l} шт.) также добавлены.`)) : (r = "Детали набора успешно удалены.", a > 0 && (r += ` Также удалены ${a} минифигурок и их детали (${i} шт.).`)), S.setModal.status = r, S.setModal.statusType = "success", setTimeout(() => {
            S.selSetNum && S.setModal.status === r && (S.setModal.status = "", renderSetModal(!1))
        }, 3e3), S.gridStale = !0, updateUI()
    } catch (o) {
        console.error(`Bulk ${t} failed for set ${e}:`, o), S.setModal.status = `Ошибка: не удалось ${"add"===t?"добавить":"удалить"} детали.`, S.setModal.statusType = "error"
    } finally {
        S.setModal.bulkUpdate = !1, S.selSetNum && renderSetModal(!1)
    }
}
async function handleBulkAddMinifigParts(e) {
    const t = S.setModal.minifigs.find(t => t.set_num === e);
    if (!t || S.setModal.bulkUpdate) return;
    S.setModal.bulkUpdate = !0, S.setModal.status = `Добавление деталей из "${t.name}"...`, S.setModal.statusType = "info", renderSetModal(!1);
    try {
        let o = t.parts;
        o || (o = await fetchMinifigParts(e));
        t.parts = o;
        if (!o || 0 === o.length) throw new Error("Детали минифигурки не найдены.");
        const l = t.quantity;
        (o || []).forEach(e => {
            const t = e.part.part_num,
                o = String(e.color.id),
                a = e.quantity * l;
            S.coll[t] || (S.coll[t] = {}), S.coll[t][o] = (S.coll[t][o] || 0) + a
        }), saveState(), forceSaveState(), await Promise.all([fetchMissingCollectionPartDetails(), ensureBasicPartImagesForCollection(), fetchColorDetailsForCollectionParts()]);
        const a = `Детали из "${t.name}" (${o.length} видов) добавлены.`;
        S.setModal.status = a, S.setModal.statusType = "success", setTimeout(() => {
            S.selSetNum && S.setModal.status === a && (S.setModal.status = "", renderSetModal(!1))
        }, 3e3)
    } catch (o) {
        console.error("Error adding minifig parts:", o), S.setModal.status = "Ошибка при добавлении деталей.", S.setModal.statusType = "error"
    } finally {
        S.setModal.bulkUpdate = !1, S.selSetNum && renderSetModal(!1), "collection" === S.view && "parts" === S.subView ? (S.gridStale = !0, updateUI()) : renderSidebar()
    }
}
async function handleBulkAddMinifigPartsFromModal(e) {
    const t = MINIFIG_MAP[e];
    if (!t || S.minifigModal.bulkUpdate) return;
    S.minifigModal.bulkUpdate = !0, S.minifigModal.status = `Добавление деталей из "${t.name}"...`, S.minifigModal.statusType = "info", renderMinifigModal(!1);
    try {
        const o = S.minifigModal.inv || await fetchMinifigParts(e);
        S.minifigModal.inv = o;
        if (!o || 0 === o.length) throw new Error("Детали минифигурки не найдены.");
        (o || []).forEach(e => {
            const t = e.part.part_num,
                o = String(e.color.id),
                l = e.quantity;
            S.coll[t] || (S.coll[t] = {}), S.coll[t][o] = (S.coll[t][o] || 0) + l
        }), saveState(), forceSaveState(), await Promise.all([fetchMissingCollectionPartDetails(), ensureBasicPartImagesForCollection(), fetchColorDetailsForCollectionParts()]);
        const l = `Детали из "${t.name}" (${o.length} видов) добавлены.`;
        S.minifigModal.status = l, S.minifigModal.statusType = "success", setTimeout(() => {
            S.selFigNum && S.minifigModal.status === l && (S.minifigModal.status = "", renderMinifigModal(!1))
        }, 3e3)
    } catch (o) {
        console.error("Ошибка добавления деталей минифигурки:", o), S.minifigModal.status = "Ошибка при добавлении деталей.", S.minifigModal.statusType = "error"
    } finally {
        S.minifigModal.bulkUpdate = !1, S.selFigNum && renderMinifigModal(!1), "collection" === S.view && "parts" === S.subView ? (S.gridStale = !0, updateUI()) : renderSidebar()
    }
}

function triggerSearch(e = !1) {
    console.log('triggerSearch called with:', { e, S_q: S.q, S_subView: S.subView, S_view: S.view });
    
    if (!e) {
        if ("sets" === S.subView) {
            S.sortBy = S.q ? "relevance" : "year_desc";
            S.setFilters = {
                minYear: "",
                maxYear: "",
                minParts: "",
                maxParts: ""
            };
        } else if ("minifigs" === S.subView) {
            S.sortBy = S.q ? "relevance" : "name_asc";
        } else {
            S.sortBy = S.q ? "relevance" : "popularity";
            S.filters.colorIds = [];
            S.filters.inCollectionOnly = !1;
        }
    }
    S.gridStale = !0;
    if ("collection" === S.view) {
        S.selCollCatId = null;
        S.selCollThemeId = null;
        updateUI();
    } else if ("sets" === S.subView) {
        S.selThemeId = null;
        fetchSets();
    } else if ("minifigs" === S.subView) {
        fetchMinifigs();
    } else {
        S.selCatId = null;
        console.log('Calling searchRebrickableParts with:', S.q.trim());
        searchRebrickableParts(S.q.trim());
    }
}

function openImageViewer(e) {
    e && !e.includes("data:image/svg+xml") && (viewerImg.setAttribute("src", e), viewerEl.classList.remove("viewer-hidden"), document.body.classList.add("overflow-hidden"), requestAnimationFrame(() => {
        viewerEl.classList.add("visible")
    }))
}

function closeImageViewer() {
    viewerEl.classList.remove("visible"), viewerEl.addEventListener("transitionend", e => {
        e.target === viewerEl && (viewerEl.classList.add("viewer-hidden"), viewerImg.setAttribute("src", ""), !S.selPartId && !S.selSetNum && !S.selFigNum && !S.filterOpen && !S.settingsOpen && document.body.classList.remove("overflow-hidden"))
    }, {
        once: !0
    })
}

function closeModal() {
    const e = document.getElementById("modal-content");
    e && !partModalEl.classList.contains("modal-hidden") && (partModalEl.classList.remove("visible"), e.classList.add("modal-content-leave"), !S.selSetNum && !S.filterOpen && !S.settingsOpen && !S.selFigNum && viewerEl.classList.contains("viewer-hidden") && document.body.classList.remove("overflow-hidden"), e.addEventListener("animationend", () => {
        e.classList.contains("modal-content-leave") && (S.selPartId = null, S.partModal = {
            groupId: null,
            variants: [],
            selColorId: null,
            qty: 1,
            loadingColors: !1,
            loadingImg: !1,
            imgUrl: null
        }, partModalEl.classList.add("modal-hidden"), partModalEl.innerHTML = "")
    }, {
        once: !0
    }))
}

function closeSetModal() {
    const e = document.getElementById("set-modal-content");
    e && !setModalEl.classList.contains("modal-hidden") && (setModalEl.classList.remove("visible"), e.classList.add("modal-content-leave"), !S.selPartId && !S.filterOpen && !S.settingsOpen && !S.selFigNum && viewerEl.classList.contains("viewer-hidden") && document.body.classList.remove("overflow-hidden"), e.addEventListener("animationend", () => {
        e.classList.contains("modal-content-leave") && (S.selSetNum = null, S.setModal = {
            loading: !1,
            inv: [],
            invPage: 1,
            hasNextInv: !1,
            qty: 1,
            bulkUpdate: !1,
            status: "",
            statusType: "",
            view: "details",
            minifigs: [],
            loadingMinifigs: !1
        }, setModalEl.classList.add("modal-hidden"), setModalEl.innerHTML = "")
    }, {
        once: !0
    }))
}

function closeMinifigModal() {
    const e = document.getElementById("minifig-modal-content");
    e && !minifigModalEl.classList.contains("modal-hidden") && (minifigModalEl.classList.remove("visible"), e.classList.add("modal-content-leave"), !S.selPartId && !S.selSetNum && !S.filterOpen && !S.settingsOpen && viewerEl.classList.contains("viewer-hidden") && document.body.classList.remove("overflow-hidden"), e.addEventListener("animationend", () => {
        e.classList.contains("modal-content-leave") && (S.selFigNum = null, S.minifigModal = {
            loading: !1,
            qty: 1,
            view: 'details',
            inv: null,
            loadingInv: !1,
            invError: !1,
            bulkUpdate: !1,
            status: '',
            statusType: ''
        }, minifigModalEl.classList.add("modal-hidden"), minifigModalEl.innerHTML = "")
    }, {
        once: !0
    }))
}

function closeFilterModal() {
    const e = document.getElementById("filter-modal-content");
    e && !filterModalEl.classList.contains("modal-hidden") && (S.filterOpen = !1, filterModalEl.classList.remove("visible"), e.classList.add("modal-content-leave"), !S.selPartId && !S.selSetNum && !S.settingsOpen && !S.selFigNum && viewerEl.classList.contains("viewer-hidden") && document.body.classList.remove("overflow-hidden"), e.addEventListener("animationend", () => {
        e.classList.contains("modal-content-leave") && (filterModalEl.classList.add("modal-hidden"), filterModalEl.innerHTML = "")
    }, {
        once: !0
    }))
}

function closeSettingsModal() {
    const e = document.getElementById("settings-modal-content");
    e && !settingsModalEl.classList.contains("modal-hidden") && (S.settingsOpen = !1, settingsModalEl.classList.remove("visible"), e.classList.add("modal-content-leave"), !S.selPartId && !S.selSetNum && !S.filterOpen && !S.selFigNum && viewerEl.classList.contains("viewer-hidden") && document.body.classList.remove("overflow-hidden"), e.addEventListener("animationend", () => {
        e.classList.contains("modal-content-leave") && (settingsModalEl.classList.add("modal-hidden"), settingsModalEl.innerHTML = "", S.settingsModal.delConfirm = null, S.settingsModal.status = "")
    }, {
        once: !0
    }))
}

function openModalForPart(e, t, o) {
    const l = PART_MAP[e];
    if (l) {
        S.selPartId = e;
        S.partModal = {
            groupId: t,
            variants: o,
            selColorId: null,
            qty: 0,
            loadingColors: !1,
            loadingImg: !1,
            imgUrl: l.rebrickable_img_url || null
        };
        renderModal();
        
        // Ensure part has an image, fetch if missing
        fetchImagesForViewedItems().catch(console.error);
        
        if (l.availableColorIds) {
            if (l.availableColorIds.length > 0) {
                S.partModal.selColorId = sortColorIds(l.availableColorIds, l.id)[0];
                S.partModal.qty = S.coll[e]?.[S.partModal.selColorId] || 0;
                updateModalPartially({
                    controls: !0
                });
                fetchPartColorSpecifics(l.id, S.partModal.selColorId);
            }
        } else {
            fetchPartColors(l.id);
        }
    }
}

function openModalForSet(e) {
    if (SET_MAP[e]) {
        S.selSetNum = e;
        S.setModal = {
            loading: !1,
            inv: [],
            invPage: 1,
            hasNextInv: !1,
            qty: S.setColl[e]?.qty || 0,
            bulkUpdate: !1,
            status: "",
            statusType: "",
            view: "details",
            minifigs: [],
            loadingMinifigs: !1
        };
        renderSetModal(!0);
        
        // Ensure set has an image, fetch if missing
        fetchImagesForViewedItems().catch(console.error);
        
        fetchSetInventory(e);
        fetchSetMinifigs(e);
    }
}

function openModalForMinifig(e) {
    if (MINIFIG_MAP[e]) {
        S.selFigNum = e;
        S.minifigModal = {
            loading: !1,
            qty: S.minifigColl[e]?.qty || 0,
            view: 'details',
            inv: null,
            loadingInv: !1,
            invError: !1,
            bulkUpdate: !1,
            status: '',
            statusType: ''
        };
        renderMinifigModal(!0);
        
        // Ensure minifig has an image, fetch if missing
        fetchImagesForViewedItems().catch(console.error);
    }
}

function refreshWithNewFilters() {
    S.toDisplay = S.increment, S.gridStale = !0;
    if ("collection" === S.view) {
        updateUI();
    } else if ("sets" === S.subView) {
        if (S.q || S.selThemeId) {
            fetchSets();
        } else {
            updateUI();
        }
    } else if ("minifigs" === S.subView) {
        if (S.q || !S.minifigRes) {
            fetchMinifigs();
        } else {
            updateUI();
        }
    } else if (S.q) {
        searchRebrickableParts(S.q.trim());
    } else if (S.selCatId) {
        loadPartsForCategory(S.selCatId);
    } else {
        updateUI();
    }
}
document.addEventListener("click", async e => {
    if (!(e.target instanceof Element)) return;
    const t = e.target;
    const o = t.closest('[data-action="view-image-fullscreen"]');
    if (o?.dataset.imageUrl) return openImageViewer(o.dataset.imageUrl);
    if ("image-viewer-container" === t.id || t.closest("#image-viewer-close")) return closeImageViewer();
    const l = t.closest('[data-action="toggle-favorite-category"]');
    if (l?.dataset.categoryId) {
        e.stopPropagation();
        const t = parseInt(l.dataset.categoryId, 10);
        return S.favCatIds.has(t) ? S.favCatIds.delete(t) : S.favCatIds.add(t), saveState(), void renderSidebar()
    }
    const a = t.closest('[data-action="toggle-favorite-theme"]');
    if (a?.dataset.themeId) {
        e.stopPropagation();
        const t = parseInt(a.dataset.themeId, 10);
        return S.favThemeIds.has(t) ? S.favThemeIds.delete(t) : S.favThemeIds.add(t), saveState(), void renderSidebar()
    }
    if (t.closest("#scroll-to-top-btn")) return mainEl.scrollTo({
        top: 0,
        behavior: "smooth"
    });
    if (t.closest("#sidebar-toggle")) return S.sidebarOpen = !S.sidebarOpen, void updateUI();
    if (t.closest("#sidebar-close")) return S.sidebarOpen = !1, void updateUI();
    if ("sidebar-backdrop" === t.id) return S.sidebarOpen = !1, void updateUI();
    const i = t.closest("[data-view]");
    if (i?.dataset.view) {
        const e = i.dataset.view;
        if (S.view === e) return;
        return S.view = e, S.q = "", S.err = null, S.gridStale = !0, S.selCatId = null, S.selCollCatId = null, S.selThemeId = null, S.selCollThemeId = null, void("catalog" === S.view && "minifigs" === S.subView && !S.minifigRes ? fetchMinifigs() : (updateUI(), setupScrollListener()))
    }
    const n = t.closest("[data-sub-view]");
    if (n?.dataset.subView) {
        const e = n.dataset.subView;
        if (S.subView === e) return;
        S.subView = e;
        S.q = "";
        S.err = null;
        S.increment = "minifigs" === e ? 20 : 48;
        S.toDisplay = S.increment;
        S.gridStale = !0;
        S.filters = { colorIds: [], inCollectionOnly: !1 };
        S.setFilters = { minYear: "", maxYear: "", minParts: "", maxParts: "" };
        S.selCatId = null;
        S.selCollCatId = null;
        S.selThemeId = null;
        S.selCollThemeId = null;
        S.searchGroups = null;
        S.catGroups = null;
        S.setRes = null;
        S.searchSetRes = null;
        S.minifigRes = null;
        S.searchMinifigRes = null;
        
        if ("sets" === e) {
            S.sortBy = "year_desc";
        } else if ("minifigs" === e) {
            S.sortBy = "name_asc";
        } else {
            S.sortBy = "popularity";
        }
        
        if ("catalog" === S.view && "minifigs" === e && !S.minifigRes) {
            fetchMinifigs();
        } else if ("minifigs" === e && S.view === "collection" && Object.keys(S.minifigColl).length > 0) {
            fetchMissingCollectionMinifigDetails().then(() => { 
                S.gridStale = true; 
                updateUI(); 
            }).catch(console.error);
        } else {
            updateUI();
        }
        
        // Setup scroll listener for automatic image loading
        setupScrollListener();
        return;
    }
    if (t.closest('[data-action="show-all-collection-items"]')) return "parts" === S.subView && (S.selCollCatId = null), "sets" === S.subView && (S.selCollThemeId = null), S.gridStale = !0, void updateUI();
    const r = t.closest("[data-theme-id]");
    if (r?.dataset.themeId) {
        const e = parseInt(r.dataset.themeId, 10),
            t = THEME_MAP[e],
            o = t && Array.isArray(t.children) && t.children.length > 0;
        if (o) {
            S.expThemes.has(e) ? S.expThemes.delete(e) : S.expThemes.add(e)
        }
        if ("collection" === S.view) S.selCollThemeId !== e && (S.selCollThemeId = e, S.gridStale = !0, updateUI());
        else if (S.selThemeId !== e) {
            S.selThemeId = e, S.q = "", S.sortBy = "year_desc", S.setFilters = {
                minYear: "",
                maxYear: "",
                minParts: "",
                maxParts: ""
            };
            fetchSets()
        }
        return void(o && renderSidebar())
    }
    const s = t.closest("[data-parent-category]");
    if (s?.dataset.parentCategory) {
        const e = s.dataset.parentCategory,
            t = S.expCats.has(e);
        return t ? S.expCats.delete(e) : S.expCats.add(e), void renderSidebar()
    }
    const c = t.closest("[data-category-id]");
    if (c?.dataset.categoryId) {
        const e = parseInt(c.dataset.categoryId, 10);
        return S.q = "", "collection" === S.view ? S.selCollCatId !== e && (S.selCollCatId = e, S.gridStale = !0, updateUI()) : S.selCatId !== e && (S.selCatId = e, S.filters = {
            colorIds: [],
            inCollectionOnly: !1
        }, S.sortBy = "popularity", loadPartsForCategory(e)), void 0
    }
    if (t.closest("#feeling-lucky-button")) return handleFeelingLucky();
    const d = t.closest('[data-action="delete-from-collection"]');
    if (d?.dataset.partId && d.dataset.colorId) return await handleUpdateCollection(d.dataset.partId, d.dataset.colorId, 0);
    const u = t.closest(".minifig-card");
    if (u?.dataset.figNum) return openModalForMinifig(u.dataset.figNum);
    const g = t.closest(".set-card");
    if (g?.dataset.setNum) return openModalForSet(g.dataset.setNum);
    const m = t.closest(".part-card");
    if (m?.dataset.groupId && m.dataset.partId) {
        const e = m.dataset.partId,
            t = m.dataset.groupId,
            o = PART_MAP[e];
        if (!o) return;
        let l = [o];
        if ("catalog" === S.view) {
            const e = S.searchGroups || S.catGroups;
            l = e && e[t] ? e[t] : [o]
        } else {
            const e = Object.values(PART_MAP);
            (l = e.filter(p => p && getGroupId(p.part_num) === t).sort(partCmp));
            if (l.length === 0) {
                l = [o];
            }
        }
        openModalForPart(e, t, l);
        if ("collection" === S.view && m.dataset.colorId) {
            S.partModal.selColorId = m.dataset.colorId;
            S.partModal.qty = S.coll[e]?.[S.partModal.selColorId] || 0;
            updateModalPartially({
                controls: !0
            });
            fetchPartColorSpecifics(e, S.partModal.selColorId);
        }
        return;
    }
    if ("modal-container" === t.id || t.closest("#modal-close")) return closeModal();
    if ("set-modal-container" === t.id || t.closest("#set-modal-close")) return closeSetModal();
    if ("minifig-modal-container" === t.id || t.closest("#minifig-modal-close")) return closeMinifigModal();
    if ("filter-modal-container" === t.id || t.closest("#filter-modal-close")) return closeFilterModal();
    if ("settings-modal-container" === t.id || t.closest("#settings-modal-close")) return closeSettingsModal();
    if (t.closest("#search-button")) return triggerSearch();
    if (t.closest("#clear-search")) {
        S.q = "";
        document.getElementById("search-input")?.focus();
        return void triggerSearch()
    }
    if (t.closest("#filter-button")) {
        S.filterOpen = !0;
        // Ensure filters are properly initialized
        if (!S.filters) S.filters = { colorIds: [], inCollectionOnly: false };
        if (!S.setFilters) S.setFilters = { minYear: "", maxYear: "", minParts: "", maxParts: "" };
        if (!S.sortBy) S.sortBy = 'popularity';
        
        tempFilters = {
            filters: JSON.parse(JSON.stringify(S.filters)),
            setFilters: JSON.parse(JSON.stringify(S.setFilters)),
            sortBy: S.sortBy
        };
        return void renderFilterModal();
    }
    if (t.closest("#refresh-images-button")) {
        return void forceRefreshPartImages();
    }

    if (t.closest("#settings-button")) return S.settingsOpen = !0, void renderSettingsModal();
    const h = t.closest('[data-action="remove-filter"]');
    if (h) {
        const e = h.dataset.filterType;
        if ("color" === e) {
            S.filters.colorIds = S.filters.colorIds.filter(id => id !== h.dataset.colorId)
        }
        if ("inCollectionOnly" === e) {
            S.filters.inCollectionOnly = !1;
        }
        if ("sortBy" === e) {
            S.sortBy = S.q ? "relevance" : "popularity";
        }
        return void refreshWithNewFilters()
    }
    if (t.closest('[data-action="remove-all-filters"]')) {
        if ("sets" === S.subView) {
            S.setFilters = {
                minYear: "",
                maxYear: "",
                minParts: "",
                maxParts: ""
            };
            S.sortBy = S.q ? "relevance" : "year_desc";
        } else if ("minifigs" === S.subView) {
            S.sortBy = S.q ? "relevance" : "name_asc";
        } else {
            S.filters.colorIds = [];
            S.filters.inCollectionOnly = !1;
            S.sortBy = S.q ? "relevance" : "popularity";
        }
        return void refreshWithNewFilters();
    }
     if (settingsModalEl?.contains(t)) {
        const e = t.closest("[data-action]");
        if (!e) return;
        switch (e.dataset.action) {
            case "disable-color-images":
                const checkbox = document.getElementById('disable-color-images');
                if (checkbox) {
                    localStorage.setItem('disableColorSpecificImages', checkbox.checked.toString());
                    if (checkbox.checked) {
                        S.settingsModal.status = "Загрузка изображений для каждого цвета отключена. Коллекция будет загружаться быстрее.", S.settingsModal.statusType = "success";
                    } else {
                        S.settingsModal.status = "Загрузка изображений для каждого цвета включена.", S.settingsModal.statusType = "success";
                    }
                    renderSettingsModal();
                }
                break;
            case "delete-all-parts":
                S.settingsModal.delConfirm = "parts", renderSettingsModal();
                break;
            case "delete-all-sets":
                S.settingsModal.delConfirm = "sets", renderSettingsModal();
                break;
            case "delete-all-minifigs":
                S.settingsModal.delConfirm = "minifigs", renderSettingsModal();
                break;
            case "delete-all-data":
                S.settingsModal.delConfirm = "all", renderSettingsModal();
                break;
            case "cancel-delete":
                S.settingsModal.delConfirm = null, renderSettingsModal();
                break;
            case "confirm-delete-parts":
                S.coll = {}, saveState(), S.settingsModal.delConfirm = null, renderSettingsModal(), updateUI();
                break;
            case "confirm-delete-sets":
                S.setColl = {}, saveState(), S.settingsModal.delConfirm = null, renderSettingsModal(), updateUI();
                break;
            case "confirm-delete-minifigs":
                S.minifigColl = {}, saveState(), S.settingsModal.delConfirm = null, renderSettingsModal(), updateUI();
                break;
            case "confirm-delete-all":
                S.coll = {}, S.setColl = {}, S.minifigColl = {}, saveState(), S.settingsModal.delConfirm = null, renderSettingsModal(), updateUI();
                break;
            case "refresh-minifig-data":
                updateSettingsModalStatus("Обновление данных минифигурок...", "info");
                try {
                    await refreshMinifigData();
                    updateSettingsModalStatus("Данные минифигурок обновлены успешно!", "success");
                } catch (error) {
                    updateSettingsModalStatus(`Ошибка обновления: ${error.message}`, "error");
                }
                break;
            case "reload-csv-data":
                updateSettingsModalStatus("Перезагрузка данных из CSV...", "info");
                try {
                    await loadDataFromCSV();
                    updateSettingsModalStatus("Данные из CSV перезагружены успешно!", "success");
                } catch (error) {
                    updateSettingsModalStatus(`Ошибка перезагрузки CSV: ${error.message}`, "error");
                }
                break;
            case "load-missing-api-data":
                updateSettingsModalStatus("Загрузка недостающих данных из API...", "info");
                try {
                    await loadMissingDataFromAPI();
                    updateSettingsModalStatus("Недостающие данные загружены успешно!", "success");
                } catch (error) {
                    updateSettingsModalStatus(`Ошибка загрузки API данных: ${error.message}`, "error");
                }
                break;
            case "force-reload-csv":
                updateSettingsModalStatus("Принудительная перезагрузка CSV данных...", "info");
                try {
                    // Clear all data maps first
                    Object.keys(PART_MAP).forEach(key => delete PART_MAP[key]);
                    Object.keys(SET_MAP).forEach(key => delete SET_MAP[key]);
                    Object.keys(MINIFIG_MAP).forEach(key => delete MINIFIG_MAP[key]);
                    Object.keys(COLOR_MAP).forEach(key => delete COLOR_MAP[key]);
                    flatCategories.length = 0;
                    Object.keys(THEME_MAP).forEach(key => delete THEME_MAP[key]);
                    
                    // Reload from CSV
                    await loadDataFromCSV();
                    updateSettingsModalStatus("CSV данные принудительно перезагружены!", "success");
                } catch (error) {
                    updateSettingsModalStatus(`Ошибка принудительной перезагрузки: ${error.message}`, "error");
                }
                break;
            case "clear-app-cache":
                updateSettingsModalStatus("Очистка кэша приложения...", "info");
                try {
                    const success = await window.clearAppCache();
                    if (success) {
                        updateSettingsModalStatus("Кэш приложения очищен успешно!", "success");
                    } else {
                        updateSettingsModalStatus("Ошибка очистки кэша", "error");
                    }
                } catch (error) {
                    updateSettingsModalStatus(`Ошибка очистки кэша: ${error.message}`, "error");
                }
                break;
            case "get-cache-info":
                try {
                    const cacheInfo = await window.getCacheInfo();
                    const cacheInfoEl = document.getElementById('cache-info');
                    if (cacheInfoEl) {
                        const infoText = Object.entries(cacheInfo)
                            .map(([cacheName, count]) => `${cacheName}: ${count} файлов`)
                            .join(', ') || 'Кэш пуст';
                        
                        cacheInfoEl.textContent = infoText;
                        cacheInfoEl.classList.remove('hidden');
                        
                        // Hide after 5 seconds
                        setTimeout(() => {
                            cacheInfoEl.classList.add('hidden');
                        }, 5000);
                    }
                } catch (error) {
                    console.error('Failed to get cache info:', error);
                }
                break;

            case "import-csv":
                document.getElementById("import-csv-input")?.click();
                break;
            case "export-csv":
                exportCollectionToCSV();
                break;
        }
    } else if (minifigModalEl?.contains(t)) {
        const e = t.closest("[data-action]");
        if (!e) return;
        switch (e.dataset.action) {
            case "decrease-minifig-qty":
                S.minifigModal.qty > 0 && (S.minifigModal.qty--, renderMinifigModal(!1));
                break;
            case "increase-minifig-qty":
                S.minifigModal.qty++, renderMinifigModal(!1);
                break;
            case "update-minifig-collection":
                S.selFigNum && await handleUpdateMinifigCollection(S.selFigNum, S.minifigModal.qty);
                break;
            case "delete-from-minifig-collection-modal":
                if (S.selFigNum) {
                    await handleUpdateMinifigCollection(S.selFigNum, 0);
                    S.minifigModal.qty = 0;
                }
                break;
            case "toggle-minifig-modal-view":
                S.minifigModal.view = "details" === S.minifigModal.view ? "inventory" : "details";
                if ("inventory" === S.minifigModal.view && !S.minifigModal.inv) {
                    S.minifigModal.loadingInv = !0, S.minifigModal.invError = !1, updateMinifigModalView();
                    try {
                        S.minifigModal.inv = await fetchMinifigParts(S.selFigNum)
                    } catch (t) {
                        S.minifigModal.invError = !0
                    } finally {
                        S.minifigModal.loadingInv = !1, updateMinifigModalView()
                    }
                } else updateMinifigModalView();
                break;
            case "add-minifig-parts-modal":
                S.selFigNum && handleBulkAddMinifigPartsFromModal(S.selFigNum);
                break;
            case "retry-load-minifig-inv":
                S.minifigModal.inv = null;
                const o = minifigModalEl.querySelector('[data-action="toggle-minifig-modal-view"]');
                o?.click();
                break
            case "refresh-minifig-image":
                if (S.selFigNum) {
                    try {
                        await fetchMinifigDetails(S.selFigNum);
                        renderMinifigModal(false);
                    } catch (error) {
                        console.error('Failed to refresh minifig image:', error);
                    }
                }
                break
        }
    } else if (setModalEl?.contains(t)) {
        const e = t.closest("[data-action]");
        if (!e) return;
        const {
            action: o,
            themeId: l,
            figNum: a,
            quantity: i
        } = e.dataset;
        switch (o) {
            case "toggle-set-modal-view":
                S.setModal.view = "details" === S.setModal.view ? "inventory" : "details", renderSetModal(!1);
                break;
            case "load-more-inventory":
                S.selSetNum && fetchSetInventory(S.selSetNum, S.setModal.invPage + 1);
                break;
            case "decrease-set-qty":
                S.setModal.qty > 0 && (S.setModal.qty--, updateSetModalControlsState());
                break;
            case "increase-set-qty":
                S.setModal.qty++, updateSetModalControlsState();
                break;
            case "update-set-collection":
                S.selSetNum && handleUpdateSetCollection(S.selSetNum, S.setModal.qty);
                break;
            case "delete-from-set-collection-modal":
                S.selSetNum && (handleUpdateSetCollection(S.selSetNum, 0), S.setModal.qty = 0);
                break;
            case "go-to-theme":
                l && (closeSetModal(), S.view = "catalog", S.subView = "sets", S.selThemeId = parseInt(l, 10), fetchSets());
                break;
            case "bulk-add-parts":
                S.selSetNum && handleBulkUpdatePartsFromSet(S.selSetNum, "add");
                break;
            case "bulk-remove-parts":
                S.selSetNum && handleBulkUpdatePartsFromSet(S.selSetNum, "remove");
                break;
            case "toggle-minifig-parts":
                if (a) {
                    const e = S.setModal.minifigs.find(e => e.set_num === a);
                    if (e) {
                        e.isExpanded = !e.isExpanded;
                        if (e.isExpanded && !e.parts && !e.loadingError) {
                            e.isLoadingParts = !0, renderSetModal(!1), fetchMinifigParts(a).then(t => {
                                e.parts = t
                            }).catch(() => {
                                e.loadingError = !0
                            }).finally(() => {
                                e.isLoadingParts = !1, S.selSetNum && renderSetModal(!1)
                            })
                        } else e.isExpanded || (e.loadingError = !1), renderSetModal(!1)
                    }
                }
                break;
            case "retry-load-minifig-parts":
                if (a) {
                    const e = S.setModal.minifigs.find(e => e.set_num === a);
                    e && (e.loadingError = !1, e.isLoadingParts = !0, e.parts = null, renderSetModal(!1), fetchMinifigParts(a).then(t => {
                        e.parts = t
                    }).catch(() => {
                        e.loadingError = !0
                    }).finally(() => {
                        e.isLoadingParts = !1, S.selSetNum && renderSetModal(!1)
                    }))
                }
                break;
            case "add-minifig-to-collection":
                a && i && await handleUpdateMinifigCollection(a, (S.minifigColl[a]?.qty || 0) + parseInt(i, 10), !1);
                break;
            case "add-minifig-parts-to-collection":
                a && handleBulkAddMinifigParts(a)
        }
    } else if (filterModalEl?.contains(t)) {
        const e = t.closest("[data-action]");
        if (!e) return;
        const {
            action: o,
            colorId: l,
            filterKey: filterKey
        } = e.dataset;
        switch (o) {
            case "modal-set-color":
                if ("null" === l) {
                    tempFilters.filters.colorIds = [];
                } else if (l) {
                    if (tempFilters.filters.colorIds.includes(l)) {
                        tempFilters.filters.colorIds.splice(tempFilters.filters.colorIds.indexOf(l), 1);
                    } else {
                        tempFilters.filters.colorIds.push(l);
                    }
                }
                updateFilterModalUI();
                break;
            case "modal-set-filter":
                if (filterKey && e.value !== undefined) {
                    tempFilters.setFilters[filterKey] = e.value;
                }
                break;
            case "modal-toggle-collection":
                tempFilters.filters.inCollectionOnly = e.checked;
                break;
            case "modal-set-sort":
                tempFilters.sortBy = e.value;
                break;
            case "modal-reset-filters":
                if ("sets" === S.subView) {
                    tempFilters.sortBy = S.q ? "relevance" : "year_desc";
                    tempFilters.setFilters = {
                        minYear: "",
                        maxYear: "",
                        minParts: "",
                        maxParts: ""
                    };
                } else if ("minifigs" === S.subView) {
                    tempFilters.sortBy = S.q ? "relevance" : "name_asc";
                } else {
                    tempFilters.sortBy = S.q ? "relevance" : "popularity";
                    tempFilters.filters = {
                        colorIds: [],
                        inCollectionOnly: !1
                    };
                }
                renderFilterModal();
                break;
            case "modal-apply-filters":
                S.filters = tempFilters.filters;
                S.setFilters = tempFilters.setFilters;
                S.sortBy = tempFilters.sortBy;
                closeFilterModal();
                refreshWithNewFilters();
                break;
        }
    } else if (partModalEl?.contains(t)) {
        // Handle custom variation selector button click
        if (t.id === "variation-select-button") {
            // Toggle dropdown
            const dropdown = document.getElementById("variation-dropdown");
            const isOpen = dropdown.style.display !== 'none';
            
            if (!isOpen) {
                dropdown.style.display = 'block';
                t.classList.add('open');
            } else {
                dropdown.style.display = 'none';
                t.classList.remove('open');
            }
            return;
        }
        
        // Handle variation option selection
        if (t.classList.contains("variation-option")) {
            const selectedVariationId = t.dataset.value;
            const selectedVariation = S.partModal.variants?.find(v => v.id === selectedVariationId);
            
            if (selectedVariation && selectedVariation.id !== S.selPartId) {
                // Update selected part ID to the new variation
                S.selPartId = selectedVariationId;
                
                // Update button text
                const buttonText = document.getElementById("variation-select-text");
                if (buttonText) {
                    buttonText.textContent = selectedVariation.name;
                }
                
                // Update option styling
                const dropdown = document.getElementById("variation-dropdown");
                if (dropdown) {
                    dropdown.querySelectorAll('.variation-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    t.classList.add('selected');
                }
                
                // Close dropdown
                const button = document.getElementById("variation-select-button");
                if (button) {
                    button.classList.remove('open');
                }
                if (dropdown) {
                    dropdown.style.display = 'none';
                }
                
                // Update part modal data for the new variation
                const newPart = PART_MAP[selectedVariationId];
                if (newPart) {
                    S.partModal.imgUrl = newPart.rebrickable_img_url || null;
                    S.partModal.selColorId = null;
                    S.partModal.qty = 0;
                    
                    // Update image
                    updateModalPartially({
                        image: true
                    });
                    
                    // Update modal title to show selected variation name
                    const modalTitle = document.querySelector('#modal-content h2');
                    if (modalTitle) {
                        modalTitle.textContent = selectedVariation.name;
                    }
                    
                    // Fetch colors for the new variation
                    if (newPart.availableColorIds && newPart.availableColorIds.length > 0) {
                        S.partModal.selColorId = sortColorIds(newPart.availableColorIds, newPart.id)[0];
                        S.partModal.qty = S.coll[selectedVariationId]?.[S.partModal.selColorId] || 0;
                        updateModalPartially({
                            colors: true,
                            controls: true
                        });
                        fetchPartColorSpecifics(newPart.id, S.partModal.selColorId);
                    } else {
                        fetchPartColors(newPart.id);
                    }
                }
            }
            return;
        }
        
        const e = t.closest("[data-action]");
        if (e) {
            const {
                action: t,
                categoryId: o
            } = e.dataset;
            switch (t) {
                case "decrease-qty":
                    S.partModal.qty > 0 && (S.partModal.qty--, updateModalControlsState());
                    break;
                case "increase-qty":
                    S.partModal.qty++, updateModalControlsState();
                    break;
                case "update-collection":
                    S.selPartId && S.partModal.selColorId && await handleUpdateCollection(S.selPartId, S.partModal.selColorId, S.partModal.qty);
                    break;
                case "delete-from-collection-modal":
                    S.selPartId && S.partModal.selColorId && (await handleUpdateCollection(S.selPartId, S.partModal.selColorId, 0), S.partModal.qty = 0);
                    break;
                case "go-to-category":
                    o && (closeModal(), S.view = "catalog", S.subView = "parts", S.selCatId = parseInt(o, 10), loadPartsForCategory(S.selCatId));
                    break;
                case "retry-fetch-colors":
                    S.selPartId && fetchPartColors(S.selPartId)
            }
        }
        const o = t.closest("button[data-color-id]");
        if (o && o.dataset.colorId) {
            S.partModal.selColorId = o.dataset.colorId;
            S.partModal.qty = S.coll[S.selPartId]?.[S.partModal.selColorId] || 0;
            
            // Update controls first
            updateModalPartially({
                controls: !0
            });
            
            // Update colors without full re-render to prevent jumping
            const colorContainer = document.getElementById("color-selector-container");
            if (colorContainer) {
                // Only update the selected color button styling
                const allColorButtons = colorContainer.querySelectorAll('button[data-color-id]');
                allColorButtons.forEach(btn => {
                    btn.classList.remove('border-blue-500', 'scale-110');
                    btn.classList.add('border-gray-600');
                });
                
                // Highlight selected color
                const selectedButton = colorContainer.querySelector(`button[data-color-id="${S.partModal.selColorId}"]`);
                if (selectedButton) {
                    selectedButton.classList.remove('border-gray-600');
                    selectedButton.classList.add('border-blue-500', 'scale-110');
                }
            }
            
            fetchPartColorSpecifics(S.selPartId, S.partModal.selColorId);
        }
    }
}), document.addEventListener("keydown", e => {
    const activeElement = document.activeElement;
    "Escape" === e.key ? viewerEl.classList.contains("viewer-hidden") ? S.filterOpen ? closeFilterModal() : S.settingsOpen ? closeSettingsModal() : S.selSetNum ? closeSetModal() : S.selFigNum ? closeMinifigModal() : S.selPartId && closeModal() : closeImageViewer() : "Enter" === e.key && activeElement.id === "search-input" && triggerSearch()
}), mainEl.addEventListener("scroll", () => {
    const threshold = 300;
    const isAtBottom = mainEl.scrollHeight - mainEl.scrollTop <= mainEl.clientHeight + threshold;

    if (isAtBottom && !S.loading && S.hasMoreItems) {
        S.toDisplay += S.increment;
        renderMainContent();
    }
    
    const e = mainEl.scrollTop > 300;
    e && toTopBtn.classList.contains("opacity-0") ? toTopBtn.classList.remove("opacity-0", "pointer-events-none", "translate-y-4") : !e && !toTopBtn.classList.contains("opacity-0") && toTopBtn.classList.add("opacity-0", "pointer-events-none", "translate-y-4")
});
async function initializeApp() {
    loadState();
    
    S.sidebarLoading = true;
    updateUI();

    try {
        // Always load data from CSV files first (fast, offline)
        await loadDataFromCSV();
        
        // Check for new data from API in background (without overloading)
        checkForNewDataInBackground();
        
    } catch (e) {
        console.error("Data loading failed:", e);
        S.err = S.err || `Не удалось загрузить данные каталога: ${e.message}`;
    } finally {
        S.sidebarLoading = false;
        updateUI();
    }

    // Load collection data if user has any
    (async () => {
        try {
            if (Object.keys(S.coll).length > 0) {
                await fetchMissingCollectionPartDetails();
                await ensureBasicPartImagesForCollection();
                // Don't load color-specific images automatically to avoid delays
                // User can use refresh button if needed
            }
            
            if (Object.keys(S.setColl).length > 0) {
                await fetchMissingCollectionSetDetails();
            }
            
            if (Object.keys(S.minifigColl).length > 0) {
                await fetchMissingCollectionMinifigDetails();
            }
            
            // Save state after background loading
            saveState();
            
            // Update UI if needed
            if (S.view === 'collection') {
                S.gridStale = true;
                updateUI();
            }
            
            // Setup scroll listener for automatic image loading
            setupScrollListener();
        } catch (e) {
            console.error("Background collection data fetch failed:", e);
        }
    })();
}
document.addEventListener("DOMContentLoaded", () => {
    viewerCloseBtn.innerHTML = I_X("w-6 h-6");
    // Add event listener for importing CSV file
    const csvImportInput = document.getElementById('import-csv-input');
    if (csvImportInput) {
        csvImportInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                try {
                    const content = await file.text();
                    await processCsvData(content);
                    // Clear input after successful import
                    event.target.value = '';
                    // Update UI
                    S.gridStale = true;
                    updateUI();
                } catch (error) {
                    console.error('CSV import failed:', error);
                    // Clear input in case of error
                    event.target.value = '';
                }
            }
        });
    }
    
    initializeApp();

    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            if (!window.isSecureContext && location.hostname !== 'localhost') {
                console.warn('Service Worker требует безопасный контекст (https или localhost). Сейчас: ', location.protocol);
            }
            
            // Check for service worker updates
            navigator.serviceWorker.register('./service-worker.js', { scope: './' })
                .then(registration => {
                    console.log('ServiceWorker registration successful with scope:', registration.scope);
                    
                    // Check for updates
                    registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing;
                        console.log('Service Worker update found');
                        
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                // New service worker is ready, prompt user to update
                                console.log('New service worker ready, prompting update');
                                if (confirm('Доступно обновление приложения. Обновить сейчас?')) {
                                    newWorker.postMessage({ type: 'SKIP_WAITING' });
                                    window.location.reload();
                                }
                            }
                        });
                    });
                    
                    return navigator.serviceWorker.ready;
                })
                .then(() => {
                    console.log('ServiceWorker is active and ready.');
                    
                    // Listen for messages from service worker
                    navigator.serviceWorker.addEventListener('message', event => {
                        if (event.data && event.data.type === 'RELOAD_PAGE') {
                            window.location.reload();
                        }
                    });
                    
                    // Add cache management functions
                    window.clearAppCache = async () => {
                        try {
                            const cacheNames = await caches.keys();
                            await Promise.all(
                                cacheNames.map(cacheName => {
                                    if (cacheName.startsWith('lego-catalog-cache')) {
                                        console.log('Deleting cache:', cacheName);
                                        return caches.delete(cacheName);
                                    }
                                })
                            );
                            console.log('App cache cleared successfully');
                            return true;
                        } catch (error) {
                            console.error('Failed to clear cache:', error);
                            return false;
                        }
                    };
                    
                    window.getCacheInfo = async () => {
                        try {
                            const cacheNames = await caches.keys();
                            const cacheInfo = {};
                            
                            for (const cacheName of cacheNames) {
                                if (cacheName.startsWith('lego-catalog-cache')) {
                                    const cache = await caches.open(cacheName);
                                    const keys = await cache.keys();
                                    cacheInfo[cacheName] = keys.length;
                                }
                            }
                            
                            return cacheInfo;
                        } catch (error) {
                            console.error('Failed to get cache info:', error);
                            return {};
                        }
                    };
                })
                .catch(error => {
                    console.log('ServiceWorker registration failed:', error);
                });
        });
    }
});

// Function to load data from CSV files
async function loadDataFromCSV() {
    try {
        
        // Update loading status
        updateSettingsModalStatus("Загрузка данных из CSV...", "info");
        
        // Load categories FIRST (most important for navigation)
        updateSettingsModalStatus("Загрузка категорий...", "info");
        await loadCategoriesFromCSV();
        
        // Load themes (for sets navigation)
        updateSettingsModalStatus("Загрузка тем...", "info");
        await loadThemesFromCSV();
        
        // Load colors (needed for parts display)
        updateSettingsModalStatus("Загрузка цветов...", "info");
        await loadColorsFromCSV();
        
        // Load parts (main catalog data)
        updateSettingsModalStatus("Загрузка деталей...", "info");
        await loadPartsFromCSV();
        
        // Load sets (main catalog data)
        updateSettingsModalStatus("Загрузка наборов...", "info");
        await loadSetsFromCSV();
        
        // Load minifigs (main catalog data)
        updateSettingsModalStatus("Загрузка минифигурок...", "info");
        await loadMinifigsFromCSV();
        
        // Load elements (part-color combinations)
        updateSettingsModalStatus("Загрузка элементов...", "info");
        await loadElementsFromCSV();
        
        // Load inventories and their contents
        updateSettingsModalStatus("Загрузка инвентарей...", "info");
        await loadInventoriesFromCSV();
        
        const stats = getLoadingStats();
        
        // Update loading status
        updateSettingsModalStatus("Данные из CSV загружены успешно!", "success");
        
        // Save state after CSV loading
        saveState();
        
        // Update UI
        S.gridStale = true;
        updateUI();
        
    } catch (error) {
        console.error('Failed to load CSV data:', error);
        S.err = `Ошибка загрузки CSV данных: ${error.message}`;
        
        // Fallback to API loading if CSV fails
        try {
            await Promise.all([fetchAllColors(), fetchCategories(), fetchThemes()]);
        } catch (apiError) {
            console.error('Fallback API loading also failed:', apiError);
            S.err = `${S.err}\nТакже не удалось загрузить данные из API: ${apiError.message}`;
        }
    }
}

// Function to load colors from CSV
async function loadColorsFromCSV() {
    try {
        const response = await fetch('./Data/colors.csv');
        const csvText = await response.text();
        const lines = csvText.split('\n').slice(1); // Skip header
        
        lines.forEach(line => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                const [id, name, rgb, is_trans] = fields;
                if (id && name) {
                    COLOR_MAP[id] = {
                        id: id,
                        name: name,
                        hex: `#${rgb || '000000'}`,
                        isTransparent: is_trans === 'True',
                        rgb: rgb || '000000',
                        is_trans: is_trans === 'True'
                    };
                }
            }
        });
        

    } catch (error) {
        console.error('Failed to load colors from CSV:', error);
        throw error;
    }
}

// Function to load categories from CSV
async function loadCategoriesFromCSV() {
    try {
        const response = await fetch('./Data/part_categories.csv');
        const csvText = await response.text();
        const lines = csvText.split('\n').slice(1); // Skip header
        
        lines.forEach(line => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                const [id, name] = fields;
                if (id && name) {
                    flatCategories.push({
                        id: parseInt(id),
                        name: name,
                        parent_id: null
                    });
                }
            }
        });
        
        // Build category tree
        S.catTree = buildCategoryTree(flatCategories);
        

    } catch (error) {
        console.error('Failed to load categories from CSV:', error);
        throw error;
    }
}

// Function to load themes from CSV
async function loadThemesFromCSV() {
    try {
        const response = await fetch('./Data/themes.csv');
        const csvText = await response.text();
        const lines = csvText.split('\n').slice(1); // Skip header
        
        const themeMap = {};
        
        lines.forEach(line => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                const [id, name, parent_id] = fields;
                if (id && name) {
                    const theme = {
                        id: parseInt(id),
                        name: name,
                        parent_id: parent_id ? parseInt(parent_id) : null,
                        children: []
                    };
                    themeMap[id] = theme;
                    THEME_MAP[id] = theme;
                }
            }
        });
        
        // Build theme tree
        const rootThemes = [];
        Object.values(themeMap).forEach(theme => {
            if (theme.parent_id && themeMap[theme.parent_id]) {
                themeMap[theme.parent_id].children.push(theme);
            } else {
                rootThemes.push(theme);
            }
        });
        
        S.themeTree = rootThemes;
        

    } catch (error) {
        console.error('Failed to load themes from CSV:', error);
        throw error;
    }
}

// Function to load parts from CSV
async function loadPartsFromCSV() {
    try {
        const response = await fetch('./Data/parts.csv');
        const csvText = await response.text();
        const lines = csvText.split('\n').slice(1); // Skip header
        
        lines.forEach(line => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                const [part_num, name, part_cat_id] = fields;
                if (part_num && name) {
                    // Don't set image URL here - it will come from inventory_parts.csv
                    PART_MAP[part_num] = {
                        id: part_num,
                        name: name,
                        part_num: part_num,
                        part_cat_id: part_cat_id ? parseInt(part_cat_id) : null,
                        categoryId: part_cat_id ? parseInt(part_cat_id) : null,
                        num_sets: 0, // Will be updated from API if needed
                        part_img_url: null, // Will be set from inventory_parts.csv
                        rebrickable_img_url: null
                    };
                }
            }
        });
        

    } catch (error) {
        console.error('Failed to load parts from CSV:', error);
        throw error;
    }
}

// Function to load sets from CSV
async function loadSetsFromCSV() {
    try {
        const response = await fetch('./Data/sets.csv');
        const csvText = await response.text();
        const lines = csvText.split('\n').slice(1); // Skip header
        
        lines.forEach(line => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                const [set_num, name, year, theme_id, num_parts, img_url] = fields;
                if (set_num && name) {
                    // Use image URL from CSV if available, otherwise generate one
                    let setImgUrl = img_url || `https://cdn.rebrickable.com/media/sets/${set_num}.jpg`;
                    
                    // Validate the image URL
                    if (setImgUrl && (!setImgUrl.startsWith('http') || setImgUrl.includes('localhost'))) {
                        console.warn('Invalid image URL detected for set', set_num, ':', setImgUrl);
                        setImgUrl = `https://cdn.rebrickable.com/media/sets/${set_num}.jpg`;
                    }
                    
                    SET_MAP[set_num] = {
                        set_num: set_num,
                        name: name,
                        year: year ? parseInt(year) : null,
                        theme_id: theme_id ? parseInt(theme_id) : null,
                        num_parts: num_parts ? parseInt(num_parts) : null,
                        set_img_url: setImgUrl
                    };
                }
            }
        });
        

    } catch (error) {
        console.error('Failed to load sets from CSV:', error);
        throw error;
    }
}

// Function to load minifigs from CSV
// FIXED: Now properly reads img_url field from CSV and uses correct fallback URL
async function loadMinifigsFromCSV() {
    try {
        const response = await fetch('./Data/minifigs.csv');
        const csvText = await response.text();
        const lines = csvText.split('\n').slice(1); // Skip header
        
        lines.forEach(line => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                const [fig_num, name, num_parts, img_url] = fields;
                if (fig_num && name) {
                    // Use image URL from CSV if available, otherwise generate one
                    let minifigImgUrl = img_url || `https://cdn.rebrickable.com/media/minifigs/${fig_num}.jpg`;
                    
                    // Validate the image URL
                    if (minifigImgUrl && (!minifigImgUrl.startsWith('http') || minifigImgUrl.includes('localhost'))) {
                        console.warn('Invalid image URL detected for minifig', fig_num, ':', minifigImgUrl);
                        minifigImgUrl = `https://cdn.rebrickable.com/media/minifigs/${fig_num}.jpg`;
                    }
                    
                    MINIFIG_MAP[fig_num] = {
                        set_num: fig_num, // Using set_num for consistency
                        name: name,
                        num_parts: num_parts ? parseInt(num_parts) : null,
                        minifig_img_url: minifigImgUrl
                    };
                }
            }
        });
        

        
        // Fetch missing image URLs from API for minifigs without images
        await fetchMissingMinifigImages();
    } catch (error) {
        console.error('Failed to load minifigs from CSV:', error);
        throw error;
    }
}

// Function to fetch missing minifig image URLs from API
async function fetchMissingMinifigImages() {
    const minifigsWithoutImages = Object.values(MINIFIG_MAP).filter(m => !m.minifig_img_url);
    
    if (minifigsWithoutImages.length === 0) {
        return;
    }
    
    for (const minifig of minifigsWithoutImages.slice(0, 10)) { // Limit to 10 to avoid rate limiting
        if (!minifig || !minifig.set_num) {
            continue;
        }
        
        try {
            const response = await fetch(`${REBRICKABLE_API_URL}/minifigs/${minifig.set_num}/?key=${getApiKey()}`);
            if (response.ok) {
                const data = await response.json();
                if (data.results && data.results[0] && data.results[0].set_img_url) {
                    minifig.minifig_img_url = data.results[0].set_img_url;
                }
            }
            // Add delay to avoid rate limiting
            await new Promise(resolve => setTimeout(resolve, 100));
        } catch (error) {
            // Ignore individual minifig fetch errors
        }
    }
}

// Function to load elements from CSV
async function loadElementsFromCSV() {
    try {
        const response = await fetch('./Data/elements.csv');
        const csvText = await response.text();
        const lines = csvText.split('\n').slice(1); // Skip header
        
        lines.forEach(line => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                const [element_id, part_num, color_id] = fields;
                if (element_id && part_num && color_id) {
                    // Store element info for later use
                    if (!PART_MAP[part_num]) {
                        PART_MAP[part_num] = { id: part_num, name: 'Unknown Part' };
                    }
                    if (!COLOR_MAP[color_id]) {
                        COLOR_MAP[color_id] = { id: color_id, name: 'Unknown Color', hex: '#000000' };
                    }
                }
            }
        });
        

    } catch (error) {
        console.error('Failed to load elements from CSV:', error);
        // Don't throw error for elements as it's not critical
    }
}

// Function to load inventories from CSV
async function loadInventoriesFromCSV() {
    try {
        // Load inventory_parts from multiple split files
        const inventoryPartsLines = [];
        
        // Try to load all 7 parts (based on the split results)
        const maxParts = 7;
        let loadedParts = 0;
        
        for (let partNum = 1; partNum <= maxParts; partNum++) {
            const partFileName = `./Data/inventory_parts_split/inventory_parts_part_${partNum.toString().padStart(3, '0')}.csv`;
            try {
                const response = await fetch(partFileName);
                if (!response.ok) {
                    break;
                }
                const csvText = await response.text();
                
                const lines = csvText.split('\n');
                
                // Skip header for all parts except the first one
                const linesToAdd = partNum === 1 ? lines.slice(1) : lines.slice(1);
                
                // Use for loop to avoid stack overflow with large arrays
                for (let i = 0; i < linesToAdd.length; i++) {
                    inventoryPartsLines.push(linesToAdd[i]);
                }
                loadedParts++;
                
                // Update loading status
                if (S.settingsOpen) {
                    S.settingsModal.status = `Загрузка инвентарей (часть ${partNum}/${maxParts})...`;
                    renderSettingsModal();
                }
            } catch (error) {
                console.error(`Failed to load part ${partNum}:`, error);
                break;
            }
        }
        

        
        const lines = inventoryPartsLines;
        
        // Create inventory maps for quick lookup
        const inventoryPartsMap = {};
        const inventorySetsMap = {};
        const inventoryMinifigsMap = {};
        
        // Process inventory parts lines and update PART_MAP with image information
        let partsWithImagesCount = 0;
        let partsWithColorImagesCount = 0;
        
        let processedLines = 0;
        let skippedLines = 0;
        
        lines.forEach((line, lineIndex) => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                processedLines++;
                
                const [inventory_id, part_num, color_id, quantity, is_spare, img_url] = fields;
                if (inventory_id && part_num && color_id && quantity && is_spare !== 't') {
                    if (!inventoryPartsMap[inventory_id]) {
                        inventoryPartsMap[inventory_id] = [];
                    }
                    inventoryPartsMap[inventory_id].push({
                        part_num,
                        color_id: parseInt(color_id),
                        quantity: parseInt(quantity),
                        img_url: img_url || null
                    });
                    
                    // Store image URL for this part-color combination (if present)
                    if (fields.length > 5 && img_url && img_url.trim() && img_url.startsWith('http')) {
                        // Ensure PART_MAP entry exists
                        if (!PART_MAP[part_num]) {
                            PART_MAP[part_num] = { 
                                id: part_num, 
                                name: 'Unknown Part'
                            };
                        }
                        
                        // Initialize colorImages if it doesn't exist
                        if (!PART_MAP[part_num].colorImages) {
                            PART_MAP[part_num].colorImages = {};
                        }
                        
                        // Store the image URL for this specific color
                        PART_MAP[part_num].colorImages[color_id] = img_url;
                        partsWithColorImagesCount++;
                        
                        // Also set as default image if none exists
                        if (!PART_MAP[part_num].part_img_url) {
                            PART_MAP[part_num].part_img_url = img_url;
                            PART_MAP[part_num].rebrickable_img_url = img_url;
                            partsWithImagesCount++;
                            

                        }
                    } else {

                    }
                    
                    // Ensure parts and colors exist
                    if (!PART_MAP[part_num]) {
                        PART_MAP[part_num] = { 
                            id: part_num, 
                            name: 'Unknown Part'
                        };
                    }
                    if (!COLOR_MAP[color_id]) {
                        COLOR_MAP[color_id] = { 
                            id: color_id, 
                            name: 'Unknown Color', 
                            hex: '#000000' 
                        };
                    }
                } else {
                    skippedLines++;

                }
            }
        });
        

        
        // Load inventory_sets
        const setResponse = await fetch('./Data/inventory_sets.csv');
        const setCsvText = await setResponse.text();
        const setLines = setCsvText.split('\n').slice(1);
        
        setLines.forEach(line => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                const [inventory_id, set_num, quantity] = fields;
                if (inventory_id && set_num && quantity) {
                    if (!inventorySetsMap[inventory_id]) {
                        inventorySetsMap[inventory_id] = [];
                    }
                    inventorySetsMap[inventory_id].push({
                        set_num,
                        quantity: parseInt(quantity)
                    });
                }
            }
        });
        
        // Load inventory_minifigs
        const minifigResponse = await fetch('./Data/inventory_minifigs.csv');
        const minifigCsvText = await minifigResponse.text();
        const minifigLines = minifigCsvText.split('\n').slice(1);
        
        minifigLines.forEach(line => {
            if (line.trim()) {
                const fields = parseCsvLine(line);
                const [inventory_id, fig_num, quantity] = fields;
                if (inventory_id && fig_num && quantity) {
                    if (!inventoryMinifigsMap[inventory_id]) {
                        inventoryMinifigsMap[inventory_id] = [];
                    }
                    inventoryMinifigsMap[inventory_id].push({
                        fig_num,
                        quantity: parseInt(quantity)
                    });
                }
            }
        });
        
        // Store inventory data globally for use in modals
        window.INVENTORY_DATA = {
            parts: inventoryPartsMap,
            sets: inventorySetsMap,
            minifigs: inventoryMinifigsMap
        };
        

        
        // Fetch missing images for collection items
        await fetchMissingImagesFromCSV();
    } catch (error) {
        console.error('Failed to load inventory data from CSV:', error);
        // Don't throw error for inventory as it's not critical
    }
}

// Function to get loading statistics
function getLoadingStats() {
    const stats = {
        colors: Object.keys(COLOR_MAP).length,
        categories: flatCategories.length,
        themes: Object.keys(THEME_MAP).length,
        parts: Object.keys(PART_MAP).length,
        sets: Object.keys(SET_MAP).length,
        minifigs: Object.keys(MINIFIG_MAP).length,
        partsWithImages: Object.values(PART_MAP).filter(p => p.part_img_url || p.rebrickable_img_url).length,
        setsWithImages: Object.values(SET_MAP).filter(s => s.set_img_url).length,
        minifigsWithImages: Object.values(MINIFIG_MAP).filter(m => m.minifig_img_url).length
    };
    
    // Get API loading statistics
    const apiStats = getApiLoadingStats();
    
    return {
        ...stats,
        ...apiStats
    };
}

// Function to get API loading statistics
function getApiLoadingStats() {
    const apiStats = JSON.parse(localStorage.getItem('legoApiStats') || '{}');
    
    return {
        apiColors: apiStats.colors || 0,
        apiParts: apiStats.parts || 0,
        apiSets: apiStats.sets || 0,
        apiMinifigs: apiStats.minifigs || 0,
        apiImages: apiStats.images || 0,
        lastApiUpdate: apiStats.lastUpdate || null
    };
}

// Function to update API loading statistics
function updateApiLoadingStats(type, count = 1) {
    try {
        const apiStats = JSON.parse(localStorage.getItem('legoApiStats') || '{}');
        
        if (!apiStats[type]) {
            apiStats[type] = 0;
        }
        
        apiStats[type] += count;
        apiStats.lastUpdate = new Date().toISOString();
        
        localStorage.setItem('legoApiStats', JSON.stringify(apiStats));
    } catch (error) {
        console.error('Failed to update API stats:', error);
    }
}

// Function to update settings modal status without full re-render
function updateSettingsModalStatus(status, statusType = 'info') {
    if (!S.settingsOpen || !S.settingsModal) return;
    
    S.settingsModal.status = status;
    S.settingsModal.statusType = statusType;
    
    // Update only the status element without full re-render
    const statusElement = document.getElementById('import-export-status');
    if (statusElement) {
        const statusClass = statusType === 'error' ? 'bg-red-900/50 text-red-300' : 
                           statusType === 'success' ? 'bg-green-900/50 text-green-300' : 
                           'bg-blue-900/50 text-blue-300';
        
        statusElement.className = `mb-2 p-2 text-sm rounded-md ${statusClass}`;
        statusElement.textContent = status;
        statusElement.classList.remove('hidden');
    }
}

// Function to search in CSV data instead of API
function searchInCSVData(query, type = 'parts') {
    if (!query || query.trim().length < 2) return [];
    
    const searchTerm = query.toLowerCase().trim();
    const results = [];
    
    console.log('searchInCSVData called with:', { query, type, searchTerm });
    console.log('PART_MAP keys:', Object.keys(PART_MAP).slice(0, 5));
    
    switch (type) {
        case 'parts':
            Object.values(PART_MAP).forEach(part => {
                if (part.name && part.name.toLowerCase().includes(searchTerm) ||
                    part.id && part.id.toLowerCase().includes(searchTerm)) {
                    results.push({
                        ...part,
                        type: 'part',
                        searchScore: calculateSearchScore(part, searchTerm)
                    });
                }
            });
            break;
            
        case 'sets':
            Object.values(SET_MAP).forEach(set => {
                if (set.name && set.name.toLowerCase().includes(searchTerm) ||
                    set.set_num && set.set_num.toLowerCase().includes(searchTerm)) {
                    results.push({
                        ...set,
                        type: 'set',
                        searchScore: calculateSearchScore(set, searchTerm)
                    });
                }
            });
            break;
            
        case 'minifigs':
            Object.values(MINIFIG_MAP).forEach(minifig => {
                if (minifig.name && minifig.name.toLowerCase().includes(searchTerm) ||
                    minifig.set_num && minifig.set_num.toLowerCase().includes(searchTerm)) {
                    results.push({
                        ...minifig,
                        type: 'minifig',
                        searchScore: calculateSearchScore(minifig, searchTerm)
                    });
                }
            });
            break;
            
        default:
            // Search in all types
            searchInCSVData(query, 'parts').forEach(r => results.push(r));
            searchInCSVData(query, 'sets').forEach(r => results.push(r));
            searchInCSVData(query, 'minifigs').forEach(r => results.push(r));
            break;
    }
    
    // Sort by search score and limit results
    return results
        .sort((a, b) => b.searchScore - a.searchScore)
        .slice(0, 50);
}

// Function to calculate search relevance score
function calculateSearchScore(item, searchTerm) {
    let score = 0;
    
    // Exact match gets highest score
    if (item.name && item.name.toLowerCase() === searchTerm) score += 100;
    if (item.id && item.id.toLowerCase() === searchTerm) score += 100;
    if (item.set_num && item.set_num.toLowerCase() === searchTerm) score += 100;
    
    // Starts with search term
    if (item.name && item.name.toLowerCase().startsWith(searchTerm)) score += 50;
    if (item.id && item.id.toLowerCase().startsWith(searchTerm)) score += 50;
    if (item.set_num && item.set_num.toLowerCase().startsWith(searchTerm)) score += 50;
    
    // Contains search term
    if (item.name && item.name.toLowerCase().includes(searchTerm)) score += 25;
    if (item.id && item.id.toLowerCase().includes(searchTerm)) score += 25;
    if (item.set_num && item.set_num.toLowerCase().includes(searchTerm)) score += 25;
    

    
    return score;
}

// Function to check for new data from API in background (without overloading)
async function checkForNewDataInBackground() {
    try {
        // Only check for new data, don't download everything
        const newDataAvailable = await checkForNewDataAvailability();
        
        if (newDataAvailable) {
            // Download new data in background with delays to avoid overloading
            downloadNewDataInBackground();
        }
        
    } catch (error) {
        console.error('Failed to check for new data:', error);
        // Don't show error to user, this is background operation
    }
}

// Function to check if new data is available from API
async function checkForNewDataAvailability() {
    try {
        // Since we now generate all image URLs from CSV data, there's no need to check for new images
        // This function is kept for future use when new data might be available
        return false;
        
    } catch (error) {
        console.error('Failed to check data availability:', error);
        return false;
    }
}

// Function to download new data in background with delays
async function downloadNewDataInBackground() {
    try {
        // Since we now generate all image URLs from CSV data, there's no need to download images
        // This function is kept for future use when new data might be available
        
        // Save state after background download
        saveState();
        
        // Update UI if needed
        if (S.gridStale) {
            updateUI();
        }
        
    } catch (error) {
        console.error('Background download failed:', error);
    }
}

// Function to check what data is missing and needs API calls
function checkMissingData() {
    const missing = {
        parts: [],
        sets: [],
        minifigs: [],
        colors: [],
        categories: [],
        themes: []
    };
    
    // Since we now generate image URLs from CSV data, we don't need to check for missing images
    // Only check for data that might be truly missing (e.g., new releases not in CSV)
    
    return missing;
}

// Function to load missing data from API
async function loadMissingDataFromAPI() {
    try {
        const missing = checkMissingData();
        
        if (missing.parts.length === 0 && missing.sets.length === 0 && missing.minifigs.length === 0) {
            return;
        }
        
        // Update loading status
        updateSettingsModalStatus("Загрузка недостающих данных из API...", "info");
        
        // Since we now generate all image URLs from CSV, this function is mainly for future use
        // when new data might be available that's not in our CSV files
        
        const stats = getLoadingStats();
        
        // Update loading status
        updateSettingsModalStatus("Все данные доступны из CSV!", "success");
        
        // Save state after API loading
        saveState();
        
    } catch (error) {
        console.error('Failed to load missing data from API:', error);
    }
}

// Function to force refresh minifig data to avoid #undefined
async function refreshMinifigData() {
    try {
        const minifigsToRefresh = Object.keys(S.minifigColl).filter(figNum => !MINIFIG_MAP[figNum]?.name);
        
        if (minifigsToRefresh.length === 0) {
            return;
        }
        
        updateSettingsModalStatus("Обновление данных минифигурок...", "info");
        await fetchMissingCollectionMinifigDetails();
        
        // Update UI after refresh
        S.gridStale = true;
        updateUI();
        updateSettingsModalStatus("Данные минифигурок обновлены!", "success");
    } catch (error) {
        console.error('Failed to refresh minifig data:', error);
    }
}

// Function to force refresh image cache for better performance
async function refreshImageCache() {
    try {
        const cache = await caches.open(CACHE_NAME);
        const requests = await cache.keys();
        
        // Find image requests
        const imageRequests = requests.filter(req => 
            req.url.match(/\.(png|jpg|jpeg|gif|webp|svg)$/i) ||
            req.url.includes('cdn.rebrickable.com') ||
            req.url.includes('m.rebrickable.com')
        );
        
        if (imageRequests.length === 0) {
            return;
        }
        
        // Refresh each image by fetching it again
        for (const request of imageRequests) {
            try {
                const response = await fetch(request.url, { 
                    mode: 'no-cors',
                    cache: 'reload'
                });
                if (response) {
                    await cache.put(request, response);
                }
            } catch (error) {
                // Ignore individual image refresh errors
            }
        }
    } catch (error) {
        console.error('Failed to refresh image cache:', error);
    }
}

// Auto-refresh image cache every 30 minutes for better performance
setInterval(refreshImageCache, 30 * 60 * 1000);

// Function to force save all state data including newly fetched details
function forceSaveState() {
    try {
        saveState();
        
        // Also save any additional data that might have been fetched
        const cache = {
            parts: Object.keys(PART_MAP).length,
            colors: Object.keys(COLOR_MAP).length,
            categories: flatCategories.length,
            themes: Object.keys(THEME_MAP).length,
            sets: Object.keys(SET_MAP).length,
            minifigs: Object.keys(MINIFIG_MAP).length
        };
        
        localStorage.setItem('legoDataCacheStats', JSON.stringify(cache));
    } catch (e) {
        console.error('Failed to force save state:', e);
    }
}

// Function to get color-specific image URL with automatic API fallback
function getColorImageUrl(partNum, colorId, fallbackUrl = null) {
    const part = PART_MAP[partNum];
    if (!part || !part.colorImages) {
        // If no color images cached, trigger fetch
        fetchColorDetailsForPart(partNum).catch(console.error);
        return fallbackUrl || `data:image/svg+xml,${encodeURIComponent(I_Img("w-full h-full text-gray-500"))}`;
    }
    
    const colorImageUrl = part.colorImages[colorId];
    if (!colorImageUrl) {
        // If specific color image not found, trigger fetch
        fetchColorDetailsForPart(partNum).catch(console.error);
        return fallbackUrl || `data:image/svg+xml,${encodeURIComponent(I_Img("w-full h-full text-gray-500"))}`;
    }
    
    return `src="${colorImageUrl}" onerror="this.onerror=null; this.src='${fallbackUrl || `data:image/svg+xml,${encodeURIComponent(I_Img("w-full h-full text-gray-500"))}`}'; handleColorImageLoadError(this, '${partNum}', '${colorId}', '${colorImageUrl}');"`
}

// Function to handle color image load errors and fetch from API
async function handleColorImageLoadError(imgElement, partNum, colorId, originalUrl) {
    try {

        
        // Fetch color details from API to get fresh image URL
        const colorDetails = await fetchPartColorDetailsFromAPI(partNum, colorId);
        if (colorDetails && colorDetails.part_img_url) {
            // Update the image source
            imgElement.src = colorDetails.part_img_url;
            
            // Cache the new color image URL
            if (PART_MAP[partNum] && PART_MAP[partNum].colorImages) {
                PART_MAP[partNum].colorImages[colorId] = colorDetails.part_img_url;
                forceSaveState();
            }
            

            return;
        }
        
        console.warn(`Could not fetch color image for part ${partNum} color ${colorId}`);
    } catch (error) {
        console.error('Error handling color image load error:', error);
    }
}

// Helper function to fetch part color details from API
async function fetchPartColorDetailsFromAPI(partNum, colorId) {
    try {
        const response = await fetch(`${REBRICKABLE_API_URL}/parts/${partNum}/colors/${colorId}/`, {
            headers: {
                Authorization: `key ${getApiKey()}`
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            return data;
        }
    } catch (error) {
        console.error(`Failed to fetch color details for part ${partNum} color ${colorId}:`, error);
    }
    return null;
}

// Function to check for missing images in collection
async function fetchMissingImagesForCollection() {
    try {
        // Check for missing minifig images
        const minifigsWithoutImages = Object.values(MINIFIG_MAP).filter(m => 
            m && !m.minifig_img_url && !m.set_img_url
        );
        
        if (minifigsWithoutImages.length > 0) {
            await fetchMissingMinifigImages();
        }
        
        // Check for missing part images
        const partsWithoutImages = Object.values(PART_MAP).filter(p => 
            p && !p.part_img_url && !p.rebrickable_img_url
        );
        
        if (partsWithoutImages.length > 0) {
            // This will be handled by the existing functions
        }
        
        // Check for missing set images
        const setsWithoutImages = Object.values(SET_MAP).filter(s => 
            s && !s.set_img_url
        );
        
        if (setsWithoutImages.length > 0) {
            // This will be handled by the existing functions
        }
        
    } catch (error) {
        console.error('Error checking missing images:', error);
    }
}

// Function to check images for currently viewed items
async function fetchImagesForViewedItems() {
    try {
        // Check minifig modal
        if (S.selFigNum && MINIFIG_MAP[S.selFigNum]) {
            const minifig = MINIFIG_MAP[S.selFigNum];
            if (!minifig.minifig_img_url && !minifig.set_img_url) {
                await fetchMinifigDetails(S.selFigNum);
            }
        }
        
        // Check part modal
        if (S.selPartId && PART_MAP[S.selPartId]) {
            const part = PART_MAP[S.selPartId];
            if (!part.part_img_url && !part.rebrickable_img_url) {
                // This will be handled by the part modal itself
            }
        }
        
        // Check set modal
        if (S.selSetNum && SET_MAP[S.selSetNum]) {
            const set = SET_MAP[S.selSetNum];
            if (!set.set_img_url) {
                // This will be handled by the set modal itself
            }
        }
        
    } catch (error) {
        console.error('Error checking viewed item images:', error);
    }
}
        


async function fetchMinifigDetailsWithRetry(figNum, retries = 3, delay = 1000) {
    for (let attempt = 0; attempt < retries; attempt++) {
        try {
            await fetchMinifigDetails(figNum);
            return;
        } catch (err) {
            if (err && err.message && err.message.includes('429')) {
                // Too Many Requests, wait and retry
                await new Promise(res => setTimeout(res, delay * (attempt + 1)));
            } else {
                // Other error, do not retry
                break;
            }
        }
    }
}

async function fetchMissingCollectionMinifigDetails() {
    const allFigNums = Object.keys(S.minifigColl).filter(e => !MINIFIG_MAP[e] || !MINIFIG_MAP[e].name);
    if (allFigNums.length === 0) return;
    const batchSize = 5;
    for (let i = 0; i < allFigNums.length; i += batchSize) {
        const batch = allFigNums.slice(i, i + batchSize);
        try {
            const results = await Promise.all(batch.map(figNum => fetchMinifigDetailsWithRetry(figNum)));
            // Save state after each batch to avoid data loss
            saveState();
            
            // Update API loading statistics for minifigs
            const successfulFetches = results.filter(result => result !== undefined).length;
            if (successfulFetches > 0) {
                updateApiLoadingStats('minifigs', successfulFetches);
            }
        } catch (error) {
            console.error(`Failed to fetch batch ${i}-${i + batchSize}:`, error);
        }
        // Add delay between batches to avoid rate limiting
        if (i + batchSize < allFigNums.length) {
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
            }
    }
    
    // Initialize API loading statistics if not exists
    function initializeApiStats() {
        if (!localStorage.getItem('legoApiStats')) {
            const initialStats = {
                colors: 0,
                parts: 0,
                sets: 0,
                minifigs: 0,
                images: 0,
                lastUpdate: null
            };
            localStorage.setItem('legoApiStats', JSON.stringify(initialStats));
        }
    }
    
    // Call initialization when app starts
    initializeApiStats();
  </script>
</body>
</html>