<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Каталог деталей и наборов LEGO</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: sans-serif; }
    .no-scrollbar::-webkit-scrollbar { display: none; }
    .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    #search-input::-webkit-search-cancel-button {
      -webkit-appearance: none;
      appearance: none;
      display: none;
    }
    .checkerboard {
      background-image:
        linear-gradient(45deg, #374151 25%, transparent 25%),
        linear-gradient(-45deg, #374151 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #374151 75%),
        linear-gradient(-45deg, transparent 75%, #374151 75%);
      background-size: 8px 8px;
      background-position: 0 0, 0 4px, 4px -4px, -4px 0px;
    }
    .modal-hidden { display: none !important; }
    .loader {
      border: 4px solid #4A5568;
      border-top: 4px solid #4299E1;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Animation Keyframes */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }
    @keyframes scaleIn {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }
    @keyframes scaleOut {
      from { opacity: 1; transform: scale(1); }
      to { opacity: 0; transform: scale(0.95); }
    }
    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(1rem); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Animation Classes */
    #modal-container, #filter-modal-container, #set-modal-container, #settings-modal-container, #minifig-modal-container {
        opacity: 0;
        transition: opacity 0.2s ease-out;
    }
    #modal-container.visible, #filter-modal-container.visible, #set-modal-container.visible, #settings-modal-container.visible, #minifig-modal-container.visible {
        opacity: 1;
    }
    .modal-content-enter {
      animation: scaleIn 0.2s ease-out forwards;
    }
    .modal-content-leave {
      animation: scaleOut 0.2s ease-out forwards;
    }
    .part-card.animate-in, .set-card.animate-in, .minifig-card.animate-in {
      opacity: 0;
      animation: fadeInUp 0.4s ease-out forwards;
    }
    
    #color-selector-wrapper {
        transition: max-height 0.35s ease-in-out;
        overflow: hidden;
    }
  </style>
<link rel="stylesheet" href="/index.css">
</head>
<body class="bg-gray-900 text-gray-200">

  <!-- Sidebar -->
  <aside id="sidebar-container" class="w-80 bg-gray-800 p-4 flex flex-col h-full border-r border-gray-700 fixed inset-y-0 left-0 z-40 transition-transform duration-300 ease-in-out lg:translate-x-0 -translate-x-full"></aside>

  <!-- Backdrop for mobile sidebar -->
  <div id="sidebar-backdrop" class="fixed inset-0 bg-black bg-opacity-60 z-30 hidden lg:hidden"></div>

  <div class="lg:ml-80 flex flex-col h-screen">
    <!-- Header -->
    <header id="header-container" class="bg-gray-800/50 backdrop-blur-sm sticky top-0 z-20 p-4 border-b border-gray-700"></header>
    
    <!-- Main Content -->
    <main id="main-content" class="flex-1 overflow-y-auto no-scrollbar"></main>

  </div>

  <!-- Part Modal -->
  <div id="modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 backdrop-blur-sm modal-hidden"></div>
  
  <!-- Set Modal -->
  <div id="set-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 backdrop-blur-sm modal-hidden"></div>
  
  <!-- Minifig Modal -->
  <div id="minifig-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 backdrop-blur-sm modal-hidden"></div>

  <!-- Filter Modal -->
  <div id="filter-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 backdrop-blur-sm modal-hidden"></div>

  <!-- Settings Modal -->
  <div id="settings-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 backdrop-blur-sm modal-hidden"></div>

  <!-- Scroll to Top Button -->
  <button id="scroll-to-top-btn" class="fixed bottom-6 right-6 bg-blue-600 text-white p-3 rounded-full shadow-lg hover:bg-blue-700 transition-all duration-300 opacity-0 pointer-events-none z-50 transform translate-y-4" aria-label="Вернуться наверх">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7"></path>
    </svg>
  </button>

  <script>
    // --- APP LOGIC ---
    
    // --- API CONFIG ---
    const REBRICKABLE_API_URL = 'https://rebrickable.com/api/v3/lego';
    const REBRICKABLE_API_KEYS = ['20c78cc607d6059c8d2a61338d851590', '04a7405ad41f1dd484a562f6e0c57312', 'd93f5c0989f63afa9b1c29ef8ad66002'];
    let currentApiKeyIndex = 0;
    function getApiKey() {
        const key = REBRICKABLE_API_KEYS[currentApiKeyIndex];
        currentApiKeyIndex = (currentApiKeyIndex + 1) % REBRICKABLE_API_KEYS.length;
        return key;
    }


    // --- UI CONFIG ---
    const COLOR_COLLAPSE_THRESHOLD = 18;

    // --- DATA MAPS (populated dynamically) ---
    let COLOR_MAP = {};
    let PART_MAP = {};
    let SET_MAP = {};
    let MINIFIG_MAP = {};
    let THEME_MAP = {};
    let flatCategories = [];

    // --- ICONS ---
    const CatalogIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>`;
    const CollectionIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polygon points="2 17 12 22 22 17"></polygon><polygon points="2 12 12 17 22 12"></polygon></svg>`;
    const SetsIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>`;
    const PlusIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>`;
    const MinusIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>`;
    const XIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
    const MenuIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>`;
    const UploadIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>`;
    const DownloadIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>`;
    const ImageIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>`;
    const TrashIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`;
    const SearchIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>`;
    const ChevronDownIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>`;
    const DiceIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><path d="M16 8h.01"></path><path d="M12 12h.01"></path><path d="M8 16h.01"></path><path d="M8 8h.01"></path><path d="M16 16h.01"></path></svg>`;
    const BrickIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="10" rx="2" ry="2"></rect><path d="M7 11V7a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v4"></path><path d="M12 11V7"></path></svg>`;
    const PlateIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="15" width="18" height="6" rx="1"></rect><circle cx="8" cy="18" r="1"></circle><circle cx="16" cy="18" r="1"></circle></svg>`;
    const TechnicIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20.94c1.5 0 2.85-.93 3.53-2.28a3.99 3.99 0 0 0-7.06 0c.68 1.35 2.03 2.28 3.53 2.28z"></path><path d="M12 3.06c-1.5 0-2.85.93-3.53 2.28a3.99 3.99 0 0 0 7.06 0C14.85 3.99 13.5 3.06 12 3.06z"></path><path d="M3.06 12c0-1.5.93-2.85 2.28-3.53a3.99 3.99 0 0 0 0 7.06C3.99 14.85 3.06 13.5 3.06 12z"></path><path d="M20.94 12c0 1.5-.93 2.85-2.28 3.53a3.99 3.99 0 0 0 0-7.06c1.35.68 2.28 2.03 2.28 3.53z"></path><circle cx="12" cy="12" r="1"></circle></svg>`;
    const SlopeIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 20h18L3 4v16z"></path></svg>`;
    const TileIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>`;
    const WindowIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"></rect><path d="M3 12h18"></path><path d="M12 3v18"></path></svg>`;
    const WheelIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle></svg>`;
    const MinifigIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="8" r="3"></circle><path d="M12 11v5"></path><path d="M9 22v-5h6v5"></path><path d="M9 11H5a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h4"></path><path d="M15 11h4a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-4"></path></svg>`;
    const BarIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12h16"></path><path d="M4 12a2 2 0 1 0-4 0 2 2 0 0 0 4 0z"></path><path d="M20 12a2 2 0 1 0 4 0 2 2 0 0 0-4 0z"></path></svg>`;
    const ArchIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 21V11c0-3.87 3.13-7 7-7s7 3.13 7 7v10"></path><path d="M5 21h14"></path></svg>`;
    const OtherIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>`;
    const FilterIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>`;
    const ThemeIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"></path></svg>`;
    const SettingsIcon = (className) => `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>`;
    const HeartIcon = (className, filled = false) => {
        if (filled) {
            return `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>`;
        }
        return `<svg xmlns="http://www.w3.org/2000/svg" class="${className}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>`;
    };

    // --- STATE MANAGEMENT ---
    let state = {
      currentView: 'catalog', // 'catalog', 'collection'
      activeSubView: 'parts', // 'parts', 'sets', 'minifigs'
      // Part state
      categoryTree: [],
      expandedCategories: new Set(),
      selectedCategoryId: null,
      selectedCollectionCategoryId: null,
      catalogGroups: null,
      favoriteCategoryIds: new Set(),
      // Set state
      themeTree: [],
      expandedThemes: new Set(),
      selectedThemeId: null,
      selectedSetCollectionThemeId: null,
      setResults: null,
      favoriteThemeIds: new Set(),
      // Minifig state
      minifigResults: null,
      // Search state
      searchQuery: '',
      searchResultGroups: null, // For parts
      searchSetResults: null, // For sets
      searchMinifigResults: null,
      // Global state
      isLoading: true, // Start in loading state for initialization
      apiError: null,
      selectedPartId: null,
      selectedSetNum: null,
      selectedFigNum: null,
      isSidebarOpen: window.innerWidth >= 1024,
      isGridStale: true, // Flag to trigger grid animations
      // Modals state
      modal: {
          partGroupId: null,
          partVariations: [],
          selectedColorId: null,
          quantity: 1,
          isLoadingColors: false,
          isImageLoading: false,
          partImageUrl: null,
      },
      setModal: {
          isLoading: false,
          inventory: [],
          inventoryPage: 1,
          hasNextInventoryPage: false,
          quantity: 1,
          isBulkUpdating: false,
          statusMessage: '',
          statusType: '',
          currentView: 'details',
          minifigs: [],
          areMinifigsLoading: false,
      },
      minifigModal: {
        isLoading: false,
        quantity: 1,
      },
      isFilterModalOpen: false,
      isSettingsModalOpen: false,
      settingsModal: {
          confirmingDelete: null, // null, 'parts', 'sets', 'minifigs'
      },
      // Other state
      itemsToDisplay: 48,
      itemsIncrement: 48,
      collection: {},
      setCollection: {},
      minifigCollection: {},
      filters: {
          colorIds: [],
          inCollectionOnly: false,
      },
      setFilters: {
          minYear: '',
          maxYear: '',
          minParts: '',
          maxParts: '',
      },
      sortBy: 'popularity',
    };
    
    let tempFilters = {};

    function loadState() {
      const savedCollection = localStorage.getItem('legoCollection');
      if (savedCollection) {
        try {
          const parsed = JSON.parse(savedCollection);
          if (typeof parsed === 'object' && parsed !== null) {
            state.collection = parsed;
          }
        } catch (e) {
          console.error("Failed to parse lego collection from localStorage", e);
          state.collection = {};
        }
      }
      const savedSetCollection = localStorage.getItem('legoSetCollection');
      if (savedSetCollection) {
        try {
          const parsed = JSON.parse(savedSetCollection);
          if (typeof parsed === 'object' && parsed !== null) {
            state.setCollection = parsed;
          }
        } catch (e) {
          console.error("Failed to parse lego set collection from localStorage", e);
          state.setCollection = {};
        }
      }
      const savedMinifigCollection = localStorage.getItem('legoMinifigCollection');
        if (savedMinifigCollection) {
            try {
                const parsed = JSON.parse(savedMinifigCollection);
                if (typeof parsed === 'object' && parsed !== null) {
                    state.minifigCollection = parsed;
                }
            } catch (e) {
                console.error("Failed to parse lego minifig collection from localStorage", e);
                state.minifigCollection = {};
            }
        }
      const savedFavoriteCategories = localStorage.getItem('favoriteCategoryIds');
      if (savedFavoriteCategories) {
          try {
              state.favoriteCategoryIds = new Set(JSON.parse(savedFavoriteCategories));
          } catch (e) {
              console.error("Failed to parse favorite categories from localStorage", e);
              state.favoriteCategoryIds = new Set();
          }
      }
      const savedFavoriteThemes = localStorage.getItem('favoriteThemeIds');
      if (savedFavoriteThemes) {
          try {
              state.favoriteThemeIds = new Set(JSON.parse(savedFavoriteThemes));
          } catch (e) {
              console.error("Failed to parse favorite themes from localStorage", e);
              state.favoriteThemeIds = new Set();
          }
      }
    }

    function saveState() {
      localStorage.setItem('legoCollection', JSON.stringify(state.collection));
      localStorage.setItem('legoSetCollection', JSON.stringify(state.setCollection));
      localStorage.setItem('legoMinifigCollection', JSON.stringify(state.minifigCollection));
      localStorage.setItem('favoriteCategoryIds', JSON.stringify(Array.from(state.favoriteCategoryIds)));
      localStorage.setItem('favoriteThemeIds', JSON.stringify(Array.from(state.favoriteThemeIds)));
    }

    // --- DOM Elements ---
    const sidebarContainer = document.getElementById('sidebar-container');
    const sidebarBackdrop = document.getElementById('sidebar-backdrop');
    const headerContainer = document.getElementById('header-container');
    const mainContent = document.getElementById('main-content');
    const modalContainer = document.getElementById('modal-container');
    const setModalContainer = document.getElementById('set-modal-container');
    const minifigModalContainer = document.getElementById('minifig-modal-container');
    const filterModalContainer = document.getElementById('filter-modal-container');
    const settingsModalContainer = document.getElementById('settings-modal-container');
    const scrollToTopBtn = document.getElementById('scroll-to-top-btn');
    
    // --- API & DATA HANDLING ---
    
    async function apiFetchPaginated(baseEndpoint) {
        let allResults = [];
        let page = 1;
        const PAGE_SIZE = 1000;

        while (true) {
            const separator = baseEndpoint.includes('?') ? '&' : '?';
            const fullUrl = `${REBRICKABLE_API_URL}${baseEndpoint}${separator}page=${page}&page_size=${PAGE_SIZE}`;
            
            const response = await fetch(fullUrl, {
                headers: { 'Authorization': `key ${getApiKey()}` }
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ detail: 'Не удалось получить детали ошибки.' }));
                throw new Error(`Ошибка API Rebrickable: ${response.status} - ${errorData.detail}`);
            }

            const data = await response.json();
            
            if (data.results && data.results.length > 0) {
                allResults = allResults.concat(data.results);
            }
            
            if (!data.next) {
                break;
            }
            page++;
        }
        return allResults;
    }

    function processPartData(apiPart) {
      if (!apiPart || !apiPart.part_num) {
        console.warn("Пропуск некорректных данных о детали из API:", apiPart);
        return null;
      }
      const partData = {
          id: apiPart.part_num,
          name: apiPart.name,
          rebrickable_img_url: apiPart.part_img_url,
          categoryId: apiPart.part_cat_id,
          num_sets: apiPart.num_sets,
          part_num: apiPart.part_num,
      };
      PART_MAP[partData.id] = { ...PART_MAP[partData.id], ...partData };
      return partData;
    }

    function getGroupId(partNum) {
        if (!partNum || typeof partNum !== 'string') return partNum || 'unknown_group';
        const match = partNum.match(/^([0-9]+)/);
        return match ? match[1] : partNum.split('p')[0];
    }
    
    function groupParts(parts) {
        const groups = {};
        (parts || []).forEach(part => {
            if (!part || !part.part_num) {
                console.warn('Пропуск детали без номера:', part);
                return;
            }
            const groupId = getGroupId(part.part_num);
            if (!groups[groupId]) {
                groups[groupId] = [];
            }
            groups[groupId].push(part);
        });
        for (const groupId in groups) {
            groups[groupId].sort(partRelevanceComparator);
        }
        return groups;
    }

    function buildCategoryTree(categories) {
        const categoryGroups = {
            'Bricks': ['brick'],
            'Plates': ['plate'],
            'Technic': ['technic'],
            'Slopes & Wedges': ['slope', 'wedge'],
            'Tiles': ['tile'],
            'Panels, Doors & Windows': ['panel', 'door', 'window'],
            'Wheels & Tyres': ['wheel', 'tyre'],
            'Minifig': ['minifig', 'minidoll', 'headwear'],
            'Bars, Hinges & Connectors': ['bar', 'hinge', 'connector', 'link', 'axle', 'pin'],
            'Arches & Curves': ['arch', 'curved', 'round', 'cone', 'cylinder'],
        };

        const tree = {};
        const other = [];

        (categories || []).forEach(cat => {
            const lowerName = cat.name.toLowerCase();
            let found = false;
            for (const groupName in categoryGroups) {
                if (categoryGroups[groupName].some(keyword => lowerName.includes(keyword))) {
                    if (!tree[groupName]) {
                        tree[groupName] = { name: groupName, children: [] };
                    }
                    tree[groupName].children.push(cat);
                    found = true;
                    break;
                }
            }
            if (!found) {
                other.push(cat);
            }
        });
        
        const sortedTree = Object.values(tree).sort((a,b) => a.name.localeCompare(b.name));
        
        if (other.length > 0) {
            sortedTree.push({ name: 'Other', children: other.sort((a,b) => a.name.localeCompare(b.name))});
        }
        
        return sortedTree;
    }


    async function fetchCategories() {
        try {
            const categories = await apiFetchPaginated('/part_categories/');
            flatCategories = categories.sort((a, b) => a.name.localeCompare(b.name));
            state.categoryTree = buildCategoryTree(flatCategories);
        } catch (error) {
            console.error("Ошибка загрузки категорий:", error);
            state.apiError = `Не удалось загрузить категории: ${error.message}`;
            state.categoryTree = [];
        }
    }

    async function fetchThemes() {
        try {
            const themes = await apiFetchPaginated('/themes/');
            const tree = [];
            const lookup = {};

            // First pass: create all nodes in lookup table and THEME_MAP
            (themes || []).forEach(t => {
                if (t && t.id) {
                    // The node in lookup has the .children property
                    const node = { ...t, children: [] };
                    lookup[t.id] = node;
                    THEME_MAP[t.id] = node;
                }
            });

            // Second pass: build the tree structure
            (themes || []).forEach(t => {
                if (t && t.id && lookup[t.id]) { // Ensure node exists
                    if (t.parent_id && lookup[t.parent_id]) {
                        // Ensure children array exists before pushing
                        if (!Array.isArray(lookup[t.parent_id].children)) {
                            lookup[t.parent_id].children = [];
                        }
                        lookup[t.parent_id].children.push(lookup[t.id]);
                    } else {
                        tree.push(lookup[t.id]);
                    }
                }
            });

            const sortRec = (node) => {
                if (Array.isArray(node.children) && node.children.length > 0) {
                    node.children.sort((a, b) => a.name.localeCompare(b.name));
                    node.children.forEach(sortRec);
                }
            };

            tree.sort((a, b) => a.name.localeCompare(b.name));
            tree.forEach(sortRec);
            state.themeTree = tree;
        } catch (error) {
            console.error("Ошибка загрузки тем:", error);
            state.apiError = (state.apiError ? state.apiError + '\n' : '') + `Не удалось загрузить темы: ${error.message}`;
            state.themeTree = [];
        }
    }

    async function fetchAllColors() {
        try {
            const colors = await apiFetchPaginated('/colors/');
            (colors || []).forEach(colorInfo => {
                const colorIdStr = String(colorInfo.id);
                COLOR_MAP[colorIdStr] = {
                    id: colorIdStr,
                    name: colorInfo.name,
                    hex: `#${colorInfo.rgb}`,
                    isTransparent: colorInfo.is_trans,
                };
            });
        } catch (error) {
            console.error("Ошибка загрузки цветов:", error);
            state.apiError = (state.apiError ? state.apiError + '\n' : '') + 'Не удалось загрузить палитру цветов.';
        }
    }

    async function loadPartsForCategory(categoryId) {
        state.selectedCategoryId = categoryId;
        state.isLoading = true;
        state.apiError = null;
        state.searchResultGroups = null;
        state.searchQuery = '';
        state.catalogGroups = null;
        state.itemsToDisplay = state.itemsIncrement;
        state.isGridStale = true;
        updateUI();

        if (state.filters.colorIds && state.filters.colorIds.length > 1) {
            state.catalogGroups = {};
            state.isLoading = false;
            updateUI();
            return;
        }

        try {
            let endpoint = `/parts/?part_cat_id=${categoryId}`;
            if (state.filters.colorIds && state.filters.colorIds.length === 1) {
                endpoint += `&color_id=${state.filters.colorIds[0]}`;
            }
            const rawParts = await apiFetchPaginated(endpoint);
            const parts = rawParts.map(processPartData).filter(Boolean);
            
            let filteredParts = parts;
            if (state.filters.inCollectionOnly) {
                 filteredParts = parts.filter(p => state.collection[p.id] && Object.keys(state.collection[p.id]).length > 0);
            }

            state.catalogGroups = groupParts(filteredParts);
        } catch (error)
        {
            console.error("Rebrickable parts fetch failed:", error);
            state.apiError = error.message;
        } finally {
            state.isLoading = false;
            updateUI();
        }
    }

    function getRelevanceScore(part, query) {
        const lowerQuery = query.toLowerCase();
        const lowerName = part.name.toLowerCase();
        const partNum = part.part_num.toLowerCase();

        if (partNum === lowerQuery) return 100;
        if (lowerName === lowerQuery) return 90;
        if (partNum.startsWith(lowerQuery)) return 80;
        if (lowerName.startsWith(lowerQuery)) return 70;
        if (partNum.includes(lowerQuery)) return 60;
        if (lowerName.includes(lowerQuery)) return 50;
        return 0;
    }

    function partRelevanceComparator(a, b) {
        if (!b || !b.part_num || !b.name) return -1;
        if (!a || !a.part_num || !a.name) return 1;

        const isPrintA = a.name.toLowerCase().includes('print') || a.name.toLowerCase().includes('sticker') || a.name.toLowerCase().includes('pattern');
        const isPrintB = b.name.toLowerCase().includes('print') || b.name.toLowerCase().includes('sticker') || b.name.toLowerCase().includes('pattern');
        if (isPrintA && !isPrintB) return 1;
        if (!isPrintA && isPrintB) return -1;

        const isAltA = a.part_num.match(/[a-zA-Z]/);
        const isAltB = b.part_num.match(/[a-zA-Z]/);
        if (isAltA && !isAltB) return 1;
        if (!isAltA && isAltB) return -1;
        
        const popularityDiff = b.num_sets - a.num_sets;
        if (popularityDiff !== 0) return popularityDiff;

        const lengthDiff = a.name.length - b.name.length;
        if (lengthDiff !== 0) return lengthDiff;

        return a.part_num.localeCompare(b.part_num);
    }
    
    async function searchRebrickableParts(query) {
        if (!query || query.trim().length === 0) {
            state.searchResultGroups = null;
            state.isLoading = false;
            state.selectedCategoryId = null;
            state.isGridStale = true;
            updateUI();
            return;
        }
        state.isLoading = true;
        state.apiError = null;
        state.selectedCategoryId = null;
        state.catalogGroups = null;
        state.itemsToDisplay = state.itemsIncrement;
        state.isGridStale = true;
        updateUI();

        if (state.filters.colorIds && state.filters.colorIds.length > 1) {
            state.searchResultGroups = {};
            state.isLoading = false;
            updateUI();
            return;
        }

        try {
            let endpoint = `/parts/?search=${encodeURIComponent(query)}`;
            if (state.filters.colorIds && state.filters.colorIds.length === 1) {
                endpoint += `&color_id=${state.filters.colorIds[0]}`;
            }
            const rawParts = await apiFetchPaginated(endpoint);
            let parts = rawParts.map(processPartData).filter(Boolean);
            
            if (state.filters.inCollectionOnly) {
                 parts = parts.filter(p => state.collection[p.id] && Object.keys(state.collection[p.id]).length > 0);
            }

            const groups = groupParts(parts);
            
            const scoredGroups = Object.entries(groups).map(([groupId, partList]) => {
                const bestScore = Math.max(...partList.map(p => getRelevanceScore(p, query)));
                return { groupId, partList, bestScore };
            });

            scoredGroups.sort((a, b) => {
                if (b.bestScore !== a.bestScore) return b.bestScore - a.bestScore;
                return partRelevanceComparator(a.partList[0], b.partList[0]);
            });

            const sortedGroups = {};
            scoredGroups.forEach(g => {
                if (g.bestScore > 0) { // Only include groups that match the search
                    sortedGroups[g.groupId] = g.partList;
                }
            });
            state.searchResultGroups = sortedGroups;

        } catch (error) {
            console.error("Rebrickable search failed:", error);
            state.apiError = error.message;
            state.searchResultGroups = {};
        } finally {
            state.isLoading = false;
            updateUI();
        }
    }
    
    async function fetchSets() {
        state.isLoading = true;
        state.apiError = null;
        state.setResults = null;
        state.searchSetResults = null;
        state.itemsToDisplay = state.itemsIncrement;
        state.isGridStale = true;
        updateUI();

        try {
            let params = new URLSearchParams();
            
            if (state.searchQuery) {
                params.append('search', state.searchQuery);
            } else if (state.selectedThemeId) {
                params.append('theme_id', state.selectedThemeId);
            } else {
                 state.isLoading = false;
                 updateUI();
                 return;
            }

            if(state.setFilters.minYear) params.append('min_year', state.setFilters.minYear);
            if(state.setFilters.maxYear) params.append('max_year', state.setFilters.maxYear);
            if(state.setFilters.minParts) params.append('min_parts', state.setFilters.minParts);
            if(state.setFilters.maxParts) params.append('max_parts', state.setFilters.maxParts);
            
            let ordering;
            if (state.sortBy === 'alpha_asc') ordering = 'name';
            else if (state.sortBy === 'alpha_desc') ordering = '-name';
            else if (state.sortBy === 'year_asc') ordering = 'year';
            else if (state.sortBy === 'year_desc') ordering = '-year';
            else if (state.sortBy === 'parts_asc') ordering = 'num_parts';
            else if (state.sortBy === 'parts_desc') ordering = '-num_parts';
            
            if(ordering) params.append('ordering', ordering);

            const rawSets = await apiFetchPaginated(`/sets/?${params.toString()}`);
            const sets = rawSets.map(s => {
                SET_MAP[s.set_num] = s;
                return s;
            });
            
            if (state.searchQuery) {
                state.searchSetResults = sets;
            } else {
                state.setResults = sets;
            }

        } catch (error) {
            console.error("Ошибка загрузки наборов Rebrickable:", error);
            state.apiError = error.message;
        } finally {
            state.isLoading = false;
            updateUI();
        }
    }
    
    async function fetchMinifigs() {
        state.isLoading = true;
        state.apiError = null;
        state.itemsToDisplay = state.itemsIncrement; // Use current increment (20 for minifigs)
        state.isGridStale = true;
        updateUI(); // Show loader

        try {
            let params = new URLSearchParams();
            
            if (state.searchQuery) {
                params.append('search', state.searchQuery);
            }

            let ordering;
            if (state.sortBy === 'name_asc') ordering = 'name';
            else if (state.sortBy === 'name_desc') ordering = '-name';
            else if (state.sortBy === 'num_parts_desc') ordering = '-num_parts';
            else if (state.sortBy === 'num_parts_asc') ordering = 'num_parts';
            
            if(ordering && state.sortBy !== 'relevance') params.append('ordering', ordering);

            const rawMinifigs = await apiFetchPaginated(`/minifigs/?${params.toString()}`);
            const minifigs = rawMinifigs.map(mf => {
                MINIFIG_MAP[mf.set_num] = mf;
                return mf;
            });
            
            if (state.searchQuery) {
                state.searchMinifigResults = minifigs;
                state.minifigResults = null;
            } else {
                state.minifigResults = minifigs;
                state.searchMinifigResults = null;
            }

        } catch (error) {
            console.error("Ошибка загрузки минифигурок Rebrickable:", error);
            state.apiError = error.message;
        } finally {
            state.isLoading = false;
            updateUI();
        }
    }

    async function fetchPartColors(partId) {
        state.modal.isLoadingColors = true;
        updateModalPartially({ colors: true });
        
        try {
            const colorAvailability = await apiFetchPaginated(`/parts/${partId}/colors/`);
            const colorIds = colorAvailability.map(c => String(c.color_id));

            PART_MAP[partId].availableColorIds = colorIds;
            if (colorIds.length > 0 && (!state.modal.selectedColorId || !colorIds.includes(state.modal.selectedColorId))) {
                const sortedColorIds = sortColorIds(colorIds, partId);
                state.modal.selectedColorId = sortedColorIds[0];
            }
        } catch (error) {
            console.error(`Failed to fetch colors for ${partId}:`, error);
            if(!PART_MAP[partId]) PART_MAP[partId] = {};
            PART_MAP[partId].availableColorIds = PART_MAP[partId].availableColorIds || [];
        } finally {
            state.modal.isLoadingColors = false;
            updateModalPartially({ colors: true, controls: true });

            if (state.modal.selectedColorId) {
                fetchPartColorSpecifics(partId, state.modal.selectedColorId);
            }
        }
    }
    
    async function fetchPartColorSpecifics(partId, colorId) {
        state.modal.isImageLoading = true;
        updateModalPartially({ image: true });

        try {
            const url = `${REBRICKABLE_API_URL}/parts/${partId}/colors/${colorId}/`;
            const response = await fetch(url, { headers: { 'Authorization': `key ${getApiKey()}` } });
            if (!response.ok) throw new Error('Image not found for this color.');
            const data = await response.json();
            
            state.modal.partImageUrl = data.part_img_url || PART_MAP[partId]?.rebrickable_img_url;
        } catch (error) {
            console.warn(`Could not fetch color-specific image:`, error);
            state.modal.partImageUrl = PART_MAP[partId]?.rebrickable_img_url;
        } finally {
            state.modal.isImageLoading = false;
            updateModalPartially({ image: true });
        }
    }

    async function fetchColorDetailsForPart(partId) {
        if (PART_MAP[partId]?.colorImages) return;
    
        try {
            const colorAvailability = await apiFetchPaginated(`/parts/${partId}/colors/`);
            if (!PART_MAP[partId]) PART_MAP[partId] = { id: partId };
            
            const colorImages = {};
            (colorAvailability || []).forEach(colorInfo => {
                if (colorInfo.part_img_url) {
                    colorImages[String(colorInfo.color_id)] = colorInfo.part_img_url;
                }
            });
            PART_MAP[partId].colorImages = colorImages;
    
        } catch (error) {
            console.warn(`Could not fetch color details for part ${partId}:`, error);
        }
    }
    
    async function fetchColorDetailsForCollectionParts() {
        const collectionPartIds = Object.keys(state.collection);
        const partsToFetch = collectionPartIds.filter(id => !PART_MAP[id]?.colorImages);
        
        if (partsToFetch.length === 0) return;
        console.log(`Fetching color-specific images for ${partsToFetch.length} parts from collection...`);
    
        const BATCH_SIZE = 20;
        for (let i = 0; i < partsToFetch.length; i += BATCH_SIZE) {
            const batch = partsToFetch.slice(i, i + BATCH_SIZE);
            const promises = batch.map(partId => fetchColorDetailsForPart(partId));
            await Promise.all(promises);
        }
    }

    async function fetchMissingCollectionPartDetails() {
      const collectionPartIds = Object.keys(state.collection);
      const missingPartIds = collectionPartIds.filter(id => !PART_MAP[id] || !PART_MAP[id].name);
      if (missingPartIds.length === 0) return;

      console.log(`Fetching details for ${missingPartIds.length} parts from collection...`);
      
      const BATCH_SIZE = 100;
      for (let i = 0; i < missingPartIds.length; i += BATCH_SIZE) {
          const batch = missingPartIds.slice(i, i + BATCH_SIZE);
          try {
            const rawParts = await apiFetchPaginated(`/parts/?part_nums=${batch.join(',')}`);
            rawParts.map(processPartData).filter(Boolean);
          } catch(err) {
            console.error(`Could not fetch details for batch starting with part ${batch[0]}:`, err);
            state.apiError = (state.apiError ? state.apiError + '\n' : '') + 'Не удалось загрузить данные для некоторых деталей коллекции.';
          }
      }
    }
    
    async function fetchMissingCollectionSetDetails() {
        const collectionSetNums = Object.keys(state.setCollection);
        const missingSetNums = collectionSetNums.filter(num => !SET_MAP[num] || !SET_MAP[num].name);
        if (missingSetNums.length === 0) return;

        console.log(`Fetching details for ${missingSetNums.length} sets from collection...`);
        
        for (const setNum of missingSetNums) {
            try {
                const response = await fetch(`${REBRICKABLE_API_URL}/sets/${setNum}/`, {
                    headers: { 'Authorization': `key ${getApiKey()}` }
                });
                if (!response.ok) throw new Error(`Set ${setNum} not found.`);
                const set = await response.json();
                SET_MAP[set.set_num] = set;
                await new Promise(resolve => setTimeout(resolve, 200)); // Small delay between fetches
            } catch(err) {
                console.error(`Could not fetch details for set ${setNum}:`, err);
            }
        }
    }

    async function fetchMinifigDetails(figNum) {
        if (MINIFIG_MAP[figNum]) return;
        try {
            const response = await fetch(`${REBRICKABLE_API_URL}/minifigs/${figNum}/`, {
                headers: { 'Authorization': `key ${getApiKey()}` }
            });
            if (!response.ok) throw new Error(`Minifig ${figNum} not found.`);
            const minifig = await response.json();
            MINIFIG_MAP[minifig.set_num] = minifig;
        } catch (err) {
            console.error(`Could not fetch details for minifig ${figNum}:`, err);
        }
    }

    async function fetchMissingCollectionMinifigDetails() {
        const collectionFigNums = Object.keys(state.minifigCollection);
        const missingFigNums = collectionFigNums.filter(num => !MINIFIG_MAP[num] || !MINIFIG_MAP[num].name);
        if (missingFigNums.length === 0) return;

        console.log(`Fetching details for ${missingFigNums.length} minifigs from collection...`);
        
        for (const figNum of missingFigNums) {
            await fetchMinifigDetails(figNum);
            await new Promise(resolve => setTimeout(resolve, 200));
        }
    }

    async function fetchSetInventory(setNum, page = 1) {
        state.setModal.isLoading = true;
        if (page === 1) {
            state.setModal.inventory = [];
        }
        updateSetModalView();

        try {
            const endpoint = `/sets/${setNum}/parts/?page=${page}&page_size=50`; // Use smaller page size for modal
            const response = await fetch(`${REBRICKABLE_API_URL}${endpoint}`, {
                headers: { 'Authorization': `key ${getApiKey()}` }
            });
            if (!response.ok) throw new Error('Could not fetch set inventory');
            const data = await response.json();
            
            const inventoryItems = (data.results || []).map(item => {
                processPartData(item.part);
                const colorIdStr = String(item.color.id);
                if (!COLOR_MAP[colorIdStr]) {
                     COLOR_MAP[colorIdStr] = {
                        id: colorIdStr,
                        name: item.color.name,
                        hex: `#${item.color.rgb}`,
                        isTransparent: item.color.is_trans,
                    };
                }
                return {
                    part: item.part,
                    color: COLOR_MAP[colorIdStr],
                    quantity: item.quantity,
                    is_spare: item.is_spare,
                    element_id: item.element_id,
                };
            }).filter(item => !item.is_spare);

            state.setModal.inventory = [...state.setModal.inventory, ...inventoryItems];
            state.setModal.inventoryPage = page;
            state.setModal.hasNextInventoryPage = !!data.next;
            
        } catch (error) {
             console.error(`Failed to fetch inventory for ${setNum}:`, error);
        } finally {
             state.setModal.isLoading = false;
             if (state.selectedSetNum) {
                 updateSetModalView();
             }
        }
    }
    
    async function fetchAllSetInventory(setNum) {
        let allResults = [];
        let page = 1;
        const PAGE_SIZE = 500;

        while (true) {
            const endpoint = `/sets/${setNum}/parts/?page=${page}&page_size=${PAGE_SIZE}`;
            const response = await fetch(`${REBRICKABLE_API_URL}${endpoint}`, {
                headers: { 'Authorization': `key ${getApiKey()}` }
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ detail: 'Не удалось получить детали ошибки.' }));
                throw new Error(`Ошибка API Rebrickable: ${response.status} - ${errorData.detail}`);
            }

            const data = await response.json();
            const inventoryItems = (data.results || []).map(item => {
                processPartData(item.part);
                const colorIdStr = String(item.color.id);
                if (!COLOR_MAP[colorIdStr]) {
                     COLOR_MAP[colorIdStr] = {
                        id: colorIdStr,
                        name: item.color.name,
                        hex: `#${item.color.rgb}`,
                        isTransparent: item.color.is_trans,
                    };
                }
                return {
                    part: item.part,
                    color: COLOR_MAP[colorIdStr],
                    quantity: item.quantity,
                    is_spare: item.is_spare,
                };
            }).filter(item => !item.is_spare);

            if (inventoryItems.length > 0) {
                allResults = allResults.concat(inventoryItems);
            }
            
            if (!data.next) break;
            page++;
            await new Promise(resolve => setTimeout(resolve, 1100)); // Prevent API rate limiting
        }
        return allResults;
    }

    async function fetchSetMinifigs(setNum) {
        state.setModal.areMinifigsLoading = true;
        updateSetModalView(); // Show loader

        try {
            const minifigs = await apiFetchPaginated(`/sets/${setNum}/minifigs/`);
            state.setModal.minifigs = (minifigs || []).map(mf => ({
                ...mf,
                isExpanded: false,
                isLoadingParts: false,
                parts: null, // Use null to indicate not fetched yet
            }));
        } catch (error) {
            console.error(`Failed to fetch minifigs for set ${setNum}:`, error);
            state.setModal.minifigs = [];
        } finally {
            state.setModal.areMinifigsLoading = false;
            if (state.selectedSetNum) { // Check if modal is still open
                updateSetModalView();
            }
        }
    }

    async function fetchMinifigParts(figNum) {
        try {
            const partInventory = await apiFetchPaginated(`/minifigs/${figNum}/parts/`);
            return (partInventory || []).map(item => {
                processPartData(item.part);
                const colorIdStr = String(item.color.id);
                if (!COLOR_MAP[colorIdStr]) {
                     COLOR_MAP[colorIdStr] = {
                        id: colorIdStr,
                        name: item.color.name,
                        hex: `#${item.color.rgb}`,
                        isTransparent: item.color.is_trans,
                    };
                }
                return {
                    ...item,
                    color: COLOR_MAP[colorIdStr],
                };
            });
        } catch (error) {
            console.error(`Failed to fetch parts for minifig ${figNum}:`, error);
            return [];
        }
    }

    async function handleFeelingLucky() {
      state.isLoading = true;
      state.apiError = null;
      state.isGridStale = true;
      updateUI();
      try {
        let randomItem;
        if (state.activeSubView === 'parts') {
            if (flatCategories.length === 0) throw new Error("Категории еще не загружены.");
            const randomCategory = flatCategories[Math.floor(Math.random() * flatCategories.length)];
            const rawParts = await apiFetchPaginated(`/parts/?part_cat_id=${randomCategory.id}&page_size=100`);
            if (rawParts.length === 0) { return handleFeelingLucky(); } // Try again
            randomItem = rawParts[Math.floor(Math.random() * rawParts.length)];
            const part = processPartData(randomItem);
            if (!part) throw new Error("Не удалось выбрать случайную деталь.");
            const groupId = getGroupId(part.part_num);
            openModalForPart(part.id, groupId, [part]);
        } else if (state.activeSubView === 'sets') {
            const themeIds = Object.keys(THEME_MAP);
            if (themeIds.length === 0) throw new Error("Темы еще не загружены.");
            let attempts = 0;
            while(attempts < 10) {
                const randomThemeId = themeIds[Math.floor(Math.random() * themeIds.length)];
                const rawSets = await apiFetchPaginated(`/sets/?theme_id=${randomThemeId}&page_size=100`);
                if (rawSets.length > 0) {
                    randomItem = rawSets[Math.floor(Math.random() * rawSets.length)];
                    SET_MAP[randomItem.set_num] = randomItem;
                    openModalForSet(randomItem.set_num);
                    state.isLoading = false;
                    updateUI();
                    return;
                }
                attempts++;
            }
            throw new Error("Не удалось найти случайный набор.");
        } else { // minifigs
            const rawMinifigs = await apiFetchPaginated(`/minifigs/?page_size=200`);
            if (rawMinifigs.length === 0) throw new Error("Не удалось загрузить минифигурки.");
            randomItem = rawMinifigs[Math.floor(Math.random() * rawMinifigs.length)];
            MINIFIG_MAP[randomItem.set_num] = randomItem;
            openModalForMinifig(randomItem.set_num);
        }
      } catch (error) {
        console.error("Feeling lucky failed:", error);
        state.apiError = `Не удалось совершить чудо: ${error.message}`;
      } finally {
        state.isLoading = false;
        updateUI();
      }
    }

    // --- UTILITY FUNCTIONS ---
    function getPartImageUrl(url) {
        const placeholderSvg = `data:image/svg+xml,${encodeURIComponent(ImageIcon('w-full h-full text-gray-500'))}`;
        if (url) {
            return `src="${url}" onerror="this.onerror=null; this.src='${placeholderSvg}';"`;
        }
        return `src="${placeholderSvg}"`;
    }

    function sortColorIds(colorIds, partId) {
        const BASIC_COLOR_IDS = ['0', '15', '4', '1', '14', '2', '71', '72', '88', '19', '5', '34']; // Black, White, Red, Blue, Yellow, Green, LBG, DBG, Reddish Brown, Tan, Orange, Lime
        
        const partCollectionColors = Object.keys(state.collection[partId] || {});

        return [...colorIds].sort((a, b) => {
            const aIsBasic = BASIC_COLOR_IDS.includes(a);
            const bIsBasic = BASIC_COLOR_IDS.includes(b);
            if (aIsBasic && !bIsBasic) return -1;
            if (!aIsBasic && bIsBasic) return 1;

            const aInCollection = partCollectionColors.includes(a);
            const bInCollection = partCollectionColors.includes(b);
            if (aInCollection && !bInCollection) return -1;
            if (!aInCollection && bInCollection) return 1;
            
            const colorA = COLOR_MAP[a];
            const colorB = COLOR_MAP[b];
            if (colorA && colorB) {
                return colorA.name.localeCompare(b.name);
            }

            return 0;
        });
    }

    function getPluralizedColorString(count) {
        const n = Math.abs(count);
        const lastDigit = n % 10;
        const lastTwoDigits = n % 100;

        if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
            return 'цветов';
        }
        if (lastDigit === 1) {
            return 'цвет';
        }
        if ([2, 3, 4].includes(lastDigit)) {
            return 'цвета';
        }
        return 'цветов';
    }

    // --- RENDER FUNCTIONS ---
    const CATEGORY_ICONS = {
        'Bricks': BrickIcon,
        'Plates': PlateIcon,
        'Technic': TechnicIcon,
        'Slopes & Wedges': SlopeIcon,
        'Tiles': TileIcon,
        'Panels, Doors & Windows': WindowIcon,
        'Wheels & Tyres': WheelIcon,
        'Minifig': MinifigIcon,
        'Bars, Hinges & Connectors': BarIcon,
        'Arches & Curves': ArchIcon,
        'Other': OtherIcon,
    };
    
    function filterThemeTreeForCollection(nodes, collectedThemeIds) {
        if (!Array.isArray(nodes)) return [];
        return nodes.map(node => {
            if (!node || !node.id) return null;
            const filteredChildren = Array.isArray(node.children) && node.children.length > 0
                ? filterThemeTreeForCollection(node.children, collectedThemeIds)
                : [];
            
            if (collectedThemeIds.has(node.id) || filteredChildren.length > 0) {
                return { ...node, children: filteredChildren };
            }
            
            return null;
        }).filter(Boolean);
    }

    function renderSidebar() {
      const { totalPartsCount, uniqueModelsCount } = Object.keys(state.collection).reduce((acc, partId) => {
        const colors = state.collection[partId] || {};
        const colorKeys = Object.keys(colors);
        if (colorKeys.length > 0) {
            acc.uniqueModelsCount += colorKeys.length;
            acc.totalPartsCount += Object.values(colors).reduce((sum, q) => sum + q, 0);
        }
        return acc;
      }, { uniqueModelsCount: 0, totalPartsCount: 0 });

      const totalSetsCount = Object.values(state.setCollection).reduce((sum, set) => sum + set.quantity, 0);
      const uniqueSetsCount = Object.keys(state.setCollection).length;

      const totalMinifigsCount = Object.values(state.minifigCollection).reduce((sum, fig) => sum + fig.quantity, 0);
      const uniqueMinifigsCount = Object.keys(state.minifigCollection).length;

      const viewButtonStyle = (view) => `flex items-center w-full p-3 text-base font-semibold rounded-lg transition-colors duration-150 ${state.currentView === view ? 'bg-blue-600 text-white' : 'text-gray-400 hover:bg-gray-700 hover:text-white'}`;
      
      const subViewButtonStyle = (subView) => `relative flex-1 py-2 px-1 rounded-lg text-sm font-semibold transition-colors duration-200 flex flex-col items-center justify-center gap-1 ${state.activeSubView === subView ? 'bg-blue-600 text-white' : 'text-gray-300 hover:bg-gray-700 hover:text-white'}`;

      const badge = (subView, count) => {
            if (count === 0) return '';
            const style = `absolute top-1 right-1 text-xs px-1.5 py-0.5 rounded-full font-bold ${state.activeSubView === subView ? 'bg-blue-200 text-blue-800' : 'bg-gray-600 text-gray-200'}`;
            return `<span class="${style}">${count}</span>`;
      };


      let mainListContent = '';
      let mainListTitle = '';
      
      if (state.activeSubView === 'sets') {
        mainListTitle = 'Темы';
        let themesToRender = state.themeTree;
        let allItemsButtonHtml = '';
        
        if (state.currentView === 'collection') {
            const isSelected = state.selectedSetCollectionThemeId === null;
            const buttonStyle = isSelected ? 'bg-blue-600 text-white' : 'text-gray-300 hover:bg-gray-700 hover:text-white';
            allItemsButtonHtml = `
              <li>
                <button data-action="show-all-collection-items" class="w-full text-left flex items-center p-2 rounded-md transition-colors duration-150 ${buttonStyle}">
                  <span class="truncate">Все наборы</span>
                </button>
              </li>
            `;
            const collectedThemeIds = new Set();
            Object.keys(state.setCollection).forEach(setNum => {
                const theme = SET_MAP[setNum];
                if (theme && theme.theme_id) {
                    let currentThemeId = theme.theme_id;
                    while(currentThemeId) {
                        collectedThemeIds.add(currentThemeId);
                        currentThemeId = THEME_MAP[currentThemeId]?.parent_id;
                    }
                }
            });
            themesToRender = filterThemeTreeForCollection(state.themeTree, collectedThemeIds);
        }

        const sortThemesWithFavorites = (nodes) => {
            if (!Array.isArray(nodes)) return [];
            nodes.forEach(node => {
                if (node && Array.isArray(node.children)) {
                    sortThemesWithFavorites(node.children);
                }
            });
            nodes.sort((a, b) => {
                const aIsFav = state.favoriteThemeIds.has(a.id);
                const bIsFav = state.favoriteThemeIds.has(b.id);
                if (aIsFav && !bIsFav) return -1;
                if (!aIsFav && bIsFav) return 1;
                return a.name.localeCompare(b.name);
            });
            return nodes;
        };
        sortThemesWithFavorites(themesToRender);

        const renderThemeTree = (nodes, depth = 0) => {
            if (!Array.isArray(nodes)) return '';
            return nodes.map(theme => {
                if(!theme) return '';
                const isExpanded = state.expandedThemes.has(theme.id);
                const isSelected = (state.currentView === 'catalog' && state.selectedThemeId === theme.id) || (state.currentView === 'collection' && state.selectedSetCollectionThemeId === theme.id);
                const buttonStyle = isSelected ? 'bg-blue-600/80 text-white' : 'text-gray-400 hover:bg-gray-700/50 hover:text-gray-200';
                const childrenHtml = Array.isArray(theme.children) && theme.children.length > 0 ? `<ul class="space-y-1 ${isExpanded ? '' : 'hidden'}">${renderThemeTree(theme.children, depth + 1)}</ul>` : '';
                
                const isFav = state.favoriteThemeIds.has(theme.id);
                const heartClasses = isFav
                    ? 'text-red-400 opacity-100'
                    : 'text-gray-500 opacity-0 group-hover:opacity-100';

                return `
                    <li class="space-y-1">
                        <button data-theme-id="${theme.id}" class="w-full text-left flex items-center justify-between p-2 rounded-md transition-colors duration-150 ${buttonStyle} group" style="padding-left: ${0.5 + depth * 1.5}rem;">
                            <span class="truncate flex-grow">${theme.name}</span>
                            <div class="flex items-center flex-shrink-0">
                                <span data-action="toggle-favorite-theme" data-theme-id="${theme.id}" class="p-1 rounded-full hover:bg-gray-600 hover:text-red-400 transition-opacity z-10 mr-1 ${heartClasses}" aria-label="Добавить в избранное">
                                    ${HeartIcon('w-4 h-4', isFav)}
                                </span>
                                ${Array.isArray(theme.children) && theme.children.length > 0 ? ChevronDownIcon(`w-5 h-5 text-gray-400 transform transition-transform duration-200 flex-shrink-0 ${isExpanded ? 'rotate-180' : ''}`) : ''}
                            </div>
                        </button>
                        ${childrenHtml}
                    </li>
                `;
            }).join('');
        };

        if (state.isLoading && state.themeTree.length === 0) {
            mainListContent = `<div class="flex items-center justify-center p-4"><div class="loader !w-6 !h-6"></div></div>`;
        } else {
            mainListContent = allItemsButtonHtml + renderThemeTree(themesToRender);
        }
      } else if (state.activeSubView === 'minifigs') {
        mainListTitle = 'Минифигурки';
        mainListContent = `<li class="text-gray-400 text-sm p-2">Используйте поиск или просмотрите каталог.</li>`;
      } else { // 'parts'
        mainListTitle = 'Категории';
        let categoriesToRender = state.categoryTree;
        let allItemsButtonHtml = '';

        if (state.currentView === 'collection') {
            const isSelected = state.selectedCollectionCategoryId === null;
            const buttonStyle = isSelected ? 'bg-blue-600 text-white' : 'text-gray-300 hover:bg-gray-700 hover:text-white';
            allItemsButtonHtml = `
              <li>
                <button data-action="show-all-collection-items" class="w-full text-left flex items-center p-2 rounded-md transition-colors duration-150 ${buttonStyle}">
                  <span class="truncate">Все детали</span>
                </button>
              </li>
            `;

            const collectionCategoryIds = new Set(
                Object.keys(state.collection)
                    .map(partId => PART_MAP[partId]?.categoryId)
                    .filter(id => id !== undefined && id !== null)
            );
            
            categoriesToRender = JSON.parse(JSON.stringify(state.categoryTree)); // Deep copy
            categoriesToRender = categoriesToRender.map(group => {
                if (Array.isArray(group.children)) {
                    group.children = group.children.filter(cat => collectionCategoryIds.has(cat.id));
                }
                return group;
            }).filter(group => Array.isArray(group.children) && group.children.length > 0);
        }
        
        if (state.isLoading && state.categoryTree.length === 0) {
            mainListContent = `<div class="flex items-center justify-center p-4"><div class="loader !w-6 !h-6"></div></div>`;
        } else if (state.currentView === 'collection' && Object.keys(state.collection).length > 0 && categoriesToRender.length === 0) {
            mainListContent = `<li class="text-gray-400 text-sm p-2">Нет деталей в категориях.</li>`;
        } else {
             categoriesToRender.forEach(group => {
                if (Array.isArray(group.children)) {
                    group.children.sort((a, b) => {
                        const aIsFav = state.favoriteCategoryIds.has(a.id);
                        const bIsFav = state.favoriteCategoryIds.has(b.id);
                        if (aIsFav && !bIsFav) return -1;
                        if (!aIsFav && bIsFav) return 1;
                        return a.name.localeCompare(b.name);
                    });
                }
             });

             mainListContent = allItemsButtonHtml + categoriesToRender.map(group => {
              const isExpanded = state.expandedCategories.has(group.name);
              const childList = group.children.map(cat => {
                   const isSelected = (state.currentView === 'catalog' && state.selectedCategoryId === cat.id) || (state.currentView === 'collection' && state.selectedCollectionCategoryId === cat.id);
                   const buttonStyle = isSelected ? 'bg-blue-600/80 text-white' : 'text-gray-400 hover:bg-gray-700/50 hover:text-gray-200';
                   const isFav = state.favoriteCategoryIds.has(cat.id);
                   const heartClasses = isFav ? 'text-red-400 opacity-100' : 'text-gray-500 opacity-0 group-hover:opacity-100';

                   return `
                      <li>
                          <button data-category-id="${cat.id}" class="w-full text-left flex items-center justify-between p-2 pl-11 rounded-md transition-colors duration-150 ${buttonStyle} group">
                            <span class="truncate">${cat.name}</span>
                            <span data-action="toggle-favorite-category" data-category-id="${cat.id}" class="p-1 rounded-full hover:bg-gray-600 hover:text-red-400 transition-opacity z-10 ${heartClasses}" aria-label="Добавить в избранное">
                                ${HeartIcon('w-4 h-4', isFav)}
                            </span>
                          </button>
                      </li>
                   `;
              }).join('');
              
              const IconComponent = CATEGORY_ICONS[group.name] || OtherIcon;
              const iconHtml = IconComponent('w-5 h-5 mr-3 text-gray-400 flex-shrink-0');

              return `
                  <li class="space-y-1">
                      <button data-parent-category="${group.name}" class="w-full text-left flex items-center justify-between p-2 rounded-md hover:bg-gray-700 transition-colors duration-150">
                          <div class="flex items-center truncate">
                            ${iconHtml}
                            <span class="font-semibold text-gray-200 truncate">${group.name}</span>
                          </div>
                          ${ChevronDownIcon(`w-5 h-5 text-gray-400 transform transition-transform duration-200 ${isExpanded ? 'rotate-180' : ''}`)}
                      </button>
                      <ul class="space-y-1 ${isExpanded ? '' : 'hidden'}">
                          ${childList}
                      </ul>
                  </li>
              `;
            }).join('');
        }
      }

      sidebarContainer.innerHTML = `
        <div class="flex items-center justify-between mb-4 flex-shrink-0">
          <h1 class="text-xl font-bold text-white">Меню</h1>
          <button id="sidebar-close" class="lg:hidden text-gray-400 hover:text-white p-1">
            ${XIcon('w-6 h-6')}
          </button>
        </div>

        <div class="space-y-2 mb-4 flex-shrink-0">
            <button data-view="catalog" class="${viewButtonStyle('catalog')}">${CatalogIcon('w-5 h-5 mr-3')}<span>Каталог</span></button>
            <button data-view="collection" class="${viewButtonStyle('collection')}">${CollectionIcon('w-5 h-5 mr-3')}<span>Коллекция</span></button>
        </div>

        <div class="mb-4 p-1 bg-gray-900/50 rounded-xl grid grid-cols-3 gap-1">
            <button data-sub-view="parts" class="${subViewButtonStyle('parts')}">
                ${BrickIcon('w-5 h-5')}
                <span class="mt-1">Детали</span>
                ${badge('parts', uniqueModelsCount)}
            </button>
            <button data-sub-view="sets" class="${subViewButtonStyle('sets')}">
                ${SetsIcon('w-5 h-5')}
                <span class="mt-1">Наборы</span>
                ${badge('sets', uniqueSetsCount)}
            </button>
            <button data-sub-view="minifigs" class="${subViewButtonStyle('minifigs')}">
                ${MinifigIcon('w-5 h-5')}
                <span class="mt-1">Фигурки</span>
                ${badge('minifigs', uniqueMinifigsCount)}
            </button>
        </div>
        
        <div id="sidebar-scroll-container" class="flex-grow overflow-y-auto no-scrollbar">
          <h2 class="text-lg font-semibold text-white mb-3">${mainListTitle}</h2>
          <nav>
            <ul id="category-list" class="space-y-1">${mainListContent}</ul>
          </nav>
        </div>
        
        <div class="flex-shrink-0 mt-4 border-t border-gray-700 pt-4 space-y-4">
            ${state.currentView === 'collection' ? `
            <div>
                <h2 class="text-lg font-semibold text-white mb-3">Сводка коллекции</h2>
                ${totalPartsCount === 0 && uniqueSetsCount === 0 && uniqueMinifigsCount === 0 ? '<p class="text-gray-400 text-sm">Ваша коллекция пуста.</p>' : `
                  <div class="space-y-1">
                      <div class="flex justify-between items-center text-sm text-gray-400">
                          <span>${BrickIcon('inline-block w-4 h-4 mr-1')} Детали</span>
                          <span class="font-semibold text-white">${uniqueModelsCount} уник. / ${totalPartsCount} всего</span>
                      </div>
                      <div class="flex justify-between items-center text-sm text-gray-400">
                          <span>${SetsIcon('inline-block w-4 h-4 mr-1')} Наборы</span>
                          <span class="font-semibold text-white">${uniqueSetsCount} уник. / ${totalSetsCount} всего</span>
                      </div>
                       <div class="flex justify-between items-center text-sm text-gray-400">
                          <span>${MinifigIcon('inline-block w-4 h-4 mr-1')} Минифигурки</span>
                          <span class="font-semibold text-white">${uniqueMinifigsCount} уник. / ${totalMinifigsCount} всего</span>
                      </div>
                  </div>
                `}
            </div>
            ` : ''}
            <button id="settings-button" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-600 hover:bg-gray-500 text-white">
                ${SettingsIcon('w-5 h-5 mr-2')} Настройки
            </button>
        </div>
      `;
    }

    function renderHeader() {
        const { activeSubView } = state;
        let placeholder = "Поиск по ID или названию...";
        if (activeSubView === 'sets') placeholder = "Поиск по наборам...";
        if (activeSubView === 'minifigs') placeholder = "Поиск по минифигуркам...";

        headerContainer.innerHTML = `
            <div class="flex justify-between items-center gap-4">
                <div class="flex items-center">
                    <button id="sidebar-toggle" class="lg:hidden text-gray-300 hover:text-white mr-4 -ml-1 p-1">
                        ${MenuIcon('w-6 h-6')}
                    </button>
                    <h1 class="text-xl font-bold text-white hidden sm:block">LEGO® Catalog</h1>
                </div>
                <div class="flex items-center space-x-2 w-full max-w-sm">
                    <div class="relative flex-grow">
                        <input id="search-input" type="search" placeholder="${placeholder}" value="${state.searchQuery}" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 pl-4 pr-10 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"/>
                        <button id="clear-search" class="absolute inset-y-0 right-0 flex items-center pr-3 text-gray-400 hover:text-white ${!state.searchQuery ? 'hidden' : ''}">${XIcon('w-5 h-5')}</button>
                    </div>
                     <button id="search-button" class="p-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors flex-shrink-0" aria-label="Поиск">
                        ${SearchIcon('w-5 h-5')}
                    </button>
                    <button id="filter-button" class="p-2 bg-gray-600 text-white rounded-md hover:bg-gray-500 transition-colors flex-shrink-0" aria-label="Фильтры">
                        ${FilterIcon('w-5 h-5')}
                    </button>
                </div>
            </div>
        `;
    }

    function renderSetCard(set, shouldAnimate, index = 0) {
        if (!set) return '';
        const animationClass = shouldAnimate ? 'animate-in' : '';
        const animationDelay = shouldAnimate ? `animation-delay: ${Math.min(index * 40, 1500)}ms;` : '';
        const collectionInfo = state.setCollection[set.set_num];
        const quantity = collectionInfo ? collectionInfo.quantity : 0;
        
        return `
            <div data-set-num="${set.set_num}" style="${animationDelay}" class="set-card ${animationClass} relative bg-gray-800 rounded-lg overflow-hidden group transform transition-all duration-300 hover:bg-gray-700 cursor-pointer hover:scale-105">
                ${quantity > 0 ? `<div class="absolute top-3 right-3 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md">${quantity}</div>` : ''}
                <div class="w-full h-40 bg-gray-700 flex items-center justify-center p-2 rounded-t-lg">
                    <div class="w-full h-full bg-white rounded-md flex items-center justify-center overflow-hidden shadow-inner">
                        <img ${getPartImageUrl(set.set_img_url)} alt="${set.name}" class="w-full h-full object-contain pointer-events-none" loading="lazy" />
                    </div>
                </div>
                <div class="p-4 space-y-1">
                    <h3 class="text-sm font-semibold text-white truncate pointer-events-none">${set.name}</h3>
                    <p class="text-xs text-gray-400 pointer-events-none">#${set.set_num} • ${set.year}</p>
                </div>
            </div>
        `;
    }

    function renderMinifigCard(minifig, shouldAnimate, index = 0) {
        if (!minifig) return '';
        const animationClass = shouldAnimate ? 'animate-in' : '';
        const animationDelay = shouldAnimate ? `animation-delay: ${Math.min(index * 40, 1500)}ms;` : '';
        const collectionInfo = state.minifigCollection[minifig.set_num];
        const quantity = collectionInfo ? collectionInfo.quantity : 0;
        
        return `
            <div data-fig-num="${minifig.set_num}" style="${animationDelay}" class="minifig-card ${animationClass} relative bg-gray-800 rounded-lg overflow-hidden group transform transition-all duration-300 hover:bg-gray-700 cursor-pointer hover:scale-105">
                ${quantity > 0 ? `<div class="absolute top-3 right-3 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md">${quantity}</div>` : ''}
                <div class="w-full h-40 bg-gray-700 flex items-center justify-center p-2 rounded-t-lg">
                    <div class="w-full h-full bg-white rounded-md flex items-center justify-center overflow-hidden shadow-inner">
                        <img ${getPartImageUrl(minifig.set_img_url)} alt="${minifig.name}" class="w-full h-full object-contain pointer-events-none" loading="lazy" />
                    </div>
                </div>
                <div class="p-4 space-y-1">
                    <h3 class="text-sm font-semibold text-white truncate pointer-events-none">${minifig.name}</h3>
                    <p class="text-xs text-gray-400 pointer-events-none">#${minifig.set_num}</p>
                </div>
            </div>
        `;
    }

    function renderPartCard(part, color, quantity, shouldAnimate, index = 0) {
        if (!part) return '';
        const isCollectionView = state.currentView === 'collection';
        const groupId = getGroupId(part.id);
        const animationClass = shouldAnimate ? 'animate-in' : '';
        const animationDelay = shouldAnimate ? `animation-delay: ${Math.min(index * 40, 1500)}ms;` : '';
        
        let quantityIndicator = '';
        if (quantity > 0) {
            const positionClass = isCollectionView ? 'left-3' : 'right-3';
            quantityIndicator = `<div class="absolute top-3 ${positionClass} bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md">${quantity}</div>`;
        }
        
        let imageUrl = part.rebrickable_img_url;
        if (isCollectionView && color) {
            const colorSpecificUrl = PART_MAP[part.id]?.colorImages?.[color.id];
            if (colorSpecificUrl) {
                imageUrl = colorSpecificUrl;
            }
        }

        return `
            <div data-group-id="${groupId}" data-part-id="${part.id}" ${isCollectionView ? `data-color-id="${color.id}"` : ''} style="${animationDelay}" class="part-card ${animationClass} relative bg-gray-800 rounded-lg overflow-hidden group transform transition-all duration-300 hover:bg-gray-700 cursor-pointer hover:scale-105">
                ${isCollectionView ? `
                    <button aria-label="Удалить ${part.name} (${color.name})" data-action="delete-from-collection" data-part-id="${part.id}" data-color-id="${color.id}" class="absolute top-3 right-3 bg-red-600 text-white p-1.5 rounded-full z-10 shadow-md transition-colors hover:bg-red-700 opacity-100 focus:opacity-100 md:opacity-0 md:group-hover:opacity-100">
                        ${TrashIcon('w-4 h-4')}
                    </button>
                ` : ''}
                ${quantityIndicator}
                <div class="w-full h-40 bg-gray-700 flex items-center justify-center p-2 rounded-t-lg">
                    <div class="w-full h-full bg-white rounded-md flex items-center justify-center overflow-hidden shadow-inner">
                        <img ${getPartImageUrl(imageUrl)} alt="${part.name}" class="w-full h-full object-contain pointer-events-none" loading="lazy" />
                    </div>
                </div>
                <div class="p-4 space-y-1">
                    <h3 class="text-sm font-semibold text-white truncate pointer-events-none">${part.name}</h3>
                    <p class="text-xs text-gray-400 pointer-events-none">ID: ${part.id}</p>
                    ${isCollectionView ? `
                        <div class="flex items-center pt-1 pointer-events-none">
                            <span class="w-4 h-4 rounded-full border border-gray-500 ${color.isTransparent ? 'checkerboard' : ''}" style="background-color: ${color.hex};"></span>
                            <span class="ml-2 text-xs text-gray-300 truncate">${color.name}</span>
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
    }

    function renderAppliedFilters() {
        let tags = '';
        let isDefaultSort = false;
        let showClearAll = false;
        
        if (state.activeSubView === 'sets') {
            const { minYear, maxYear, minParts, maxParts } = state.setFilters;
            const setFilterTags = [
                minYear && `Мин. год: ${minYear}`,
                maxYear && `Макс. год: ${maxYear}`,
                minParts && `Мин. деталей: ${minParts}`,
                maxParts && `Макс. деталей: ${maxParts}`,
            ].filter(Boolean).map(text => `
                <div class="flex items-center bg-green-900/50 text-green-200 rounded-full pl-3 pr-2 py-1 text-sm">
                    <span class="mr-2">${text}</span>
                </div>`).join('');
            
            const sortMap = { 'year_desc': 'Год (новые)', 'year_asc': 'Год (старые)', 'parts_desc': 'Детали (убыв.)', 'parts_asc': 'Детали (возр.)', 'alpha_asc': 'Алфавит (А-Я)', 'alpha_desc': 'Алфавит (Я-А)' };
            isDefaultSort = state.searchQuery ? state.sortBy === 'relevance' : state.sortBy === 'year_desc';
            const sortTag = !isDefaultSort && sortMap[state.sortBy] ? `
                <div class="flex items-center bg-gray-600 text-gray-200 rounded-full pl-3 pr-2 py-1 text-sm">
                    <span class="mr-2">Сортировка: ${sortMap[state.sortBy]}</span>
                </div>
            ` : '';

            tags = [sortTag, setFilterTags].filter(Boolean).join('');
            showClearAll = !isDefaultSort || minYear || maxYear || minParts || maxParts;
        } else if (state.activeSubView === 'minifigs') {
            const sortMap = { 'name_asc': 'Алфавит (А-Я)', 'name_desc': 'Алфавит (Я-А)', 'num_parts_desc': 'Кол-во деталей (убыв.)', 'num_parts_asc': 'Кол-во деталей (возр.)' };
            isDefaultSort = state.searchQuery ? state.sortBy === 'relevance' : state.sortBy === 'name_asc';
            const sortTag = !isDefaultSort && sortMap[state.sortBy] ? `
                <div class="flex items-center bg-gray-600 text-gray-200 rounded-full pl-3 pr-2 py-1 text-sm">
                    <span class="mr-2">Сортировка: ${sortMap[state.sortBy]}</span>
                </div>
            ` : '';
            tags = sortTag;
            showClearAll = !isDefaultSort;
        } else { // Parts views
            const { colorIds, inCollectionOnly } = state.filters;
            const colorTags = colorIds.map(colorId => {
                if (!COLOR_MAP[colorId]) return '';
                return `
                <div class="flex items-center bg-blue-900/50 text-blue-200 rounded-full pl-3 pr-2 py-1 text-sm">
                    <span class="mr-2">${COLOR_MAP[colorId].name}</span>
                    <button data-action="remove-filter" data-filter-type="color" data-color-id="${colorId}" class="text-blue-200 hover:bg-blue-500/50 rounded-full p-0.5">${XIcon('w-4 h-4')}</button>
                </div>
                `;
            }).join('');

            const collectionTag = inCollectionOnly && state.currentView === 'catalog' ? `
                <div class="flex items-center bg-green-900/50 text-green-200 rounded-full pl-3 pr-2 py-1 text-sm">
                    <span class="mr-2">В коллекции</span>
                    <button data-action="remove-filter" data-filter-type="inCollectionOnly" class="text-green-200 hover:bg-green-500/50 rounded-full p-0.5">${XIcon('w-4 h-4')}</button>
                </div>
            ` : '';

            const sortMap = { 'relevance': 'Релевантность', 'alpha_asc': 'Алфавит (А-Я)', 'alpha_desc': 'Алфавит (Я-А)', 'popularity': 'Популярность' };
            isDefaultSort = state.searchQuery ? state.sortBy === 'relevance' : state.sortBy === 'popularity';
            const sortTag = !isDefaultSort ? `
                <div class="flex items-center bg-gray-600 text-gray-200 rounded-full pl-3 pr-2 py-1 text-sm">
                    <span class="mr-2">Сортировка: ${sortMap[state.sortBy]}</span>
                    <button data-action="remove-filter" data-filter-type="sortBy" class="text-gray-200 hover:bg-gray-500/50 rounded-full p-0.5">${XIcon('w-4 h-4')}</button>
                </div>
            ` : '';
            
            tags = [sortTag, colorTags, collectionTag].filter(Boolean).join('');
            showClearAll = !isDefaultSort || colorIds.length > 0 || (inCollectionOnly && state.currentView === 'catalog');
        }

        if (!showClearAll) return '';

        return `
            <div class="px-4 pt-2 pb-0">
                <div class="flex items-center flex-wrap gap-2">
                    ${tags}
                    <button data-action="remove-all-filters" class="text-sm text-blue-400 hover:underline">Очистить все</button>
                </div>
            </div>
        `;
    }

    function renderMainContent() {
        let gridContent = '';
        
        if (state.isLoading) {
            gridContent = `<div class="flex flex-col items-center justify-center h-full p-8 text-center"><div class="loader"></div><p class="mt-4 text-gray-400">Загрузка...</p></div>`;
        } else if (state.apiError) {
            gridContent = `<div class="flex flex-col items-center justify-center h-full p-8 text-center text-red-400"><p class="font-semibold">Произошла ошибка</p><p class="text-sm mt-2">${state.apiError}</p></div>`;
        } else if (state.currentView === 'catalog') {
            let itemsToDisplay;
            let renderFn;
            let emptyMessage;
            let gridClass = 'grid-cols-[repeat(auto-fill,minmax(150px,1fr))]';
            
            if (state.activeSubView === 'parts') {
                let groupsToShow = {};
                emptyMessage = 'Выберите категорию, чтобы увидеть детали, или воспользуйтесь поиском.';
                if (state.filters.colorIds && state.filters.colorIds.length > 1) {
                    emptyMessage = 'Фильтрация по нескольким цветам в режиме "Каталог" не поддерживается. Пожалуйста, выберите один цвет или просмотрите свою "Коллекцию".';
                } else if (state.searchResultGroups !== null) {
                    groupsToShow = state.searchResultGroups;
                    emptyMessage = 'По вашему запросу ничего не найдено.';
                } else if (state.selectedCategoryId !== null) {
                    groupsToShow = state.catalogGroups;
                    emptyMessage = 'В этой категории нет деталей.';
                }
                let allItems = Object.values(groupsToShow).flat();
                switch(state.sortBy) {
                    case 'alpha_asc': allItems.sort((a, b) => a.name.localeCompare(b.name)); break;
                    case 'alpha_desc': allItems.sort((a, b) => b.name.localeCompare(a.name)); break;
                    case 'popularity': allItems.sort((a, b) => b.num_sets - a.num_sets); break;
                }
                groupsToShow = groupParts(allItems);
                const groupKeys = groupsToShow ? Object.keys(groupsToShow) : [];
                itemsToDisplay = groupKeys.map(key => groupsToShow[key][0]);
                renderFn = (item) => {
                    const totalQuantity = Object.values(state.collection[item.id] || {}).reduce((sum, q) => sum + q, 0);
                    return renderPartCard(item, null, totalQuantity, state.isGridStale);
                };
                gridClass = 'grid-cols-[repeat(auto-fill,minmax(130px,1fr))]';

            } else if (state.activeSubView === 'sets') {
                itemsToDisplay = state.searchQuery ? state.searchSetResults : state.setResults;
                renderFn = (item) => renderSetCard(item, state.isGridStale);
                emptyMessage = state.searchQuery ? 'По вашему запросу ничего не найдено.' : 'Выберите тему для просмотра наборов.';
            } else { // minifigs
                itemsToDisplay = state.searchQuery ? state.searchMinifigResults : state.minifigResults;
                renderFn = (item) => renderMinifigCard(item, state.isGridStale);
                emptyMessage = state.searchQuery ? 'По вашему запросу ничего не найдено.' : 'В каталоге нет минифигурок. Попробуйте поиск.';
            }

            if (!itemsToDisplay || itemsToDisplay.length === 0) {
                 gridContent = `
                    <div class="flex flex-col items-center justify-center h-full p-4 text-center">
                        <p class="text-gray-400 max-w-sm mb-6">${emptyMessage}</p>
                        <button id="feeling-lucky-button" class="flex items-center gap-3 bg-blue-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-blue-700 transition-all duration-200 transform hover:scale-105 shadow-lg">
                            ${DiceIcon('w-6 h-6')} Мне повезёт!
                        </button>
                    </div>`;
            } else {
                const itemsToRender = itemsToDisplay.slice(0, state.itemsToDisplay);
                gridContent = `<div class="grid ${gridClass} gap-4 p-4">
                    ${itemsToRender.map((item, index) => {
                        const card = renderFn(item);
                        // A bit of a hack to add index to the animation
                        return card.replace('class="part-card ', `style="animation-delay: ${Math.min(index * 40, 1500)}ms;" class="part-card `)
                                   .replace('class="set-card ', `style="animation-delay: ${Math.min(index * 40, 1500)}ms;" class="set-card `)
                                   .replace('class="minifig-card ', `style="animation-delay: ${Math.min(index * 40, 1500)}ms;" class="minifig-card `);
                    }).join('')}
                </div>`;
                if(itemsToDisplay.length > state.itemsToDisplay) {
                    gridContent += `<div class="p-4 text-center">
                        <button id="load-more-button" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 transition-colors">
                            Загрузить ещё
                        </button>
                    </div>`;
                }
            }
        } else { // Collection View
            let collectionItems = [];
            let renderFn;
            let emptyMsg = `В вашей коллекции нет ${state.activeSubView === 'parts' ? 'деталей' : state.activeSubView === 'sets' ? 'наборов' : 'минифигурок'}`;
            const query = state.searchQuery.trim().toLowerCase();
            let gridClass = 'grid-cols-[repeat(auto-fill,minmax(150px,1fr))]';

            if (state.activeSubView === 'parts') {
                for (const partId in state.collection) {
                  for (const colorId in state.collection[partId]) {
                    const part = PART_MAP[partId];
                    const color = COLOR_MAP[colorId];
                    const quantity = state.collection[partId][colorId];
                    if (part && color && quantity > 0) {
                      collectionItems.push({ part, color, quantity });
                    }
                  }
                }
                if (state.selectedCollectionCategoryId) {
                    collectionItems = collectionItems.filter(({ part }) => PART_MAP[part.id]?.categoryId === state.selectedCollectionCategoryId);
                }
                if (state.filters.colorIds && state.filters.colorIds.length > 0) {
                    collectionItems = collectionItems.filter(item => state.filters.colorIds.includes(item.color.id));
                }
                if (query) {
                    collectionItems = collectionItems.filter(({part}) => part.name.toLowerCase().includes(query) || part.id.toLowerCase().includes(query));
                }
                switch(state.sortBy) {
                    case 'alpha_asc': collectionItems.sort((a, b) => a.part.name.localeCompare(b.part.name)); break;
                    case 'alpha_desc': collectionItems.sort((a, b) => b.part.name.localeCompare(a.part.name)); break;
                    case 'popularity': collectionItems.sort((a, b) => (PART_MAP[b.part.id]?.num_sets || 0) - (PART_MAP[a.part.id]?.num_sets || 0)); break;
                }
                renderFn = (item, anim, i) => renderPartCard(item.part, item.color, item.quantity, anim, i);
                gridClass = 'grid-cols-[repeat(auto-fill,minmax(130px,1fr))]';
            } else if (state.activeSubView === 'sets') {
                collectionItems = Object.keys(state.setCollection).map(setNum => SET_MAP[setNum]).filter(Boolean);
                if (state.selectedSetCollectionThemeId) {
                    const getChildThemes = (themeId) => {
                        const theme = THEME_MAP[themeId];
                        if (!theme) return [];
                        let ids = [theme.id];
                        if(Array.isArray(theme.children)) { theme.children.forEach(child => { ids = ids.concat(getChildThemes(child.id)); }); }
                        return ids;
                    }
                    const themeIdsToMatch = getChildThemes(state.selectedSetCollectionThemeId);
                    collectionItems = collectionItems.filter(set => themeIdsToMatch.includes(set.theme_id));
                }
                if (query) { collectionItems = collectionItems.filter(s => s.name.toLowerCase().includes(query) || s.set_num.toLowerCase().includes(query)); }
                switch(state.sortBy) {
                    case 'alpha_asc': collectionItems.sort((a, b) => a.name.localeCompare(b.name)); break;
                    case 'alpha_desc': collectionItems.sort((a, b) => b.name.localeCompare(a.name)); break;
                    case 'year_asc': collectionItems.sort((a, b) => a.year - b.year); break;
                    case 'year_desc': collectionItems.sort((a, b) => b.year - a.year); break;
                    case 'parts_asc': collectionItems.sort((a, b) => a.num_parts - b.num_parts); break;
                    case 'parts_desc': collectionItems.sort((a, b) => b.num_parts - b.num_parts); break;
                }
                renderFn = (item, anim, i) => renderSetCard(item, anim, i);
            } else { // minifigs
                collectionItems = Object.keys(state.minifigCollection).map(figNum => MINIFIG_MAP[figNum]).filter(Boolean);
                if (query) { collectionItems = collectionItems.filter(mf => mf.name.toLowerCase().includes(query) || mf.set_num.toLowerCase().includes(query)); }
                switch(state.sortBy) {
                    case 'name_asc': collectionItems.sort((a, b) => a.name.localeCompare(b.name)); break;
                    case 'name_desc': collectionItems.sort((a, b) => b.name.localeCompare(a.name)); break;
                    case 'num_parts_desc': collectionItems.sort((a, b) => b.num_parts - a.num_parts); break;
                    case 'num_parts_asc': collectionItems.sort((a, b) => a.num_parts - b.num_parts); break;
                }
                renderFn = (item, anim, i) => renderMinifigCard(item, anim, i);
            }

            if (collectionItems.length === 0) {
                if(query || (state.activeSubView === 'parts' && (state.filters.colorIds.length > 0 || state.selectedCollectionCategoryId)) || (state.activeSubView === 'sets' && state.selectedSetCollectionThemeId)) {
                    emptyMsg += ', соответствующих фильтрам';
                }
                emptyMsg += '.';
                gridContent = `<div class="flex items-center justify-center h-full p-4 text-center"><p class="text-gray-400">${emptyMsg}</p></div>`;
            } else {
                const itemsToRender = collectionItems.slice(0, state.itemsToDisplay);
                gridContent = `<div class="grid ${gridClass} gap-4 p-4">
                    ${itemsToRender.map((item, index) => renderFn(item, state.isGridStale, index)).join('')}
                </div>`;
                if (collectionItems.length > state.itemsToDisplay) {
                    gridContent += `<div class="p-4 text-center">
                        <button id="load-more-button" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 transition-colors">
                            Загрузить ещё
                        </button>
                    </div>`;
                }
            }
        }
        mainContent.innerHTML = renderAppliedFilters() + gridContent;
        state.isGridStale = false;
    }
    
    function renderSetCollectionControls() {
        if (!state.selectedSetNum) return '';
        const { quantity } = state.setModal;
        const currentInCollection = state.setCollection[state.selectedSetNum]?.quantity || 0;
        
        return `
            <div class="bg-gray-700/50 rounded-lg p-4">
                <div class="space-y-4">
                    <div class="flex justify-between items-center">
                        <h3 class="text-white font-semibold">Коллекция наборов</h3>
                        <p class="text-sm text-gray-400 text-right">В коллекции: <span id="set-modal-in-collection-qty" class="font-bold text-white">${currentInCollection}</span></p>
                    </div>
                    
                    <div class="flex justify-between items-center gap-4">
                        <div class="flex items-center gap-2">
                            <button data-action="decrease-set-qty" class="p-2 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors">${MinusIcon('w-5 h-5')}</button>
                            <input id="set-modal-quantity-input" type="number" value="${quantity}" readonly class="w-12 text-center bg-gray-900 text-white font-bold rounded-md py-1"/>
                            <button data-action="increase-set-qty" class="p-2 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors">${PlusIcon('w-5 h-5')}</button>
                        </div>
                        <button data-action="update-set-collection" class="flex-grow bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors">
                            ${currentInCollection > 0 ? 'Обновить' : 'Добавить'}
                        </button>
                    </div>
                    ${currentInCollection > 0 ? `
                        <div>
                            <button data-action="delete-from-set-collection-modal" class="w-full mt-1 text-sm text-red-400 hover:text-red-300 hover:bg-red-900/50 rounded-md py-1.5 transition-colors">Удалить из коллекции</button>
                        </div>
                    ` : '<div></div>'}
                </div>
            </div>
        `;
    }

    function renderSetBulkPartsControls() {
        if (!state.selectedSetNum) return '';

        const { isBulkUpdating } = state.setModal;

        if (isBulkUpdating) {
            return `
                <div class="bg-gray-700/50 rounded-lg p-4 mt-4">
                     <h3 class="text-md font-semibold text-gray-300 mb-2">Коллекция деталей</h3>
                     <div class="flex items-center justify-center gap-3 text-white h-10">
                        <div class="loader !w-5 !h-5 !border-2"></div>
                        <span>Обновление...</span>
                     </div>
                </div>
            `;
        }

        return `
            <div class="bg-gray-700/50 rounded-lg p-4 mt-4">
                <h3 class="text-md font-semibold text-gray-300 mb-2">Коллекция деталей</h3>
                <div class="grid grid-cols-2 gap-2">
                    <button data-action="bulk-add-parts" class="flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-green-600 hover:bg-green-700 text-white">
                        ${PlusIcon('w-5 h-5 mr-2')} Добавить все
                    </button>
                    <button data-action="bulk-remove-parts" class="flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-600 hover:bg-red-700 text-white">
                        ${MinusIcon('w-5 h-5 mr-2')} Удалить все
                    </button>
                </div>
            </div>
        `;
    }

    function renderSetModalToggleButton() {
        const set = SET_MAP[state.selectedSetNum];
        if (!set) return '';

        if (state.setModal.currentView === 'details') {
            return `<button data-action="toggle-set-modal-view" class="flex items-center gap-2 px-3 py-1.5 text-sm font-semibold rounded-md transition-colors bg-gray-600 hover:bg-gray-500 text-white">
                ${BrickIcon('w-5 h-5')}
                <span>Инвентарь</span>
                <span class="text-xs bg-gray-700 text-gray-200 px-1.5 py-0.5 rounded-full">${set.num_parts}</span>
            </button>`;
        } else { // inventory view
            return `<button data-action="toggle-set-modal-view" class="flex items-center gap-2 px-3 py-1.5 text-sm font-semibold rounded-md transition-colors bg-blue-600 hover:bg-blue-700 text-white">
                ${CatalogIcon('w-5 h-5')}
                <span>Детали набора</span>
            </button>`;
        }
    }

    function renderSetModalDetailsView() {
        const set = SET_MAP[state.selectedSetNum];
        const theme = THEME_MAP[set.theme_id];
        
        return `
        <div class="flex-grow flex flex-col lg:flex-row overflow-y-auto no-scrollbar h-full">
            <div class="lg:w-1/2 p-4 sm:p-6 bg-gray-900/30 flex items-center justify-center flex-shrink-0 border-b lg:border-b-0 lg:border-r border-gray-700">
                 <div class="w-48 h-48 sm:w-64 sm:h-64 bg-white rounded-lg flex items-center justify-center overflow-hidden shadow-lg relative">
                    <img ${getPartImageUrl(set.set_img_url)} alt="${set.name}" class="max-w-full max-h-full object-contain">
                 </div>
            </div>
            
            <div class="lg:w-1/2 p-4 sm:p-6 flex flex-col">
                <div class="space-y-6">
                    <div>
                        <h3 class="text-md font-semibold text-gray-300 mb-3">Детали</h3>
                        <div class="space-y-1 text-sm text-gray-400">
                            <p><span class="font-semibold text-gray-300">Название:</span> ${set.name}</p>
                            <p>ID: ${set.set_num}</p>
                            <p>Год: ${set.year}</p>
                            <p>Кол-во деталей: ${set.num_parts}</p>
                            ${theme ? `<div class="flex items-center">
                                <span class="mr-1">Тема:</span>
                                <button data-action="go-to-theme" data-theme-id="${theme.id}" class="text-blue-400 hover:text-blue-300 hover:underline text-left truncate">
                                    ${theme.name}
                                </button>
                            </div>` : ''}
                        </div>
                    </div>

                    <div id="set-modal-controls-container">
                        ${renderSetCollectionControls()}
                        ${renderSetBulkPartsControls()}
                    </div>
                    
                     ${state.setModal.statusMessage ? `
                        <div class="mt-4 p-2 text-sm rounded-md ${state.setModal.statusType === 'error' ? 'bg-red-900/50 text-red-300' : 'bg-green-900/50 text-green-300'}">
                            ${state.setModal.statusMessage}
                        </div>
                     ` : ''}
                </div>
            </div>
        </div>
        `;
    }

    function renderSetModalInventoryView() {
        return `<div id="set-inventory-container" class="p-4 flex flex-col overflow-y-auto no-scrollbar h-full">
            ${renderSetInventory()}
        </div>`;
    }

    function updateSetModalView() {
        if (!state.selectedSetNum) return;
        const viewContainer = document.getElementById('set-modal-view-container');
        if (!viewContainer) return;

        if (state.setModal.currentView === 'details') {
            viewContainer.innerHTML = renderSetModalDetailsView();
        } else {
            viewContainer.innerHTML = renderSetModalInventoryView();
        }
    }

    function renderSetModal(isInitialRender = false) {
        if (!state.selectedSetNum) {
            closeSetModal();
            return;
        }

        const set = SET_MAP[state.selectedSetNum];
        if (!set) {
            closeSetModal();
            return;
        }

        const animationClass = isInitialRender ? 'modal-content-enter' : '';
        const isInventoryView = state.setModal.currentView === 'inventory';

        const sizeClass = isInventoryView ? 'max-w-6xl' : 'max-w-4xl';
        const heightClass = isInventoryView ? 'h-[calc(100vh-4rem)]' : 'max-h-[calc(100vh-2rem)]';

        if (isInitialRender) {
            document.body.classList.add('overflow-hidden');
            setModalContainer.classList.remove('modal-hidden');
            requestAnimationFrame(() => setModalContainer.classList.add('visible'));
        }

        setModalContainer.innerHTML = `
        <div id="set-modal-content" class="bg-gray-800 rounded-lg shadow-xl w-[calc(100%-2rem)] ${sizeClass} flex flex-col ${heightClass} ${animationClass} transition-all duration-300">
            <div class="flex-shrink-0 p-4 border-b border-gray-700 flex justify-between items-center gap-4">
                 <h2 class="text-xl lg:text-2xl font-bold text-white truncate pr-4">${set.name}</h2>
                 <div class="flex items-center gap-2 flex-shrink-0">
                    ${renderSetModalToggleButton()}
                    <button id="set-modal-close" class="text-gray-400 hover:text-white transition-colors">${XIcon('w-6 h-6')}</button>
                 </div>
            </div>
            <div id="set-modal-view-container" class="flex-grow overflow-hidden" style="min-height: 0;">
                <!-- View content is injected by updateSetModalView -->
            </div>
        </div>
        `;
        
        updateSetModalView();
    }

    function renderSetInventory() {
        const { inventory, isLoading, hasNextInventoryPage, minifigs, areMinifigsLoading } = state.setModal;

        let minifigsContent = '';
        if (areMinifigsLoading) {
            minifigsContent = `<div class="flex items-center justify-center p-4"><div class="loader !w-6 !h-6"></div></div>`;
        } else if (minifigs && minifigs.length > 0) {
            minifigsContent = minifigs.map(mf => {
                const figNum = mf.set_num;
                const collectionQty = state.minifigCollection[figNum]?.quantity || 0;
                return `
                    <div class="bg-gray-700/50 rounded-lg overflow-hidden">
                        <div class="flex items-center p-2 gap-3 text-sm">
                            <div class="w-12 h-12 bg-white rounded-md flex items-center justify-center flex-shrink-0">
                                <img ${getPartImageUrl(mf.set_img_url)} alt="${mf.set_name}" class="w-full h-full object-contain p-1">
                            </div>
                            <div class="flex-grow truncate">
                                <p class="text-white font-semibold truncate">${mf.set_name}</p>
                                <p class="text-gray-400 truncate">${figNum}</p>
                            </div>
                            <div class="flex items-center gap-2 flex-shrink-0">
                                <span class="text-gray-300 w-8 text-right font-semibold">${mf.quantity}x</span>
                                <button data-action="add-minifig-to-collection" data-fig-num="${figNum}" data-quantity="${mf.quantity}" class="p-2 rounded-full text-white transition-colors ${collectionQty > 0 ? 'bg-green-600' : 'bg-blue-600 hover:bg-blue-700'}" title="${collectionQty > 0 ? `В коллекции: ${collectionQty}` : `Добавить ${mf.quantity} в коллекцию минифигурок`}">
                                    ${MinifigIcon('w-5 h-5')}
                                </button>
                                <button data-action="toggle-minifig-parts" data-fig-num="${figNum}" class="p-2 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors" title="Показать/скрыть детали">
                                    ${ChevronDownIcon(`w-5 h-5 transform transition-transform duration-200 ${mf.isExpanded ? 'rotate-180' : ''}`)}
                                </button>
                            </div>
                        </div>
                        <div id="minifig-parts-${figNum.replace(/[^a-zA-Z0-9]/g, '-')}" class="${mf.isExpanded ? 'bg-gray-900/40 p-2 max-h-60 overflow-y-auto no-scrollbar' : 'hidden'}">
                             ${mf.isExpanded ? `
                                <div class="flex justify-end items-center mb-2 px-1.5">
                                    <button data-action="add-minifig-parts-to-collection" data-fig-num="${figNum}" class="flex items-center gap-2 text-xs px-2 py-1 rounded-md bg-blue-600 hover:bg-blue-700 text-white transition-colors disabled:opacity-50" title="Добавить все детали этой минифигурки в вашу коллекцию деталей" ${state.setModal.isBulkUpdating ? 'disabled' : ''}>
                                        ${PlusIcon('w-4 h-4')}
                                        <span>Добавить детали</span>
                                    </button>
                                </div>
                            ` : ''}
                            ${mf.isLoadingParts
                                ? `<div class="flex items-center justify-center p-2"><div class="loader !w-5 !h-5"></div></div>`
                                : (mf.parts || []).map(item => `
                                    <div class="flex items-center p-1.5 rounded-md gap-2 text-xs">
                                        <div class="w-8 h-8 bg-white rounded flex items-center justify-center flex-shrink-0">
                                            <img ${getPartImageUrl(item.part.part_img_url)} alt="${item.part.name}" class="w-full h-full object-contain p-0.5">
                                        </div>
                                        <div class="flex-grow truncate">
                                            <p class="text-gray-200 truncate">${item.part.name}</p>
                                            <p class="text-gray-400 truncate">${item.part.part_num}</p>
                                        </div>
                                        <div class="flex items-center gap-2 flex-shrink-0">
                                            <span class="w-4 h-4 rounded-full border border-gray-500 ${item.color.isTransparent ? 'checkerboard' : ''}" style="background-color: ${item.color.hex};" title="${item.color.name}"></span>
                                            <span class="text-gray-300 w-6 text-right">${item.quantity}x</span>
                                        </div>
                                    </div>
                                `).join('') || (mf.parts && mf.parts.length === 0 ? `<p class="text-xs text-gray-400 text-center p-2">Детали не найдены.</p>` : '')
                            }
                        </div>
                    </div>
                `
            }).join('');
        }

        const partsListContent = inventory.map(item => `
            <div class="flex items-center bg-gray-700/50 p-2 rounded-md gap-3 text-sm">
                <div class="w-12 h-12 bg-white rounded-md flex items-center justify-center flex-shrink-0">
                        <img ${getPartImageUrl(item.part.part_img_url)} alt="${item.part.name}" class="w-full h-full object-contain p-1">
                </div>
                <div class="flex-grow truncate">
                    <p class="text-white font-semibold truncate">${item.part.name}</p>
                    <p class="text-gray-400 truncate">${item.part.part_num}</p>
                </div>
                <div class="flex items-center gap-2 flex-shrink-0">
                    <span class="w-5 h-5 rounded-full border border-gray-500 ${item.color.isTransparent ? 'checkerboard' : ''}" style="background-color: ${item.color.hex};" title="${item.color.name}"></span>
                    <span class="text-gray-300 w-8 text-right">${item.quantity}x</span>
                </div>
            </div>
        `).join('');

        let loadMoreButton = '';
        if(isLoading) {
            loadMoreButton = `<div class="flex justify-center p-4 flex-shrink-0"><div class="loader !w-8 !h-8"></div></div>`;
        } else if (hasNextInventoryPage) {
            loadMoreButton = `<div class="pt-4 text-center flex-shrink-0">
                <button data-action="load-more-inventory" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 transition-colors">
                    Загрузить ещё
                </button>
            </div>`;
        }

        return `
            <div class="space-y-6">
                ${minifigsContent ? `
                    <div>
                        <h3 class="text-lg font-semibold text-white mb-3 flex items-center gap-2">
                            ${MinifigIcon('w-5 h-5')} Минифигурки
                        </h3>
                        <div class="space-y-2">${minifigsContent}</div>
                    </div>` : ''
                }
                <div>
                    <h3 class="text-lg font-semibold text-white mb-3 flex items-center gap-2">
                        ${BrickIcon('w-5 h-5')} Детали
                    </h3>
                    ${inventory.length > 0 || isLoading ? `
                        <div class="space-y-2">${partsListContent}</div>
                        ${loadMoreButton}
                    ` : `<div class="text-sm text-gray-400 p-2">Инвентарь (кроме минифигурок) не найден.</div>`
                    }
                </div>
            </div>
        `;
    }
    
    function updateSetModalControlsState() {
        if (!state.selectedSetNum) return;
        
        const controlsContainer = document.getElementById('set-modal-controls-container');
        if (controlsContainer) {
          controlsContainer.innerHTML = renderSetCollectionControls() + renderSetBulkPartsControls();
        }
    }

    function renderModal() {
        if (!state.selectedPartId) {
            if (!modalContainer.classList.contains('modal-hidden')) {
                closeModal();
            }
            return;
        }

        const part = PART_MAP[state.selectedPartId];
        if (!part) {
            closeModal();
            return;
        }
        
        const animationClass = 'modal-content-enter';
        const categoryName = flatCategories.find(c => c.id === part.categoryId)?.name;
        const { partVariations, partImageUrl } = state.modal;
        
        let variationSelector = '';
        if (partVariations && partVariations.length > 1) {
            variationSelector = `
                <div>
                    <label for="variation-select" class="block text-sm font-medium text-gray-400 mb-2">Вариация</label>
                    <select id="variation-select" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                        ${partVariations.map(variation => `
                            <option value="${variation.id}" ${variation.id === state.selectedPartId ? 'selected' : ''}>
                                ${variation.name}
                            </option>
                        `).join('')}
                    </select>
                </div>
            `;
        }

        document.body.classList.add('overflow-hidden');
        modalContainer.classList.remove('modal-hidden');
        requestAnimationFrame(() => {
            modalContainer.classList.add('visible');
        });
        
        modalContainer.innerHTML = `
        <div id="modal-content" class="bg-gray-800 rounded-lg shadow-xl w-[calc(100%-2rem)] max-w-lg lg:max-w-4xl flex flex-col max-h-[calc(100vh-2rem)] ${animationClass}">
            
            <div class="flex-shrink-0 p-4 border-b border-gray-700 flex justify-between items-center">
                 <h2 class="text-xl lg:text-2xl font-bold text-white lg:truncate pr-8">${part.name}</h2>
                 <button id="modal-close" class="text-gray-400 hover:text-white transition-colors">${XIcon('w-6 h-6')}</button>
            </div>
            
            <div id="modal-scroll-area" class="flex-grow flex flex-col lg:flex-row overflow-y-auto no-scrollbar">
                <div class="lg:w-1/2 p-4 sm:p-6 bg-gray-900/30 flex items-center justify-center flex-shrink-0 border-b lg:border-b-0 lg:border-r border-gray-700">
                     <div id="modal-image-container" class="w-48 h-48 sm:w-64 sm:h-64 bg-white rounded-lg flex items-center justify-center overflow-hidden shadow-lg relative">
                        <img ${getPartImageUrl(partImageUrl)} alt="${part.name}" class="max-w-full max-h-full object-contain">
                     </div>
                </div>
                
                <div class="lg:w-1/2 p-4 sm:p-6 flex flex-col">
                    <div class="space-y-6">
                        <div>
                            <p class="text-sm text-gray-400">ID: ${part.id}</p>
                            ${categoryName ? `
                                <div class="text-sm text-gray-400 flex items-center mt-1">
                                    <span class="mr-1">Категория:</span>
                                    <button data-action="go-to-category" data-category-id="${part.categoryId}" class="text-blue-400 hover:text-blue-300 hover:underline text-left truncate">
                                        ${categoryName}
                                    </button>
                                </div>
                            ` : ''}
                            ${variationSelector ? `<div class="mt-4">${variationSelector}</div>` : ''}
                        </div>
                        
                        <div>
                          <h3 class="text-md font-semibold text-gray-300 mb-3">Доступные цвета</h3>
                           <div id="color-selector-container">${renderColorSelector()}</div>
                        </div>
                        
                        <div id="modal-controls-container">${renderModalControls()}</div>
                    </div>
                </div>
            </div>
        </div>
        `;

        updateModalPartially({ image: true });
    }
    
    function renderColorSelector() {
        if (!state.selectedPartId) return '';
    
        const part = PART_MAP[state.selectedPartId];
        if (!part) return '';
    
        const { selectedColorId, isLoadingColors } = state.modal;
        const availableColorIds = part.availableColorIds || [];
    
        if (isLoadingColors) {
            return `<div class="flex items-center justify-center h-24"><div class="loader !w-8 !h-8"></div></div>`;
        }
        if (availableColorIds.length === 0) {
            return `<p class="text-sm text-gray-400 text-center py-4">Нет информации о доступных цветах.</p>`;
        }
        
        const sortedColorIds = sortColorIds(availableColorIds, part.id);
        
        const allColorButtonsHtml = sortedColorIds.map(cid => {
            const color = COLOR_MAP[cid];
            if (!color) return '';
            const isInCollection = state.collection[part.id] && state.collection[part.id][cid] > 0;
            return `
                <button data-color-id="${cid}" title="${color.name}" class="w-8 h-8 rounded-full border-2 transition-transform duration-150 overflow-hidden flex-shrink-0 flex items-center justify-center ${color.isTransparent ? 'checkerboard' : ''} ${selectedColorId === cid ? 'border-blue-500 scale-110' : 'border-gray-600 hover:border-gray-400'}" style="background-color: ${color.hex};">
                    ${isInCollection ? '<div class="w-2 h-2 bg-white rounded-full"></div>' : ''}
                </button>
            `;
        }).join('');
        
        return `
            <div class="bg-gray-900/50 rounded-lg">
                <div class="relative">
                    <div class="max-h-48 overflow-y-auto no-scrollbar">
                        <div class="flex flex-wrap justify-center gap-3 p-3">
                            ${allColorButtonsHtml}
                        </div>
                    </div>
                    ${availableColorIds.length > COLOR_COLLAPSE_THRESHOLD * 1.5 ? `<div class="absolute bottom-0 left-0 right-0 h-8 bg-gradient-to-t from-gray-900/50 to-transparent pointer-events-none"></div>` : ''}
                </div>
            </div>
        `;
    }

    function renderModalControls() {
        const { selectedColorId, quantity } = state.modal;
        const selectedColor = selectedColorId ? COLOR_MAP[selectedColorId] : null;

        if (!selectedColor || !state.selectedPartId) return '';

        const currentInCollection = (state.collection[state.selectedPartId]?.[selectedColorId]) || 0;

        return `
            <div class="bg-gray-700/50 rounded-lg p-3">
                <div class="space-y-2">
                    <div class="flex justify-between items-center">
                        <p class="text-white font-semibold truncate" title="${selectedColor.name}">${selectedColor.name}</p>
                        <p class="text-sm text-gray-400 text-right">В коллекции: <span id="modal-in-collection-qty" class="font-bold text-white">${currentInCollection}</span></p>
                    </div>
                    
                    <div class="flex justify-between items-center gap-3">
                        <div class="flex items-center gap-1.5">
                            <button data-action="decrease-qty" class="p-2 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors">${MinusIcon('w-5 h-5')}</button>
                            <input id="modal-quantity-input" type="number" value="${quantity}" readonly class="w-12 text-center bg-gray-900 text-white font-bold rounded-md py-1"/>
                            <button data-action="increase-qty" class="p-2 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors">${PlusIcon('w-5 h-5')}</button>
                        </div>
                        <button id="modal-update-collection-btn" data-action="update-collection" class="flex-grow bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors">
                            ${currentInCollection > 0 ? 'Обновить' : 'Добавить'}
                        </button>
                    </div>
                    <div id="modal-delete-container" class="h-5 flex items-center justify-center">
                        ${currentInCollection > 0 ? `
                            <button data-action="delete-from-collection-modal" class="text-sm text-red-400 hover:text-red-300 hover:underline transition-colors">Удалить из коллекции</button>
                        ` : ''}
                    </div>
                </div>
            </div>
        `;
    }

    function renderFilterModal() {
        if (!state.isFilterModalOpen) {
            closeFilterModal();
            return;
        }
        
        const animationClass = 'modal-content-enter';
        document.body.classList.add('overflow-hidden');
        filterModalContainer.classList.remove('modal-hidden');
        requestAnimationFrame(() => filterModalContainer.classList.add('visible'));

        let content = '';

        if (state.activeSubView === 'sets') {
            const sortOptions = [
                { id: 'relevance', name: 'Релевантность', desc: 'Поиск' },
                { id: 'year_desc', name: 'Год (новые)', desc: 'По умолч.' },
                { id: 'year_asc', name: 'Год (старые)', desc: '' },
                { id: 'parts_desc', name: 'Кол-во деталей (убыв.)', desc: '' },
                { id: 'parts_asc', name: 'Кол-во деталей (возр.)', desc: '' },
                { id: 'alpha_asc', name: 'Алфавит (А-Я)', desc: '' },
                { id: 'alpha_desc', name: 'Алфавит (Я-А)', desc: '' },
            ];
            const sortRadios = sortOptions.map(opt => {
                const isChecked = tempFilters.sortBy === opt.id;
                const isDisabled = opt.id === 'relevance' && !state.searchQuery;
                const defaultBadge = (opt.id === 'relevance' && state.searchQuery) || (opt.id === 'year_desc' && !state.searchQuery) ? `<span class="ml-2 text-xs bg-blue-600/50 text-blue-300 px-1.5 py-0.5 rounded-full">По умолч.</span>` : '';
                return `
                    <label class="flex items-center p-3 rounded-lg hover:bg-gray-700/50 transition-colors cursor-pointer ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}">
                        <input type="radio" name="sort" value="${opt.id}" class="h-4 w-4 text-blue-600 bg-gray-700 border-gray-500 focus:ring-blue-500" ${isChecked ? 'checked' : ''} ${isDisabled ? 'disabled' : ''} data-action="modal-set-sort">
                        <span class="ml-3 text-white">${opt.name}</span>
                        ${defaultBadge}
                    </label>
                `;
            }).join('');
            
            content = `
                <div>
                    <h3 class="text-md font-semibold text-gray-300 mb-2">Сортировать по</h3>
                    <div class="bg-gray-900/50 rounded-lg space-y-1 p-2">${sortRadios}</div>
                </div>
                <div>
                    <h3 class="text-md font-semibold text-gray-300 mb-2">Фильтры</h3>
                    <div class="bg-gray-900/50 rounded-lg p-3 space-y-4">
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label for="min-year" class="block text-sm font-medium text-gray-400 mb-1">Мин. год</label>
                                <input type="number" id="min-year" value="${tempFilters.setFilters.minYear}" data-filter-key="minYear" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                            </div>
                             <div>
                                <label for="max-year" class="block text-sm font-medium text-gray-400 mb-1">Макс. год</label>
                                <input type="number" id="max-year" value="${tempFilters.setFilters.maxYear}" data-filter-key="maxYear" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label for="min-parts" class="block text-sm font-medium text-gray-400 mb-1">Мин. деталей</label>
                                <input type="number" id="min-parts" value="${tempFilters.setFilters.minParts}" data-filter-key="minParts" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                            </div>
                             <div>
                                <label for="max-parts" class="block text-sm font-medium text-gray-400 mb-1">Макс. деталей</label>
                                <input type="number" id="max-parts" value="${tempFilters.setFilters.maxParts}" data-filter-key="maxParts" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                            </div>
                        </div>
                    </div>
                </div>
            `;
        } else if (state.activeSubView === 'minifigs') {
            const sortOptions = [
                { id: 'relevance', name: 'Релевантность', desc: 'Поиск' },
                { id: 'name_asc', name: 'Алфавит (А-Я)', desc: 'По умолч.' },
                { id: 'name_desc', name: 'Алфавит (Я-А)', desc: '' },
                { id: 'num_parts_desc', name: 'Кол-во деталей (убыв.)', desc: '' },
                { id: 'num_parts_asc', name: 'Кол-во деталей (возр.)', desc: '' },
            ];
            const sortRadios = sortOptions.map(opt => {
                const isChecked = tempFilters.sortBy === opt.id;
                const isDisabled = opt.id === 'relevance' && !state.searchQuery;
                const defaultBadge = (opt.id === 'relevance' && state.searchQuery) || (opt.id === 'name_asc' && !state.searchQuery) ? `<span class="ml-2 text-xs bg-blue-600/50 text-blue-300 px-1.5 py-0.5 rounded-full">По умолч.</span>` : '';
                return `
                    <label class="flex items-center p-3 rounded-lg hover:bg-gray-700/50 transition-colors cursor-pointer ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}">
                        <input type="radio" name="sort" value="${opt.id}" class="h-4 w-4 text-blue-600 bg-gray-700 border-gray-500 focus:ring-blue-500" ${isChecked ? 'checked' : ''} ${isDisabled ? 'disabled' : ''} data-action="modal-set-sort">
                        <span class="ml-3 text-white">${opt.name}</span>
                        ${defaultBadge}
                    </label>
                `;
            }).join('');
            content = `
                <div>
                    <h3 class="text-md font-semibold text-gray-300 mb-2">Сортировать по</h3>
                    <div class="bg-gray-900/50 rounded-lg space-y-1 p-2">${sortRadios}</div>
                </div>
            `;
        } else { // Parts views
            const sortOptions = [ { id: 'relevance', name: 'Релевантность', desc: 'Поиск' }, { id: 'popularity', name: 'Популярность', desc: 'Каталог' }, { id: 'alpha_asc', name: 'Алфавит (А-Я)', desc: '' }, { id: 'alpha_desc', name: 'Алфавит (Я-А)', desc: '' }, ];
            const sortRadios = sortOptions.map(opt => {
                const isChecked = tempFilters.sortBy === opt.id;
                const isDisabled = (opt.id === 'relevance' && !state.searchQuery) || (opt.id === 'popularity' && state.searchQuery);
                const defaultBadge = (state.searchQuery && opt.id === 'relevance') || (!state.searchQuery && opt.id === 'popularity') ? '<span class="ml-2 text-xs bg-blue-600/50 text-blue-300 px-1.5 py-0.5 rounded-full">По умолч.</span>' : '';
                return `
                    <label class="flex items-center p-3 rounded-lg hover:bg-gray-700/50 transition-colors cursor-pointer ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}">
                        <input type="radio" name="sort" value="${opt.id}" class="h-4 w-4 text-blue-600 bg-gray-700 border-gray-500 focus:ring-blue-500" ${isChecked ? 'checked' : ''} ${isDisabled ? 'disabled' : ''} data-action="modal-set-sort">
                        <span class="ml-3 text-white">${opt.name}</span>
                        ${defaultBadge}
                    </label>
                `;
            }).join('');
            const collectionToggle = state.currentView === 'catalog' ? `
                <div>
                    <h3 class="text-md font-semibold text-gray-300 mb-2">Фильтры</h3>
                    <div class="bg-gray-900/50 rounded-lg p-2">
                        <label class="flex justify-between items-center p-2 cursor-pointer">
                            <span class="text-white">Только детали в коллекции</span>
                            <div class="relative">
                                <input type="checkbox" class="sr-only peer" ${tempFilters.filters.inCollectionOnly ? 'checked' : ''} data-action="modal-toggle-collection">
                                <div class="w-11 h-6 bg-gray-600 rounded-full peer peer-focus:ring-2 peer-focus:ring-blue-500 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                            </div>
                        </label>
                    </div>
                </div>
            ` : '';
            const sortedColorIds = Object.keys(COLOR_MAP).sort((a,b) => COLOR_MAP[a].name.localeCompare(b.name));
            const colorButtons = sortedColorIds.map(cid => {
                const color = COLOR_MAP[cid];
                const isSelected = tempFilters.filters.colorIds.includes(cid);
                return `<button data-action="modal-set-color" data-color-id="${cid}" title="${color.name}" class="w-8 h-8 rounded-full border-2 transition-transform duration-150 overflow-hidden flex-shrink-0 ${color.isTransparent ? 'checkerboard' : ''} ${isSelected ? 'border-blue-500 scale-110' : 'border-gray-600 hover:border-gray-400'}" style="background-color: ${color.hex};"></button>`;
            }).join('');
            content = `
                <div>
                    <h3 class="text-md font-semibold text-gray-300 mb-2">Сортировать по</h3>
                    <div class="bg-gray-900/50 rounded-lg space-y-1 p-2">${sortRadios}</div>
                </div>
                ${collectionToggle}
                <div>
                     <h3 class="text-md font-semibold text-gray-300 mb-2">Фильтр по цвету</h3>
                     <div class="bg-gray-900/50 rounded-lg p-3">
                        <button data-action="modal-set-color" data-color-id="null" class="w-full mb-3 py-2 text-sm rounded-md transition-colors ${tempFilters.filters.colorIds.length === 0 ? 'bg-blue-600 text-white font-semibold' : 'bg-gray-600 hover:bg-gray-500 text-gray-200'}">Все цвета</button>
                        <div class="relative">
                            <div class="max-h-48 overflow-y-auto no-scrollbar pr-2">
                                <div class="grid grid-cols-[repeat(auto-fill,minmax(36px,1fr))] gap-3">
                                    ${colorButtons}
                                </div>
                            </div>
                            <div class="absolute bottom-0 left-0 right-0 h-6 bg-gradient-to-t from-gray-900 to-transparent pointer-events-none"></div>
                        </div>
                     </div>
                </div>`;
        }
        
        filterModalContainer.innerHTML = `
            <div id="filter-modal-content" class="bg-gray-800 rounded-lg shadow-xl w-[calc(100%-2rem)] max-w-md flex flex-col max-h-[calc(100vh-2rem)] ${animationClass}">
                <div class="flex-shrink-0 p-4 border-b border-gray-700 flex justify-between items-center">
                     <h2 class="text-xl font-bold text-white">Фильтры и сортировка</h2>
                     <button id="filter-modal-close" class="text-gray-400 hover:text-white transition-colors">${XIcon('w-6 h-6')}</button>
                </div>
                <div class="flex-grow p-4 overflow-y-auto no-scrollbar space-y-6">${content}</div>
                <div class="flex-shrink-0 p-4 border-t border-gray-700 flex justify-between items-center gap-4">
                    <button data-action="modal-reset-filters" class="px-4 py-2 text-sm font-semibold rounded-md transition-colors bg-gray-600 hover:bg-gray-500 text-white">Сбросить</button>
                    <button data-action="modal-apply-filters" class="flex-grow px-4 py-2 text-sm font-semibold rounded-md transition-colors bg-blue-600 hover:bg-blue-700 text-white">Применить</button>
                </div>
            </div>
        `;
    }

    function renderSettingsModal() {
        if (!state.isSettingsModalOpen) {
            closeSettingsModal();
            return;
        }

        const animationClass = 'modal-content-enter';
        document.body.classList.add('overflow-hidden');
        settingsModalContainer.classList.remove('modal-hidden');
        requestAnimationFrame(() => settingsModalContainer.classList.add('visible'));

        const { confirmingDelete } = state.settingsModal;
        const totalPartsCount = Object.values(state.collection).reduce((sum, colors) => sum + Object.keys(colors).length, 0);
        const totalSetsCount = Object.keys(state.setCollection).length;
        const totalMinifigsCount = Object.keys(state.minifigCollection).length;
        
        let deletePartsSection = '';
        if (confirmingDelete === 'parts') {
            deletePartsSection = `
                <p class="text-yellow-300 text-sm text-center mb-2">Вы уверены? Это действие необратимо.</p>
                <div class="flex gap-2">
                    <button data-action="cancel-delete" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-600 hover:bg-gray-500 text-white">Отмена</button>
                    <button data-action="confirm-delete-parts" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-800 hover:bg-red-700 text-white">Подтвердить удаление</button>
                </div>`;
        } else {
            deletePartsSection = `<button data-action="delete-all-parts" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-600 hover:bg-red-700 text-white ${totalPartsCount === 0 ? 'opacity-50 cursor-not-allowed' : ''}" ${totalPartsCount === 0 ? 'disabled' : ''}>${TrashIcon('w-5 h-5 mr-2')} Удалить все детали</button>`;
        }
        
        let deleteSetsSection = '';
        if (confirmingDelete === 'sets') {
             deleteSetsSection = `
                <p class="text-yellow-300 text-sm text-center mb-2">Вы уверены? Это действие необратимо.</p>
                <div class="flex gap-2">
                    <button data-action="cancel-delete" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-600 hover:bg-gray-500 text-white">Отмена</button>
                    <button data-action="confirm-delete-sets" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-800 hover:bg-red-700 text-white">Подтвердить удаление</button>
                </div>`;
        } else {
            deleteSetsSection = `<button data-action="delete-all-sets" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-600 hover:bg-red-700 text-white ${totalSetsCount === 0 ? 'opacity-50 cursor-not-allowed' : ''}" ${totalSetsCount === 0 ? 'disabled' : ''}>${TrashIcon('w-5 h-5 mr-2')} Удалить все наборы</button>`;
        }

        let deleteMinifigsSection = '';
        if (confirmingDelete === 'minifigs') {
            deleteMinifigsSection = `
                <p class="text-yellow-300 text-sm text-center mb-2">Вы уверены? Это действие необратимо.</p>
                <div class="flex gap-2">
                    <button data-action="cancel-delete" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-gray-600 hover:bg-gray-500 text-white">Отмена</button>
                    <button data-action="confirm-delete-minifigs" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-800 hover:bg-red-700 text-white">Подтвердить удаление</button>
                </div>`;
        } else {
            deleteMinifigsSection = `<button data-action="delete-all-minifigs" class="w-full flex items-center justify-center px-3 py-2 text-sm font-semibold rounded-md transition-colors duration-150 bg-red-600 hover:bg-red-700 text-white ${totalMinifigsCount === 0 ? 'opacity-50 cursor-not-allowed' : ''}" ${totalMinifigsCount === 0 ? 'disabled' : ''}>${TrashIcon('w-5 h-5 mr-2')} Удалить все минифигурки</button>`;
        }


        settingsModalContainer.innerHTML = `
             <div id="settings-modal-content" class="bg-gray-800 rounded-lg shadow-xl w-[calc(100%-2rem)] max-w-md flex flex-col max-h-[calc(100vh-2rem)] ${animationClass}">
                <div class="flex-shrink-0 p-4 border-b border-gray-700 flex justify-between items-center">
                     <h2 class="text-xl font-bold text-white">Настройки</h2>
                     <button id="settings-modal-close" class="text-gray-400 hover:text-white transition-colors">${XIcon('w-6 h-6')}</button>
                </div>
                <div class="flex-grow p-4 overflow-y-auto no-scrollbar space-y-6">
                     <div>
                        <h3 class="text-md font-semibold text-gray-300 mb-2">Опасная зона</h3>
                        <div class="bg-red-900/20 border border-red-500/30 rounded-lg p-3 space-y-3">
                           ${deletePartsSection}
                           ${deleteSetsSection}
                           ${deleteMinifigsSection}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    function updateFilterModalUI() {
        if (!state.isFilterModalOpen || !filterModalContainer.innerHTML) return;

        const sortRadios = filterModalContainer.querySelectorAll('input[name="sort"]');
        sortRadios.forEach(radio => {
            radio.checked = tempFilters.sortBy === radio.value;
        });

        if (state.activeSubView === 'parts') {
            const collectionToggle = filterModalContainer.querySelector('input[data-action="modal-toggle-collection"]');
            if (collectionToggle) collectionToggle.checked = tempFilters.filters.inCollectionOnly;

            const allColorsButton = filterModalContainer.querySelector('button[data-color-id="null"]');
            if (allColorsButton) {
                const isActive = tempFilters.filters.colorIds.length === 0;
                allColorsButton.className = `w-full mb-3 py-2 text-sm rounded-md transition-colors ${isActive ? 'bg-blue-600 text-white font-semibold' : 'bg-gray-600 hover:bg-gray-500 text-gray-200'}`;
            }

            const colorButtons = filterModalContainer.querySelectorAll('button[data-action="modal-set-color"]');
            colorButtons.forEach(button => {
                const colorId = button.dataset.colorId;
                if (colorId && colorId !== 'null') {
                    const isSelected = tempFilters.filters.colorIds.includes(colorId);
                    const color = COLOR_MAP[colorId];
                    if (color) {
                        button.className = `w-8 h-8 rounded-full border-2 transition-transform duration-150 overflow-hidden flex-shrink-0 ${color.isTransparent ? 'checkerboard' : ''} ${isSelected ? 'border-blue-500 scale-110' : 'border-gray-600 hover:border-gray-400'}`;
                    }
                }
            });
        }
    }

    function updateModalPartially(updates) {
        if (!state.selectedPartId) return;

        if (updates.image) {
            const imageContainer = document.getElementById('modal-image-container');
            if (imageContainer) {
                const { partImageUrl, isImageLoading } = state.modal;
                const part = PART_MAP[state.selectedPartId];
                imageContainer.innerHTML = `
                    ${isImageLoading ? `<div class="absolute inset-0 bg-gray-900/80 flex items-center justify-center z-10"><div class="loader !w-10 !h-10"></div></div>` : ''}
                    <img ${getPartImageUrl(partImageUrl)} alt="${part.name}" class="max-w-full max-h-full object-contain">
                `;
            }
        }
        if (updates.colors) {
            const colorContainer = document.getElementById('color-selector-container');
            if (colorContainer) {
                colorContainer.innerHTML = renderColorSelector();
            }
        }
        if (updates.controls) {
            const controlsContainer = document.getElementById('modal-controls-container');
            if (controlsContainer) {
                controlsContainer.innerHTML = renderModalControls();
            }
        }
    }
    
    function updateModalControlsState() {
        if (!state.selectedPartId || !state.modal.selectedColorId) return;

        const currentInCollection = (state.collection[state.selectedPartId]?.[state.modal.selectedColorId]) || 0;
        
        const inCollectionQtySpan = document.getElementById('modal-in-collection-qty');
        if (inCollectionQtySpan) inCollectionQtySpan.textContent = currentInCollection;
        
        const updateBtn = document.getElementById('modal-update-collection-btn');
        if (updateBtn) updateBtn.textContent = currentInCollection > 0 ? 'Обновить' : 'Добавить';
        
        const deleteContainer = document.getElementById('modal-delete-container');
        if (deleteContainer) {
            const deleteButtonHtml = `<button data-action="delete-from-collection-modal" class="text-sm text-red-400 hover:text-red-300 hover:underline transition-colors">Удалить из коллекции</button>`;
            if (currentInCollection > 0) {
                if (!deleteContainer.innerHTML.trim()) {
                    deleteContainer.innerHTML = deleteButtonHtml;
                }
            } else {
                deleteContainer.innerHTML = '';
            }
        }

        const qtyInput = document.getElementById('modal-quantity-input');
        if(qtyInput) qtyInput.value = state.modal.quantity;
    }

    function renderMinifigModal(isInitialRender = false) {
        if (!state.selectedFigNum) {
            closeMinifigModal();
            return;
        }

        const minifig = MINIFIG_MAP[state.selectedFigNum];
        if (!minifig) {
            closeMinifigModal();
            return;
        }

        const animationClass = isInitialRender ? 'modal-content-enter' : '';
        const sizeClass = 'max-w-4xl';

        if (isInitialRender) {
            document.body.classList.add('overflow-hidden');
            minifigModalContainer.classList.remove('modal-hidden');
            requestAnimationFrame(() => minifigModalContainer.classList.add('visible'));
        }
        
        const { quantity } = state.minifigModal;
        const currentInCollection = state.minifigCollection[state.selectedFigNum]?.quantity || 0;
        
        const collectionControls = `
            <div class="bg-gray-700/50 rounded-lg p-4">
                <div class="space-y-4">
                    <div class="flex justify-between items-center">
                        <h3 class="text-white font-semibold">Коллекция минифигурок</h3>
                        <p class="text-sm text-gray-400 text-right">В коллекции: <span class="font-bold text-white">${currentInCollection}</span></p>
                    </div>
                    
                    <div class="flex justify-between items-center gap-4">
                        <div class="flex items-center gap-2">
                            <button data-action="decrease-minifig-qty" class="p-2 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors">${MinusIcon('w-5 h-5')}</button>
                            <input type="number" value="${quantity}" readonly class="w-12 text-center bg-gray-900 text-white font-bold rounded-md py-1"/>
                            <button data-action="increase-minifig-qty" class="p-2 rounded-full bg-gray-600 hover:bg-gray-500 text-white transition-colors">${PlusIcon('w-5 h-5')}</button>
                        </div>
                        <button data-action="update-minifig-collection" class="flex-grow bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors">
                            ${currentInCollection > 0 ? 'Обновить' : 'Добавить'}
                        </button>
                    </div>
                    ${currentInCollection > 0 ? `
                        <div>
                            <button data-action="delete-from-minifig-collection-modal" class="w-full mt-1 text-sm text-red-400 hover:text-red-300 hover:bg-red-900/50 rounded-md py-1.5 transition-colors">Удалить из коллекции</button>
                        </div>
                    ` : '<div></div>'}
                </div>
            </div>`;

        minifigModalContainer.innerHTML = `
        <div id="minifig-modal-content" class="bg-gray-800 rounded-lg shadow-xl w-[calc(100%-2rem)] ${sizeClass} flex flex-col max-h-[calc(100vh-2rem)] ${animationClass}">
            <div class="flex-shrink-0 p-4 border-b border-gray-700 flex justify-between items-center gap-4">
                 <h2 class="text-xl lg:text-2xl font-bold text-white truncate pr-4">${minifig.name}</h2>
                 <div class="flex items-center gap-2 flex-shrink-0">
                    <button id="minifig-modal-close" class="text-gray-400 hover:text-white transition-colors">${XIcon('w-6 h-6')}</button>
                 </div>
            </div>
            <div class="flex-grow overflow-y-auto no-scrollbar">
                <div class="flex flex-col lg:flex-row">
                    <div class="lg:w-1/2 p-4 sm:p-6 bg-gray-900/30 flex items-center justify-center flex-shrink-0 border-b lg:border-b-0 lg:border-r border-gray-700">
                         <div class="w-48 h-48 sm:w-64 sm:h-64 bg-white rounded-lg flex items-center justify-center overflow-hidden shadow-lg relative">
                            <img ${getPartImageUrl(minifig.set_img_url)} alt="${minifig.name}" class="max-w-full max-h-full object-contain">
                         </div>
                    </div>
                    <div class="lg:w-1/2 p-4 sm:p-6 flex flex-col">
                        <div class="space-y-6">
                            <div>
                                <h3 class="text-md font-semibold text-gray-300 mb-3">Информация</h3>
                                <div class="space-y-1 text-sm text-gray-400">
                                    <p>ID: ${minifig.set_num}</p>
                                    <p>Кол-во деталей: ${minifig.num_parts}</p>
                                </div>
                            </div>
                            ${collectionControls}
                        </div>
                    </div>
                </div>
            </div>
        </div>
        `;
    }

    function updateUI() {
        renderSidebar();
        renderHeader();
        renderMainContent();
        
        const isMobile = window.innerWidth < 1024;
        if (isMobile) {
            if (state.isSidebarOpen) {
                sidebarContainer.classList.remove('-translate-x-full');
                sidebarBackdrop.classList.remove('hidden');
                document.body.style.overflow = 'hidden';
            } else {
                sidebarContainer.classList.add('-translate-x-full');
                sidebarBackdrop.classList.add('hidden');
                document.body.style.overflow = '';
            }
        } else {
            sidebarContainer.classList.remove('-translate-x-full');
            sidebarBackdrop.classList.add('hidden');
            document.body.style.overflow = '';
        }
    }

    // --- EVENT HANDLING ---
    async function handleUpdateCollection(partId, colorId, quantity) {
        if (!state.collection[partId]) state.collection[partId] = {};
        
        if (quantity > 0) {
            state.collection[partId][colorId] = quantity;
        } else {
            delete state.collection[partId][colorId];
            if (Object.keys(state.collection[partId]).length === 0) {
                delete state.collection[partId];
            }
        }

        if (quantity > 0 && !PART_MAP[partId]?.colorImages) {
            await fetchColorDetailsForPart(partId);
        }
        
        saveState();
        
        state.isGridStale = true;
        
        if(state.currentView === 'collection') {
            updateUI();
        } else {
            renderSidebar();
            const card = mainContent.querySelector(`.part-card[data-part-id="${partId}"]`);
            if(card) {
                const totalQuantity = Object.values(state.collection[partId] || {}).reduce((sum, q) => sum + q, 0);
                let indicator = card.querySelector('.absolute.top-3.right-3');
                if(totalQuantity > 0) {
                    if(!indicator) {
                        indicator = document.createElement('div');
                        indicator.className = `absolute top-3 right-3 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md`;
                        card.prepend(indicator);
                    }
                    indicator.textContent = totalQuantity;
                } else {
                    indicator?.remove();
                }
            }
        }
        
        if (state.selectedPartId === partId) {
            updateModalControlsState();
            const colorButton = modalContainer.querySelector(`button[data-color-id="${colorId}"]`);
            if (colorButton) {
                const dot = colorButton.querySelector('.w-2.h-2');
                if (quantity > 0 && !dot) {
                    const newDot = document.createElement('div');
                    newDot.className = 'w-2 h-2 bg-white rounded-full';
                    colorButton.appendChild(newDot);
                } else if (quantity === 0 && dot) {
                    dot.remove();
                }
            }
        }
    }

    function handleUpdateSetCollection(setNum, quantity) {
        if (quantity > 0) {
            state.setCollection[setNum] = { quantity };
        } else {
            delete state.setCollection[setNum];
        }
        saveState();
        
        state.isGridStale = true;
        if (state.currentView === 'collection') {
            updateUI();
        } else {
            renderSidebar(); 
            const card = mainContent.querySelector(`.set-card[data-set-num="${setNum}"]`);
            if (card) {
                let indicator = card.querySelector('.absolute.top-3.right-3');
                if (quantity > 0) {
                    if (!indicator) {
                        indicator = document.createElement('div');
                        indicator.className = 'absolute top-3 right-3 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md';
                        card.prepend(indicator);
                    }
                    indicator.textContent = quantity;
                } else {
                    indicator?.remove();
                }
            }
        }
        
        if (state.selectedSetNum === setNum) {
            updateSetModalControlsState();
        }
    }
    
    async function handleUpdateMinifigCollection(figNum, quantity) {
        if (quantity > 0) {
            state.minifigCollection[figNum] = { quantity };
            if (!MINIFIG_MAP[figNum]) {
                await fetchMinifigDetails(figNum);
            }
        } else {
            delete state.minifigCollection[figNum];
        }
        saveState();
        
        state.isGridStale = true;
        
        if (state.currentView === 'collection') {
            updateUI();
        } else {
            renderSidebar();
            const card = mainContent.querySelector(`.minifig-card[data-fig-num="${figNum}"]`);
            if (card) {
                let indicator = card.querySelector('.absolute.top-3.right-3');
                if (quantity > 0) {
                    if (!indicator) {
                        indicator = document.createElement('div');
                        indicator.className = 'absolute top-3 right-3 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center z-10 shadow-md';
                        card.prepend(indicator);
                    }
                    indicator.textContent = quantity;
                } else {
                    indicator?.remove();
                }
            }
        }
        
        if (state.selectedFigNum === figNum) {
            renderMinifigModal(false);
        }
        if (state.selectedSetNum) {
            renderSetModal(false); // Re-render the set modal to update button states.
        }
    }

    async function handleBulkUpdatePartsFromSet(setNum, action) {
        if (state.setModal.isBulkUpdating) return;

        state.setModal.isBulkUpdating = true;
        state.setModal.statusMessage = '';
        state.setModal.statusType = '';
        updateSetModalControlsState();

        try {
            const inventory = await fetchAllSetInventory(setNum);

            (inventory || []).forEach(item => {
                const { part, color, quantity } = item;
                if (!state.collection[part.part_num]) {
                    state.collection[part.part_num] = {};
                }
                
                const currentColorId = String(color.id);
                const currentQuantity = state.collection[part.part_num][currentColorId] || 0;
                
                if (action === 'add') {
                    state.collection[part.part_num][currentColorId] = currentQuantity + quantity;
                } else { // remove
                    const newQuantity = currentQuantity - quantity;
                    if (newQuantity > 0) {
                        state.collection[part.part_num][currentColorId] = newQuantity;
                    } else {
                        delete state.collection[part.part_num][currentColorId];
                        if (Object.keys(state.collection[part.part_num]).length === 0) {
                            delete state.collection[part.part_num];
                        }
                    }
                }
            });
            
            saveState();
            
            await fetchMissingCollectionPartDetails();
            await fetchColorDetailsForCollectionParts();
            
            state.setModal.statusMessage = `Детали успешно ${action === 'add' ? 'добавлены' : 'удалены'}.`;
            state.setModal.statusType = 'success';
            state.isGridStale = true;
            updateUI();
        } catch (error) {
            console.error(`Bulk ${action} failed for set ${setNum}:`, error);
            state.setModal.statusMessage = `Ошибка: не удалось ${action === 'add' ? 'добавить' : 'удалить'} детали.`;
            state.setModal.statusType = 'error';
        } finally {
            state.setModal.isBulkUpdating = false;
            if (state.selectedSetNum) {
                renderSetModal(false);
            }
        }
    }

    async function handleBulkAddMinifigParts(figNum) {
        // This function is now only called from the Set Modal
        const minifig = state.setModal.minifigs.find(mf => mf.set_num === figNum);
        if (!minifig || state.setModal.isBulkUpdating) return;

        state.setModal.isBulkUpdating = true;
        state.setModal.statusMessage = `Добавление деталей из "${minifig.set_name}"...`;
        state.setModal.statusType = 'info';
        renderSetModal(false);

        try {
            let parts = minifig.parts;
            if(!parts) parts = await fetchMinifigParts(figNum);
            minifig.parts = parts;

            if (!parts || parts.length === 0) throw new Error("Детали минифигурки не найдены.");

            const quantityMultiplier = minifig.quantity;

            (parts || []).forEach(item => {
                const partId = item.part.part_num;
                const colorId = String(item.color.id);
                const quantityToAdd = item.quantity * quantityMultiplier;

                if (!state.collection[partId]) state.collection[partId] = {};
                const currentQuantity = state.collection[partId][colorId] || 0;
                state.collection[partId][colorId] = currentQuantity + quantityToAdd;
            });

            saveState();
            await Promise.all([
                fetchMissingCollectionPartDetails(),
                fetchColorDetailsForCollectionParts()
            ]);
            
            state.setModal.statusMessage = `Детали из "${minifig.name}" (${parts.length} видов) добавлены.`;
            state.setModal.statusType = 'success';
            
        } catch(error) {
            console.error('Error adding minifig parts:', error);
            state.setModal.statusMessage = 'Ошибка при добавлении деталей.';
            state.setModal.statusType = 'error';
        } finally {
            state.setModal.isBulkUpdating = false;
            if (state.selectedSetNum) renderSetModal(false);
            
            if (state.currentView === 'collection' && state.activeSubView === 'parts') {
                state.isGridStale = true;
                updateUI();
            } else {
                renderSidebar(); // Update counts
            }
        }
    }
    
    function triggerSearch(useCurrentFilters = false) {
        if (!useCurrentFilters) {
            if (state.activeSubView === 'sets') {
                state.sortBy = state.searchQuery ? 'relevance' : 'year_desc';
                state.setFilters = { minYear: '', maxYear: '', minParts: '', maxParts: '' };
            } else if (state.activeSubView === 'minifigs') {
                state.sortBy = state.searchQuery ? 'relevance' : 'name_asc';
            } else { // parts view
                state.sortBy = state.searchQuery ? 'relevance' : 'popularity';
                state.filters.colorIds = [];
                state.filters.inCollectionOnly = false;
            }
        }
        
        state.isGridStale = true;

        if (state.currentView === 'collection') {
            state.selectedCollectionCategoryId = null;
            state.selectedSetCollectionThemeId = null;
            updateUI();
        } else { // catalog
            if (state.activeSubView === 'sets') {
                state.selectedThemeId = null;
                fetchSets();
            } else if (state.activeSubView === 'minifigs') {
                fetchMinifigs();
            } else { // parts
                state.selectedCategoryId = null;
                searchRebrickableParts(state.searchQuery.trim());
            }
        }
    }
    
    function closeModal() {
        const modalContent = document.getElementById('modal-content');
        if (!modalContent || modalContainer.classList.contains('modal-hidden')) {
            return; 
        }
        
        modalContainer.classList.remove('visible');
        modalContent.classList.add('modal-content-leave');
        if (!state.selectedSetNum && !state.isFilterModalOpen && !state.isSettingsModalOpen && !state.selectedFigNum) {
            document.body.classList.remove('overflow-hidden');
        }
        
        modalContent.addEventListener('animationend', () => {
            if (modalContent.classList.contains('modal-content-leave')) {
                state.selectedPartId = null;
                state.modal = {
                    partGroupId: null, partVariations: [], selectedColorId: null,
                    quantity: 1, isLoadingColors: false, isImageLoading: false,
                    partImageUrl: null,
                };
                modalContainer.classList.add('modal-hidden');
                modalContainer.innerHTML = '';
            }
        }, { once: true });
    }

    function closeSetModal() {
        const modalContent = document.getElementById('set-modal-content');
        if (!modalContent || setModalContainer.classList.contains('modal-hidden')) {
            return; 
        }
        
        setModalContainer.classList.remove('visible');
        modalContent.classList.add('modal-content-leave');
        if (!state.selectedPartId && !state.isFilterModalOpen && !state.isSettingsModalOpen && !state.selectedFigNum) {
            document.body.classList.remove('overflow-hidden');
        }
        
        modalContent.addEventListener('animationend', () => {
            if (modalContent.classList.contains('modal-content-leave')) {
                state.selectedSetNum = null;
                state.setModal = { isLoading: false, inventory: [], inventoryPage: 1, hasNextInventoryPage: false, quantity: 1, isBulkUpdating: false, statusMessage: '', statusType: '', currentView: 'details', minifigs: [], areMinifigsLoading: false, };
                setModalContainer.classList.add('modal-hidden');
                setModalContainer.innerHTML = '';
            }
        }, { once: true });
    }

    function closeMinifigModal() {
        const modalContent = document.getElementById('minifig-modal-content');
        if (!modalContent || minifigModalContainer.classList.contains('modal-hidden')) {
            return; 
        }
        
        minifigModalContainer.classList.remove('visible');
        modalContent.classList.add('modal-content-leave');
        if (!state.selectedPartId && !state.selectedSetNum && !state.isFilterModalOpen && !state.isSettingsModalOpen) {
            document.body.classList.remove('overflow-hidden');
        }
        
        modalContent.addEventListener('animationend', () => {
            if (modalContent.classList.contains('modal-content-leave')) {
                state.selectedFigNum = null;
                state.minifigModal = { isLoading: false, quantity: 1 };
                minifigModalContainer.classList.add('modal-hidden');
                minifigModalContainer.innerHTML = '';
            }
        }, { once: true });
    }
    
    function closeFilterModal() {
        const modalContent = document.getElementById('filter-modal-content');
        if (!modalContent || filterModalContainer.classList.contains('modal-hidden')) {
            return; 
        }
        
        state.isFilterModalOpen = false;
        filterModalContainer.classList.remove('visible');
        modalContent.classList.add('modal-content-leave');
        if (!state.selectedPartId && !state.selectedSetNum && !state.isSettingsModalOpen && !state.selectedFigNum) {
            document.body.classList.remove('overflow-hidden');
        }
        
        modalContent.addEventListener('animationend', () => {
            if (modalContent.classList.contains('modal-content-leave')) {
                filterModalContainer.classList.add('modal-hidden');
                filterModalContainer.innerHTML = '';
            }
        }, { once: true });
    }

    function closeSettingsModal() {
        const modalContent = document.getElementById('settings-modal-content');
        if (!modalContent || settingsModalContainer.classList.contains('modal-hidden')) {
            return; 
        }
        
        state.isSettingsModalOpen = false;
        settingsModalContainer.classList.remove('visible');
        modalContent.classList.add('modal-content-leave');
        if (!state.selectedPartId && !state.selectedSetNum && !state.isFilterModalOpen && !state.selectedFigNum) {
            document.body.classList.remove('overflow-hidden');
        }
        
        modalContent.addEventListener('animationend', () => {
            if (modalContent.classList.contains('modal-content-leave')) {
                settingsModalContainer.classList.add('modal-hidden');
                settingsModalContainer.innerHTML = '';
                state.settingsModal.confirmingDelete = null;
            }
        }, { once: true });
    }

    function openModalForPart(partId, groupId, variations) {
        const representativePart = PART_MAP[partId];
        if (!representativePart) { 
            console.error(`Part ${partId} not found in PART_MAP.`);
            return; 
        }
        
        state.selectedPartId = partId;
        state.modal = { 
            partGroupId: groupId,
            partVariations: variations,
            selectedColorId: null, 
            quantity: 1, 
            isLoadingColors: false,
            isImageLoading: false,
            partImageUrl: representativePart.rebrickable_img_url,
        };
        
        renderModal();
        
        if (!representativePart.availableColorIds) {
            fetchPartColors(representativePart.id);
        } else if (representativePart.availableColorIds.length > 0) {
            const sortedColorIds = sortColorIds(representativePart.availableColorIds, representativePart.id);
            state.modal.selectedColorId = sortedColorIds[0];
            const currentQuantity = state.collection[partId]?.[state.modal.selectedColorId] || 0;
            state.modal.quantity = currentQuantity > 0 ? currentQuantity : 1;
            updateModalPartially({ controls: true });
            fetchPartColorSpecifics(representativePart.id, sortedColorIds[0]);
        }
    }

    function openModalForSet(setNum) {
        if (!SET_MAP[setNum]) {
            console.error(`Set ${setNum} not found in SET_MAP.`);
            return;
        }
        state.selectedSetNum = setNum;
        const currentQuantity = state.setCollection[setNum]?.quantity || 0;
        
        state.setModal = {
            isLoading: false,
            inventory: [],
            inventoryPage: 1,
            hasNextInventoryPage: false,
            quantity: currentQuantity > 0 ? currentQuantity : 1,
            isBulkUpdating: false,
            statusMessage: '',
            statusType: '',
            currentView: 'details',
            minifigs: [],
            areMinifigsLoading: false,
        };
        
        renderSetModal(true); // isInitialRender = true
        fetchSetInventory(setNum);
        fetchSetMinifigs(setNum);
    }

    function openModalForMinifig(figNum) {
        if (!MINIFIG_MAP[figNum]) {
            console.error(`Minifig ${figNum} not found in MINIFIG_MAP.`);
            return;
        }
        state.selectedFigNum = figNum;
        const currentQuantity = state.minifigCollection[figNum]?.quantity || 0;
        
        state.minifigModal = {
            isLoading: false,
            quantity: currentQuantity > 0 ? currentQuantity : 1,
        };
        
        renderMinifigModal(true);
    }
    
    function refreshWithNewFilters() {
        state.itemsToDisplay = state.itemsIncrement;
        state.isGridStale = true;
        
        if (state.currentView === 'collection') {
            updateUI();
        } else { // catalog
            if (state.activeSubView === 'sets') {
                if(state.searchQuery || state.selectedThemeId) {
                    fetchSets();
                } else {
                    updateUI();
                }
            } else if (state.activeSubView === 'minifigs') {
                fetchMinifigs();
            } else { // parts
                if (state.searchQuery) {
                    searchRebrickableParts(state.searchQuery.trim());
                } else if (state.selectedCategoryId) {
                    loadPartsForCategory(state.selectedCategoryId);
                } else {
                    updateUI();
                }
            }
        }
    }
    
    document.addEventListener('click', async (e) => {
        if (!(e.target instanceof Element)) return;
        const target = e.target;

        // --- FAVORITE HANDLERS ---
        const favoriteCategoryButton = target.closest('[data-action="toggle-favorite-category"]');
        if (favoriteCategoryButton?.dataset.categoryId) {
            e.stopPropagation(); // Prevent category selection
            const catId = parseInt(favoriteCategoryButton.dataset.categoryId, 10);
            if (state.favoriteCategoryIds.has(catId)) {
                state.favoriteCategoryIds.delete(catId);
            } else {
                state.favoriteCategoryIds.add(catId);
            }
            saveState();
            const scrollContainer = document.getElementById('sidebar-scroll-container');
            const scrollTop = scrollContainer ? scrollContainer.scrollTop : 0;
            renderSidebar();
            const newScrollContainer = document.getElementById('sidebar-scroll-container');
            if (newScrollContainer) newScrollContainer.scrollTop = scrollTop;
            return;
        }

        const favoriteThemeButton = target.closest('[data-action="toggle-favorite-theme"]');
        if (favoriteThemeButton?.dataset.themeId) {
            e.stopPropagation(); // Prevent theme selection/expansion
            const themeId = parseInt(favoriteThemeButton.dataset.themeId, 10);
            if (state.favoriteThemeIds.has(themeId)) {
                state.favoriteThemeIds.delete(themeId);
            } else {
                state.favoriteThemeIds.add(themeId);
            }
            saveState();
            const scrollContainer = document.getElementById('sidebar-scroll-container');
            const scrollTop = scrollContainer ? scrollContainer.scrollTop : 0;
            renderSidebar();
            const newScrollContainer = document.getElementById('sidebar-scroll-container');
            if (newScrollContainer) newScrollContainer.scrollTop = scrollTop;
            return;
        }

        if (target.closest('#scroll-to-top-btn')) {
            mainContent.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
            return;
        }

        if (target.closest('#sidebar-toggle')) {
            state.isSidebarOpen = true;
            updateUI();
            return;
        }
        if (target.closest('#sidebar-close') || target.id === 'sidebar-backdrop') {
            state.isSidebarOpen = false;
            updateUI();
            return;
        }

        const viewButton = target.closest('[data-view]');
        if (viewButton?.dataset.view) {
            const newView = viewButton.dataset.view;
            if (state.currentView === newView) return;
            state.currentView = newView;
            
            // Clear things that are view-specific but keep subview
            state.searchQuery = '';
            state.apiError = null;
            state.isGridStale = true;
            state.selectedCategoryId = null;
            state.selectedCollectionCategoryId = null;
            state.selectedThemeId = null;
            state.selectedSetCollectionThemeId = null;

            if (state.currentView === 'catalog' && state.activeSubView === 'minifigs') {
                fetchMinifigs();
            } else {
                updateUI();
            }
            return;
        }
        
        const subViewButton = target.closest('[data-sub-view]');
        if (subViewButton?.dataset.subView) {
            const newSubView = subViewButton.dataset.subView;
            if (state.activeSubView === newSubView) return;
            
            state.activeSubView = newSubView;
            state.searchQuery = '';
            state.apiError = null;

            if (newSubView === 'minifigs') {
                state.itemsIncrement = 20;
            } else {
                state.itemsIncrement = 48;
            }
            state.itemsToDisplay = state.itemsIncrement;
            
            state.isGridStale = true;
            state.filters = { colorIds: [], inCollectionOnly: false };
            state.setFilters = { minYear: '', maxYear: '', minParts: '', maxParts: '' };
            state.selectedCategoryId = null;
            state.selectedCollectionCategoryId = null;
            state.selectedThemeId = null;
            state.selectedSetCollectionThemeId = null;
            state.searchResultGroups = null;
            state.catalogGroups = null;
            state.setResults = null;
            state.searchSetResults = null;
            state.minifigResults = null;
            state.searchMinifigResults = null;

            if (newSubView === 'sets') state.sortBy = 'year_desc';
            else if (newSubView === 'minifigs') state.sortBy = 'name_asc';
            else state.sortBy = 'popularity';

            if (state.currentView === 'catalog' && newSubView === 'minifigs') {
                fetchMinifigs();
            } else {
                updateUI();
            }
            return;
        }

        if (target.closest('[data-action="show-all-collection-items"]')) {
            if (state.activeSubView === 'parts') state.selectedCollectionCategoryId = null;
            if (state.activeSubView === 'sets') state.selectedSetCollectionThemeId = null;
            state.isGridStale = true;
            const scrollContainer = document.getElementById('sidebar-scroll-container');
            const scrollTop = scrollContainer ? scrollContainer.scrollTop : 0;
            updateUI();
            const newScrollContainer = document.getElementById('sidebar-scroll-container');
            if (newScrollContainer) newScrollContainer.scrollTop = scrollTop;
            return;
        }
        
        const themeButton = target.closest('[data-theme-id]');
        if (themeButton?.dataset.themeId) {
            const themeId = parseInt(themeButton.dataset.themeId, 10);
            const themeNode = THEME_MAP[themeId];
            const hasChildren = themeNode && Array.isArray(themeNode.children) && themeNode.children.length > 0;
            
            if (hasChildren) {
                const isExpanded = state.expandedThemes.has(themeId);
                if (isExpanded) { state.expandedThemes.delete(themeId); } 
                else { state.expandedThemes.add(themeId); }
            }

            if (state.currentView === 'collection') {
                 if (state.selectedSetCollectionThemeId !== themeId) {
                     state.selectedSetCollectionThemeId = themeId;
                     state.isGridStale = true;
                     updateUI();
                 }
            } else { // catalog
                if (state.selectedThemeId !== themeId) {
                    state.selectedThemeId = themeId;
                    state.searchQuery = '';
                    state.sortBy = 'year_desc';
                    state.setFilters = { minYear: '', maxYear: '', minParts: '', maxParts: '' };
                    fetchSets();
                }
            }
            // re-render sidebar for expansion icon
            if(hasChildren) renderSidebar();
            return;
        }

        const parentCategoryButton = target.closest('[data-parent-category]');
        if(parentCategoryButton?.dataset.parentCategory) {
            const groupName = parentCategoryButton.dataset.parentCategory;
            const isExpanded = state.expandedCategories.has(groupName);

            if (isExpanded) { state.expandedCategories.delete(groupName); } 
            else { state.expandedCategories.add(groupName); }

            const sublist = parentCategoryButton.nextElementSibling;
            if (sublist && sublist.tagName === 'UL') { sublist.classList.toggle('hidden', isExpanded); }
            const icon = parentCategoryButton.querySelector('svg:last-child');
            if (icon) { icon.classList.toggle('rotate-180', !isExpanded); }
            return;
        }

        const categoryButton = target.closest('[data-category-id]');
        if (categoryButton?.dataset.categoryId) {
            const catId = parseInt(categoryButton.dataset.categoryId, 10);
            state.searchQuery = '';
            
            if (state.currentView === 'collection') {
                if(state.selectedCollectionCategoryId !== catId) {
                    state.selectedCollectionCategoryId = catId;
                    state.isGridStale = true;
                    updateUI();
                }
            } else {
                if(state.selectedCategoryId !== catId) {
                    state.selectedCategoryId = catId;
                    state.filters = { colorIds: [], inCollectionOnly: false };
                    state.sortBy = 'popularity';
                    loadPartsForCategory(catId);
                }
            }
            return;
        }

        if(target.closest('#load-more-button')) {
            state.itemsToDisplay += state.itemsIncrement;
            renderMainContent();
            return;
        }

        if(target.closest('#feeling-lucky-button')) { handleFeelingLucky(); return; }
        
        const deleteButton = target.closest('[data-action="delete-from-collection"]');
        if (deleteButton?.dataset.partId && deleteButton.dataset.colorId) {
            await handleUpdateCollection(deleteButton.dataset.partId, deleteButton.dataset.colorId, 0);
            return;
        }

        const minifigCard = target.closest('.minifig-card');
        if (minifigCard?.dataset.figNum) {
            openModalForMinifig(minifigCard.dataset.figNum);
            return;
        }

        const setCard = target.closest('.set-card');
        if (setCard?.dataset.setNum) {
            openModalForSet(setCard.dataset.setNum);
            return;
        }
        
        const partCard = target.closest('.part-card');
        if (partCard?.dataset.groupId && partCard.dataset.partId) {
            const partId = partCard.dataset.partId;
            const groupId = partCard.dataset.groupId;
            
            const representativePart = PART_MAP[partId];
            if (!representativePart) { return; }

            let variations = [representativePart];
            if (state.currentView === 'catalog') {
                const groupsSource = state.searchResultGroups || state.catalogGroups;
                variations = (groupsSource && groupsSource[groupId]) ? groupsSource[groupId] : [representativePart];
            } else {
                const allParts = Object.values(PART_MAP);
                variations = allParts
                    .filter(p => getGroupId(p.part_num) === groupId)
                    .sort(partRelevanceComparator);
                if (variations.length === 0) variations = [representativePart];
            }
            
            openModalForPart(partId, groupId, variations);
            if (state.currentView === 'collection' && partCard.dataset.colorId) {
                state.modal.selectedColorId = partCard.dataset.colorId;
                const currentQuantity = state.collection[partId]?.[state.modal.selectedColorId] || 0;
                state.modal.quantity = currentQuantity > 0 ? currentQuantity : 1;
                updateModalPartially({ controls: true });
                fetchPartColorSpecifics(partId, state.modal.selectedColorId);
            }
            return;
        }
        
        if (target.id === 'modal-container' || target.closest('#modal-close')) { closeModal(); return; }
        if (target.id === 'set-modal-container' || target.closest('#set-modal-close')) { closeSetModal(); return; }
        if (target.id === 'minifig-modal-container' || target.closest('#minifig-modal-close')) { closeMinifigModal(); return; }
        if (target.id === 'filter-modal-container' || target.closest('#filter-modal-close')) { closeFilterModal(); return; }
        if (target.id === 'settings-modal-container' || target.closest('#settings-modal-close')) { closeSettingsModal(); return; }

        if (target.closest('#search-button')) { triggerSearch(); return; }
        if (target.closest('#clear-search')) {
            state.searchQuery = '';
            document.getElementById('search-input')?.focus();
            triggerSearch();
            return;
        }
        
        if (target.closest('#filter-button')) {
            state.isFilterModalOpen = true;
            tempFilters = {
                filters: JSON.parse(JSON.stringify(state.filters)),
                setFilters: JSON.parse(JSON.stringify(state.setFilters)),
                sortBy: state.sortBy
            };
            renderFilterModal();
            return;
        }
        
        if (target.closest('#settings-button')) {
            state.isSettingsModalOpen = true;
            renderSettingsModal();
            return;
        }

        const filterAction = target.closest('[data-action="remove-filter"]');
        if (filterAction) {
            const type = filterAction.dataset.filterType;
            if (type === 'color') {
                 const colorIdToRemove = filterAction.dataset.colorId;
                 if (colorIdToRemove) {
                    state.filters.colorIds = state.filters.colorIds.filter(id => id !== colorIdToRemove);
                 }
            }
            if (type === 'inCollectionOnly') state.filters.inCollectionOnly = false;
            if (type === 'sortBy') state.sortBy = state.searchQuery ? 'relevance' : 'popularity';
            refreshWithNewFilters();
            return;
        }

        if (target.closest('[data-action="remove-all-filters"]')) {
            if (state.activeSubView === 'sets') {
                state.setFilters = { minYear: '', maxYear: '', minParts: '', maxParts: '' };
                state.sortBy = state.searchQuery ? 'relevance' : 'year_desc';
            } else if (state.activeSubView === 'minifigs') {
                state.sortBy = state.searchQuery ? 'relevance' : 'name_asc';
            } else {
                state.filters.colorIds = [];
                state.filters.inCollectionOnly = false;
                state.sortBy = state.searchQuery ? 'relevance' : 'popularity';
            }
            refreshWithNewFilters();
            return;
        }
        
        if(settingsModalContainer?.contains(target)) {
            const actionTarget = target.closest('[data-action]');
            if(!actionTarget) return;
            const { action } = actionTarget.dataset;

            switch(action) {
                case 'delete-all-parts': state.settingsModal.confirmingDelete = 'parts'; renderSettingsModal(); break;
                case 'delete-all-sets': state.settingsModal.confirmingDelete = 'sets'; renderSettingsModal(); break;
                case 'delete-all-minifigs': state.settingsModal.confirmingDelete = 'minifigs'; renderSettingsModal(); break;
                case 'cancel-delete': state.settingsModal.confirmingDelete = null; renderSettingsModal(); break;
                case 'confirm-delete-parts':
                    state.collection = {};
                    saveState();
                    state.settingsModal.confirmingDelete = null;
                    renderSettingsModal();
                    updateUI();
                    break;
                case 'confirm-delete-sets':
                    state.setCollection = {};
                    saveState();
                    state.settingsModal.confirmingDelete = null;
                    renderSettingsModal();
                    updateUI();
                    break;
                case 'confirm-delete-minifigs':
                    state.minifigCollection = {};
                    saveState();
                    state.settingsModal.confirmingDelete = null;
                    renderSettingsModal();
                    updateUI();
                    break;
            }
            return;
        }

        if(minifigModalContainer?.contains(target)) {
            const actionTarget = target.closest('[data-action]');
            if(!actionTarget) return;
            const { action } = actionTarget.dataset;

            switch(action) {
                case 'decrease-minifig-qty':
                    if (state.minifigModal.quantity > 1) {
                        state.minifigModal.quantity--;
                        renderMinifigModal(false);
                    }
                    break;
                case 'increase-minifig-qty':
                    state.minifigModal.quantity++;
                    renderMinifigModal(false);
                    break;
                case 'update-minifig-collection':
                    if (state.selectedFigNum) {
                        await handleUpdateMinifigCollection(state.selectedFigNum, state.minifigModal.quantity);
                    }
                    break;
                case 'delete-from-minifig-collection-modal':
                    if (state.selectedFigNum) {
                        await handleUpdateMinifigCollection(state.selectedFigNum, 0);
                        state.minifigModal.quantity = 1;
                    }
                    break;
            }
            return;
        }

        if(setModalContainer?.contains(target)) {
            const actionTarget = target.closest('[data-action]');
            if(!actionTarget) return;
            const { action, themeId, figNum, quantity } = actionTarget.dataset;

            switch(action) {
                case 'toggle-set-modal-view':
                    state.setModal.currentView = state.setModal.currentView === 'details' ? 'inventory' : 'details';
                    renderSetModal(false);
                    break;
                case 'load-more-inventory':
                    if (state.selectedSetNum) {
                        fetchSetInventory(state.selectedSetNum, state.setModal.inventoryPage + 1);
                    }
                    break;
                case 'decrease-set-qty':
                    if (state.setModal.quantity > 1) {
                        state.setModal.quantity--;
                        updateSetModalControlsState();
                    }
                    break;
                case 'increase-set-qty':
                    state.setModal.quantity++;
                    updateSetModalControlsState();
                    break;
                case 'update-set-collection':
                    if (state.selectedSetNum) {
                        handleUpdateSetCollection(state.selectedSetNum, state.setModal.quantity);
                    }
                    break;
                case 'delete-from-set-collection-modal':
                    if (state.selectedSetNum) {
                        handleUpdateSetCollection(state.selectedSetNum, 0);
                        state.setModal.quantity = 1;
                    }
                    break;
                case 'go-to-theme':
                    if (themeId) {
                        closeSetModal();
                        state.currentView = 'catalog';
                        state.activeSubView = 'sets';
                        state.selectedThemeId = parseInt(themeId, 10);
                        fetchSets();
                    }
                    break;
                case 'bulk-add-parts':
                    if (state.selectedSetNum) handleBulkUpdatePartsFromSet(state.selectedSetNum, 'add');
                    break;
                case 'bulk-remove-parts':
                    if (state.selectedSetNum) handleBulkUpdatePartsFromSet(state.selectedSetNum, 'remove');
                    break;
                case 'toggle-minifig-parts':
                    if(figNum) {
                        const minifig = state.setModal.minifigs.find(mf => mf.set_num === figNum);
                        if (minifig) {
                            minifig.isExpanded = !minifig.isExpanded;
                            if (minifig.isExpanded && !minifig.parts) {
                                minifig.isLoadingParts = true;
                                renderSetModal(false);
                                fetchMinifigParts(figNum).then(parts => {
                                    minifig.parts = parts;
                                    minifig.isLoadingParts = false;
                                    if(state.selectedSetNum) renderSetModal(false);
                                });
                            } else {
                                renderSetModal(false);
                            }
                        }
                    }
                    break;
                case 'add-minifig-to-collection':
                    if (figNum && quantity) {
                        const currentQty = state.minifigCollection[figNum]?.quantity || 0;
                        await handleUpdateMinifigCollection(figNum, currentQty + parseInt(quantity, 10));
                    }
                    break;
                case 'add-minifig-parts-to-collection':
                    if (figNum) {
                        handleBulkAddMinifigParts(figNum);
                    }
                    break;
            }
            return;
        }

        if(filterModalContainer?.contains(target)) {
            const actionTarget = target.closest('[data-action]');
            if(!actionTarget) return;
            const { action, colorId } = actionTarget.dataset;

            switch(action) {
                case 'modal-set-sort':
                    // This is handled by the change event listener now
                    break;
                case 'modal-toggle-collection':
                    // This is handled by the change event listener now
                    break;
                case 'modal-set-color':
                    if (colorId === 'null') {
                        tempFilters.filters.colorIds = [];
                    } else if (colorId) {
                        const index = tempFilters.filters.colorIds.indexOf(colorId);
                        if (index > -1) {
                            tempFilters.filters.colorIds.splice(index, 1);
                        } else {
                            tempFilters.filters.colorIds.push(colorId);
                        }
                    }
                    updateFilterModalUI();
                    break;
                case 'modal-reset-filters':
                    if (state.activeSubView === 'sets') {
                        tempFilters.sortBy = state.searchQuery ? 'relevance' : 'year_desc';
                        tempFilters.setFilters = { minYear: '', maxYear: '', minParts: '', maxParts: ''};
                    } else if (state.activeSubView === 'minifigs') {
                        tempFilters.sortBy = state.searchQuery ? 'relevance' : 'name_asc';
                    } else {
                        tempFilters.sortBy = state.searchQuery ? 'relevance' : 'popularity';
                        tempFilters.filters = { colorIds: [], inCollectionOnly: false };
                    }
                    renderFilterModal();
                    break;
                case 'modal-apply-filters':
                    state.filters = tempFilters.filters;
                    state.setFilters = tempFilters.setFilters;
                    state.sortBy = tempFilters.sortBy;
                    closeFilterModal();
                    refreshWithNewFilters();
                    break;
            }
            return;
        }
        
        if(modalContainer?.contains(target)) {
            const actionTarget = target.closest('[data-action]');
            if(actionTarget) {
                const { action, categoryId } = actionTarget.dataset;
                switch(action) {
                    case 'go-to-category':
                        if (categoryId) {
                            closeModal();
                            state.currentView = 'catalog';
                            state.activeSubView = 'parts';
                            state.selectedCategoryId = parseInt(categoryId, 10);
                            loadPartsForCategory(state.selectedCategoryId);
                        }
                        break;
                    case 'decrease-qty':
                        if (state.modal.quantity > 1) {
                            state.modal.quantity--;
                            updateModalControlsState();
                        }
                        break;
                    case 'increase-qty':
                        state.modal.quantity++;
                        updateModalControlsState();
                        break;
                    case 'update-collection':
                        if (state.selectedPartId && state.modal.selectedColorId) {
                            handleUpdateCollection(state.selectedPartId, state.modal.selectedColorId, state.modal.quantity);
                        }
                        break;
                    case 'delete-from-collection-modal':
                         if (state.selectedPartId && state.modal.selectedColorId) {
                            await handleUpdateCollection(state.selectedPartId, state.modal.selectedColorId, 0);
                            state.modal.quantity = 1; // Reset quantity for next interaction
                            updateModalControlsState();
                        }
                        break;
                }
            }
            
            const colorButton = target.closest('button[data-color-id]');
            if (colorButton && colorButton.dataset.colorId) {
                const newColorId = colorButton.dataset.colorId;
                if (state.modal.selectedColorId !== newColorId) {
                    state.modal.selectedColorId = newColorId;
                    const currentQuantity = state.collection[state.selectedPartId]?.[newColorId] || 0;
                    state.modal.quantity = currentQuantity > 0 ? currentQuantity : 1;
                    
                    updateModalPartially({ colors: true, controls: true });
                    fetchPartColorSpecifics(state.selectedPartId, newColorId);
                }
            }
        }
    });
    
    document.addEventListener('change', (e) => {
        if (!(e.target instanceof Element)) return;
        
        if(e.target.id === 'search-input') {
            state.searchQuery = e.target.value;
            if (state.searchQuery.trim() === '') {
                 triggerSearch();
            }
            renderHeader(); // to show/hide clear button
        }
        
        if (modalContainer && modalContainer.contains(e.target) && e.target.id === 'variation-select') {
            const newPartId = e.target.value;
            if (newPartId && newPartId !== state.selectedPartId) {
                openModalForPart(newPartId, state.modal.partGroupId, state.modal.partVariations);
            }
        }

        if (filterModalContainer && filterModalContainer.contains(e.target)) {
            const target = e.target;
            
            if (target.matches('input[name="sort"]')) {
                tempFilters.sortBy = target.value;
            }
            if(target.matches('[data-action="modal-toggle-collection"]')) {
                tempFilters.filters.inCollectionOnly = target.checked;
            }
            if(target.matches('[data-filter-key]')) {
                 tempFilters.setFilters[target.dataset.filterKey] = target.value;
            }
        }
    });

    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if (state.isSettingsModalOpen) { closeSettingsModal(); return; }
            if (state.isFilterModalOpen) { closeFilterModal(); return; }
            if (state.selectedFigNum) { closeMinifigModal(); return; }
            if (state.selectedSetNum) { closeSetModal(); return; }
            if (state.selectedPartId) { closeModal(); return; }
        }
        if (e.key === 'Enter' && e.target.id === 'search-input') {
            triggerSearch();
        }
    });
    
    mainContent.addEventListener('scroll', (e) => {
        if (mainContent.scrollTop > 300) {
            scrollToTopBtn.classList.remove('opacity-0', 'pointer-events-none', 'translate-y-4');
        } else {
            scrollToTopBtn.classList.add('opacity-0', 'pointer-events-none', 'translate-y-4');
        }
    });

    // --- INITIALIZATION ---
    async function initializeApp() {
        console.log("Initializing LEGO Catalog...");
        loadState();
        updateUI();

        state.isLoading = true;
        updateUI();

        try {
            await Promise.all([
                fetchAllColors(),
                fetchCategories(),
                fetchThemes(),
            ]);
            
            await Promise.all([
                fetchMissingCollectionPartDetails(),
                fetchMissingCollectionSetDetails(),
                fetchMissingCollectionMinifigDetails()
            ]);

            await fetchColorDetailsForCollectionParts();
            
        } catch(error) {
            console.error("Initialization failed:", error);
            state.apiError = `Не удалось загрузить начальные данные: ${error.message}`;
        } finally {
            state.isLoading = false;
            updateUI();
            console.log("Initialization complete.");
        }
    }
    
    initializeApp();

  </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>